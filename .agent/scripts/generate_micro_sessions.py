import os
import json

base_dir = "/Users/mrsono0/Obsidian Vault/0 리서치/_lecture-factory/2026-02-18_AI-native_파이썬기초/01_Planning/micro_sessions"
os.makedirs(base_dir, exist_ok=True)

sessions = [
    # 2-1
    {
        "id": "MS-PY101-023",
        "num": "023",
        "title": "프롬프트의 본질",
        "time": 20,
        "chars": 3000,
        "prev": "022",
        "prev_type": "권장",
        "next": "024",
        "keywords": ["프롬프트", "업무 지시서", "AI 대화"],
        "diff": "low",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 프롬프트를 '단순한 검색어'가 아닌 '업무 지시서'로 정의하고 설명할 수 있다.",
        "hook": "Day 1에서 파이썬 환경을 구축하고 첫 코드를 실행해 봤죠? AI가 코드를 짜줬는데, 생각보다 쉽지 않았나요?",
        "analogy_title": "AI에게 보내는 업무 지시서",
        "analogy": "식당에 가서 '밥 해줘'라고 하면 주방장이 당황하겠죠? 하지만 '2인분 김치찌개를 돼지고기 200g을 넣고 30분 안에 만들어줘'라고 하면 완벽한 요리가 나옵니다. 프롬프트도 똑같습니다.",
        "concept": "프롬프트는 단순한 검색이나 대화가 아닙니다. 고도로 훈련된 전문가(AI)에게 내리는 '구체적인 업무 지시서'입니다. 명확한 지시가 명확한 결과를 만듭니다. 우리는 AI를 마법사가 아닌 '유능한 조수'로 대해야 합니다. 조수에게 일을 시킬 때는 배경 설명, 구체적인 목표, 그리고 원하는 결과물의 형태를 명확히 해야 합니다.",
        "how": "예를 들어 '파이썬 코드 짜줘' 대신, '초보자도 이해할 수 있는 10줄 이내의 파이썬 계산기 코드를 작성하고 주석을 달아줘'라고 요청해 봅니다. 결과의 퀄리티가 완전히 달라집니다.",
        "checkpoint": "프롬프트는 검색어가 아니라 업무 지시서입니다. 그렇다면 완벽한 업무 지시서는 어떻게 작성할까요? 다음 세션에서 4대 요소를 배워보겠습니다.",
        "script": "자, 어제 우리가 콘솔 프로그램을 만들었던 거 기억나시죠? 마치 마차를 타고 가는 것처럼 우리가 직접 모든 걸 제어했어요. 오늘은 그 마차를 현대적인 자동차로 업그레이드하기 위해, AI라는 유능한 운전기사에게 정확한 목적지를 지시하는 방법을 배울 거예요. AI는 눈치 빠른 친구가 아닙니다. 아주 성실하지만 눈치 없는 신입사원이죠. '밥 해줘'라는 두루뭉술한 지시보다는, '2인분 김치찌개를 30분 안에 끓여줘'라고 해야 원하는 결과가 나옵니다. 이것이 바로 프롬프트의 본질입니다.",
        "lab": False,
        "conn_reason": "AI 활용의 기본 마인드셋 수립",
        "bridge": "이렇게 프롬프트의 본질을 이해했으니, 이제 구체적으로 어떤 내용이 들어가야 하는지 배울 준비가 되었어요. 024번 세션에서 프롬프트의 핵심 요소 2가지를 먼저 살펴볼까요?",
    },
    {
        "id": "MS-PY101-024",
        "num": "024",
        "title": "프롬프트 구성 4요소 1 - Persona와 Task",
        "time": 20,
        "chars": 3000,
        "prev": "023",
        "prev_type": "필수",
        "next": "025",
        "keywords": ["Persona", "Task", "역할 부여", "작업 지시"],
        "diff": "medium",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 프롬프트의 4요소 중 Persona와 Task를 명확히 구분하여 작성할 수 있다.",
        "hook": "방금 전 프롬프트가 업무 지시서라는 걸 배웠습니다. 그럼 좋은 지시서에는 무엇이 들어가야 할까요?",
        "analogy_title": "연극 감독의 캐스팅과 대본",
        "analogy": "연극을 무대에 올릴 때, 감독은 배우에게 '너는 20년 경력의 베테랑 형사야(Persona)'라고 역할을 줍니다. 그리고 '범인을 취조해서 자백을 받아내(Task)'라고 임무를 주죠. 역할과 임무가 명확해야 연기가 살아납니다.",
        "concept": "프롬프트의 4요소 중 첫 번째는 Persona(역할)입니다. AI에게 어떤 전문가로 행동할지 정체성을 부여합니다. '너는 10년 차 파이썬 시니어 개발자야'라고 선언하는 순간, AI의 대답 퀄리티가 달라집니다. 두 번째는 Task(작업)입니다. AI가 구체적으로 수행해야 할 단 하나의 명확한 행동입니다. '코드 작성해', '오류 수정해' 등 동사형으로 떨어져야 합니다.",
        "how": "프롬프트 창에 '너는 친절한 파이썬 튜터야(Persona). 파이썬의 변수 개념을 설명해줘(Task)'라고 입력하면, 초보자 눈높이에 맞춘 다정한 설명이 출력됩니다.",
        "checkpoint": "Persona는 역할, Task는 임무입니다. 이 두 가지만 있어도 훌륭한 출발입니다. 하지만 완벽을 위해선 상황과 형식이 필요하죠.",
        "script": "우리가 영화를 찍는다고 상상해 보세요. 길 가는 사람 아무나 붙잡고 '연기해 보세요' 하면 어색하겠죠? AI도 똑같습니다. 먼저 '너는 20년 경력의 베테랑 프로그래머야'라고 캐스팅(Persona)을 해야 합니다. 역할의 옷을 입혀주는 거죠. 그다음엔 '초보자를 위한 가이드 문서를 작성해 줘'라고 구체적인 임무(Task)를 줍니다. 캐스팅과 임무, 이 두 가지가 만나면 AI는 주어진 역할에 100% 몰입해서 여러분이 상상하지 못했던 고퀄리티의 결과물을 쏟아낼 겁니다.",
        "lab": False,
        "conn_reason": "프롬프트 구성의 기초",
        "bridge": "배우에게 역할과 임무를 줬으니, 이제 어떤 무대에서(Context) 어떤 형식으로(Format) 연기할지 알려줘야겠죠? 다음 세션에서 마저 완성해 봅시다.",
    },
    {
        "id": "MS-PY101-025",
        "num": "025",
        "title": "프롬프트 구성 4요소 2 - Context와 Format",
        "time": 25,
        "chars": 4000,
        "prev": "024",
        "prev_type": "필수",
        "next": "026",
        "keywords": ["Context", "Format", "배경 상황", "출력 형식"],
        "diff": "medium",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 프롬프트의 4요소 중 Context와 Format을 활용해 원하는 형태의 결과물을 얻어낼 수 있다.",
        "hook": "역할과 임무를 줬는데도 AI가 엉뚱한 소리를 한다면? 그건 '상황'을 모르기 때문입니다.",
        "analogy_title": "무대 배경과 제출 양식",
        "analogy": "배우가 자신이 '베테랑 형사'인 건 아는데, 배경이 1980년대인지 2026년인지(Context) 모르면 엉뚱한 대사를 칩니다. 또, 보고서를 서면으로 제출할지 PPT로 발표할지(Format) 정해주지 않으면 곤란하겠죠.",
        "concept": "Context(배경/상황)는 AI에게 현재 우리가 처한 제약 조건이나 타겟 독자를 알려주는 요소입니다. '나는 파이썬을 오늘 처음 배운 비전공자야'라는 상황을 주면 설명을 훨씬 쉽게 해줍니다. Format(형식)은 출력물의 형태입니다. 마크다운, 표, 체크리스트, 파이썬 코드 블록 등 원하는 형태를 정확히 묘사해야 합니다.",
        "how": "완성된 4요소: '너는 파이썬 강사야(Persona). 변수의 개념을 설명해줘(Task). 수강생은 코딩을 처음 해보는 중학생이야(Context). 비유를 사용해서 3개의 불릿 포인트로 정리해줘(Format).'",
        "checkpoint": "이 4가지 요소(Persona, Task, Context, Format)가 모이면 AI가 헛발질할 확률이 극적으로 줄어듭니다. 이제 직접 실험해 볼까요?",
        "script": "아무리 훌륭한 요리사라도, 식사하는 사람이 매운 걸 못 먹는 아이라는 '상황(Context)'을 모르면 아주 매운 찌개를 끓여올 수 있습니다. AI에게도 우리의 구체적인 상황을 알려줘야 해요. '내 컴퓨터는 Windows 11이고, 파이썬 3.12를 쓰고 있어'처럼요. 그리고 마지막으로 '형식(Format)'을 지정합니다. '표로 만들어줘', '코드만 출력해줘'라고 명확히 요구하면, 우리가 결과물을 다시 가공할 필요 없이 바로 실무에 가져다 쓸 수 있는 완벽한 형태가 나옵니다. 이 4가지 요소를 꼭 기억하세요!",
        "lab": False,
        "conn_reason": "프롬프트 4요소 완성",
        "bridge": "이론은 완벽하게 배웠습니다. 그럼 이게 실제로 얼마나 큰 차이를 만드는지 026번 세션에서 두 눈으로 직접 확인해 볼까요?",
    },
    {
        "id": "MS-PY101-026",
        "num": "026",
        "title": "좋은 프롬프트 vs 나쁜 프롬프트 비교 실험",
        "time": 25,
        "chars": 4000,
        "prev": "025",
        "prev_type": "필수",
        "next": "027",
        "keywords": ["프롬프트 비교", "Antigravity", "결과 분석"],
        "diff": "low",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 Antigravity 환경에서 나쁜 프롬프트와 좋은 프롬프트의 출력 결과를 직접 비교하고 차이를 분석할 수 있다.",
        "hook": "백문이 불여일견입니다. 지금부터 우리가 배운 4요소가 실제로 어떤 마법을 부리는지 확인해 보겠습니다.",
        "analogy_title": "장님 코끼리 만지기 vs X-Ray 촬영",
        "analogy": "나쁜 프롬프트는 눈을 가리고 코끼리를 만지는 것과 같습니다. AI도 답답해서 아무거나 던져주죠. 좋은 프롬프트는 X-Ray로 코끼리의 뼈대부터 정확히 투시하는 것과 같습니다. 결과물이 투명하고 완벽하게 들어맞습니다.",
        "concept": "실제 코딩 현장에서 프롬프트의 품질은 곧 생산성의 차이로 직결됩니다. 애매하게 질문하면 코드를 고치느라 1시간이 걸리지만, 정확하게 질문하면 1초 만에 완벽한 코드를 얻습니다.",
        "how": "",
        "checkpoint": "눈으로 확인하셨죠? 프롬프트 작성에 1분을 더 쓰면 코드 수정하는 1시간을 아낄 수 있습니다.",
        "script": "이제 여러분의 IDE를 열어주세요. 우리가 두 가지 실험을 할 겁니다. 첫 번째는 AI에게 대충 던져보는 나쁜 프롬프트입니다. '계산기 만들어줘'라고 쳐보세요. 코드가 나오긴 하죠? 하지만 우리가 원했던 모양일까요? 에러 처리는 되어 있나요? 자, 이번엔 우리가 배운 4요소를 장착한 좋은 프롬프트를 입력해 보겠습니다. '너는 10년 차 파이썬 개발자야. 사칙연산을 지원하고 0으로 나누면 에러 메시지를 보여주는 콘솔 계산기 파이썬 코드를 만들어줘. 주석을 상세히 달아줘.' 결과가 어떻게 다른가요? 이 차이가 바로 여러분의 퇴근 시간을 결정합니다.",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 프롬프트의 질적 차이가 결과물의 압도적 차이로 이어진다는 것을 경험한다",
        "lab_steps": [
            {
                "step": 1,
                "time": "5분",
                "inst": "Antigravity에서 '파이썬 계산기 만들어' 입력 후 결과 관찰",
                "res": "단순하고 투박한 코드, 설명 부족",
            },
            {
                "step": 2,
                "time": "10분",
                "inst": "4요소를 포함한 상세 프롬프트 작성 및 입력 (0으로 나누기 예외 처리 포함)",
                "res": "구조화된 코드, 상세한 주석, 예외 처리 포함",
            },
            {
                "step": 3,
                "time": "10분",
                "inst": "두 코드를 비교 분석하여 짝과 차이점 공유",
                "res": "프롬프트 4요소의 중요성 체감",
            },
        ],
        "lab_trouble": "- 흔한 오류: 프롬프트가 너무 길어서 AI가 혼동함 (해결법: 줄바꿈과 기호를 사용해 가독성을 높여서 다시 입력)",
        "conn_reason": "프롬프트 이론의 실전 검증",
        "bridge": "기본적인 대화법은 익혔습니다. 그런데 코드를 짜달라고 할 때는 조금 더 특별한 규칙이 필요해요. 다음 세션에서는 코드 생성 특화 프롬프트를 배워보겠습니다.",
    },
    # 2-2
    {
        "id": "MS-PY101-027",
        "num": "027",
        "title": "코드 생성 특화 프롬프트: 5대 필수 항목",
        "time": 25,
        "chars": 4000,
        "prev": "026",
        "prev_type": "필수",
        "next": "028",
        "keywords": ["코드 생성", "5대 항목", "예외 처리"],
        "diff": "medium",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 코드 생성을 요청할 때 필수적으로 포함해야 하는 5대 항목(기능, 입력, 출력, 제약, 예외)을 열거하고 설명할 수 있다.",
        "hook": "일반 대화 프롬프트와 코딩용 프롬프트는 다릅니다. 기계가 이해할 수 있는 완벽한 청사진을 줘야 하죠.",
        "analogy_title": "건축 설계도 작성하기",
        "analogy": "집을 지을 때 '좋은 집 지어줘'라고 하지 않습니다. 방 개수(기능), 들어올 가구(입력), 보일러 온도(출력), 층고 제한(제약), 불이 났을 때 대피로(예외)까지 명확히 설계도에 적어야 부실공사를 막을 수 있습니다.",
        "concept": "AI에게 코드를 맡길 때 반드시 5가지를 명시해야 합니다. 1) 핵심 기능(무엇을 하는가), 2) 입력(어떤 데이터가 들어가는가), 3) 출력(어떤 결과가 나오는가), 4) 제약 사항(사용하면 안 되는 라이브러리나 조건), 5) 예외 처리(에러가 났을 때 어떻게 방어할 것인가). 이 5가지가 빠지면 코드는 반드시 구멍이 납니다.",
        "how": "프롬프트 작성 시 아예 마크다운 양식을 만들어 '기능:', '입력:', '출력:' 식으로 명시적으로 적어주는 것이 좋습니다.",
        "checkpoint": "코드 생성 5대 항목은 여러분을 버그의 늪에서 구출해 줄 동아줄입니다.",
        "script": "우리가 AI에게 코드를 짜달라고 할 때, 가장 많이 놓치는 게 뭘까요? 바로 '예외 상황'입니다. 사용자가 숫자를 입력해야 하는데 문자를 입력하면 어떻게 할까요? 프로그램이 펑 터지면 안 되겠죠? 그래서 코드 생성 프롬프트는 일반 질문과 달라야 합니다. 마치 견고한 건축 설계도처럼 5가지 기둥이 필요해요. 어떤 기능인지, 입력값은 무엇인지, 출력은 어떤 형태인지, 제약 조건은 무엇인지, 그리고 에러가 날 땐 어떻게 방어할지(예외 처리)를 명시해야 합니다. 이 5가지를 습관처럼 적으세요. 그러면 AI가 짜준 코드를 여러분이 두 번 고칠 일이 없어집니다.",
        "lab": False,
        "conn_reason": "코드 생성을 위한 구체적 방법론 제시",
        "bridge": "설계도를 완벽히 그리는 법을 알았습니다. 그런데 이걸 한 번에 다 그려서 던져주면 AI도 체합니다. 어떻게 해야 할까요? 다음 세션에서 그 비법을 공개합니다.",
    },
    {
        "id": "MS-PY101-028",
        "num": "028",
        "title": "점진적 개선(Iterative Refinement)의 이해",
        "time": 20,
        "chars": 3500,
        "prev": "027",
        "prev_type": "권장",
        "next": "029",
        "keywords": ["점진적 개선", "Iterative Refinement", "단계적 접근"],
        "diff": "medium",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 점진적 개선의 개념을 이해하고, 한 번에 완벽한 코드를 요구하는 대신 단계별로 코드를 발전시키는 이유를 설명할 수 있다.",
        "hook": "복잡한 프로그램 코드를 한 번의 질문으로 완벽하게 얻을 수 있을까요? 천재 개발자도 그렇게는 안 합니다.",
        "analogy_title": "조각상 조각하기",
        "analogy": "미켈란젤로가 다비드 상을 조각할 때, 한 번의 망치질로 눈썹을 파지 않았습니다. 먼저 큰 돌(기본 구조)을 쪼개고, 팔다리 형태(핵심 로직)를 잡은 뒤, 마지막에 손톱(세부 기능/예외)을 깎았습니다. AI 코딩도 조각과 같습니다.",
        "concept": "점진적 개선(Iterative Refinement)은 처음부터 복잡한 요구를 쏟아내지 않고, 뼈대부터 시작해 살을 붙여나가는 방식입니다. AI는 문맥이 길어지면 지시를 무시하거나 환각(Hallucination)을 일으킬 확률이 높아집니다. 핵심 동작을 먼저 확인한 후, 조건을 하나씩 추가하는 것이 가장 빠르고 안전한 개발 방법입니다.",
        "how": "1단계: 기본 뼈대 코드 생성 -> 2단계: 특정 조건 1개 추가 -> 3단계: 예외 처리 및 UI 개선",
        "checkpoint": "작게 시작해서 크게 만드세요. AI와의 티키타카가 핵심입니다.",
        "script": "아무리 뛰어난 AI라도 너무 많은 요구사항을 한꺼번에 던져주면 과부하가 걸려서 중요한 조건을 슬쩍 빼먹곤 합니다. 그래서 우리에겐 전략이 필요해요. 바로 '점진적 개선'입니다. 처음에는 가장 단순한 뼈대만 요청하세요. 코드가 제대로 돌아가는지 확인한 다음에, '좋아, 이제 여기에 숫자만 입력받게 조건을 추가해'라고 한 걸음 더 나아가는 겁니다. 망치질 한 번에 조각상을 완성하려 하지 마세요. AI와 대화하며 찰흙에 살을 붙이듯 코드를 키워나가는 것, 이것이 진정한 AI-native 개발자의 방식입니다.",
        "lab": False,
        "conn_reason": "안정적인 코드 생성을 위한 필수 전략",
        "bridge": "이론만 들으면 감이 잘 안 오죠? 이제 우리가 배운 5대 항목과 점진적 개선법을 합쳐서 직접 프로그램을 만들어 보겠습니다.",
    },
    {
        "id": "MS-PY101-029",
        "num": "029",
        "title": "프롬프트 고도화 실습: 비밀번호 검사기 만들기",
        "time": 25,
        "chars": 4000,
        "prev": "028",
        "prev_type": "필수",
        "next": "030",
        "keywords": ["실습", "비밀번호 강도", "점진적 개선"],
        "diff": "medium",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 점진적 개선 기법을 활용하여 3단계에 걸쳐 비밀번호 강도 검사기 프로그램을 완성할 수 있다.",
        "hook": "자, 이제 우리의 조수를 부려먹을 시간입니다. 단순한 비밀번호 검사기를 철통 보안 시스템으로 업그레이드해 볼까요?",
        "analogy_title": "레고 블록 조립하기",
        "analogy": "설명서 없이 레고 성을 한 번에 만들 순 없죠. 바닥판을 깔고(1단계), 벽을 세우고(2단계), 지붕을 얹는(3단계) 과정을 직접 체험해 봅니다.",
        "concept": "앞서 배운 '프롬프트 5대 항목'과 '점진적 개선'을 실전에 적용합니다. 예측-검증-설명(POE) 사이클을 통해 AI가 준 코드를 무비판적으로 수용하지 않고 동작을 이해하는 것이 핵심입니다.",
        "how": "",
        "checkpoint": "단계별로 코드가 진화하는 것을 확인했습니다. 이렇게 코딩하면 어떤 복잡한 요구사항도 두렵지 않습니다.",
        "script": "이제 실습을 시작하겠습니다. 우리의 목표는 사용자가 입력한 비밀번호가 얼마나 안전한지 검사해 주는 프로그램입니다. 한 번에 '복잡한 조건 다 넣어서 짜줘'라고 하지 않기로 했죠? 1단계 프롬프트부터 입력해 볼까요? '비밀번호를 입력받아 길이를 출력하는 파이썬 프로그램의 뼈대를 만들어줘.' 자, 결과가 잘 나왔나요? 그럼 2단계, '방금 코드에 길이가 8자 이상이면 통과, 아니면 실패를 출력하는 기능을 추가해줘.' 좋습니다. 마지막 3단계로 특수문자 조건과 예외 처리까지 얹어봅시다. 여러분이 AI의 사수가 되어 코드를 훈련시키는 겁니다!",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 복잡한 프로그램을 단계적으로 쪼개서 AI에게 요청하는 워크플로우를 경험한다",
        "lab_steps": [
            {
                "step": 1,
                "time": "5분",
                "inst": "1단계: 길이만 반환하는 기본 뼈대 코드 생성 및 실행 검증",
                "res": "기본 입력/출력 코드 확보",
            },
            {
                "step": 2,
                "time": "7분",
                "inst": "2단계: 8자 이상, 대소문자, 숫자 포함 제약 사항 추가 (점진적 개선)",
                "res": "조건문이 추가된 발전된 코드",
            },
            {
                "step": 3,
                "time": "8분",
                "inst": "3단계: 특수문자 검사 및 에러 처리 추가, 출력 포맷(O/X) 개선",
                "res": "완성도 높은 튼튼한 프로그램",
            },
        ],
        "lab_trouble": "- 흔한 오류: 이전 문맥을 무시하고 완전히 새로운 코드를 뱉어냄 (해결법: '기존 코드를 유지하면서~'라는 제약어 추가)",
        "conn_reason": "배운 기법들의 통합 실습",
        "bridge": "훌륭합니다. 여러분은 이미 상위 10%의 프롬프트 작성자입니다. 하지만 진짜 고수들이 쓰는 비밀 무기가 2개 더 남아있습니다. 궁금하신가요?",
    },
    {
        "id": "MS-PY101-030",
        "num": "030",
        "title": "고급 프롬프트 기법: CoT와 Few-shot",
        "time": 20,
        "chars": 3500,
        "prev": "029",
        "prev_type": "권장",
        "next": "031",
        "keywords": ["CoT", "Few-shot", "생각의 사슬", "예시 제공"],
        "diff": "high",
        "type": "code",
        "goal": "이 세션 종료 시 수강생은 CoT와 Few-shot 프롬프팅 기법을 이해하고, 이를 적용해 AI의 추론 능력과 출력 정확도를 극대화할 수 있다.",
        "hook": "AI가 가끔 바보 같은 실수를 하죠? 똑똑한 AI를 더 똑똑하게 만드는 마법의 주문을 알려드립니다.",
        "analogy_title": "수학 문제 풀이와 모범 답안",
        "analogy": "수학 문제를 풀 때 '답만 적어'라고 하면 찍어서 틀릴 확률이 높지만, '풀이 과정을 단계별로 적어(CoT)'라고 하면 검산하면서 정답률이 확 올라갑니다. 또, '이런 식으로 풀어봐'하고 모범 답안 2~3개(Few-shot)를 보여주면 완벽하게 의도를 파악하죠.",
        "concept": "CoT(Chain of Thought, 생각의 사슬)는 프롬프트에 '단계별로 생각해서 답해줘'라는 마법의 문장을 추가하여 AI의 논리적 추론 능력을 끌어올리는 기법입니다. Few-shot은 Zero-shot(예시 없음)과 대비되는 개념으로, 원하는 입력-출력 예시 쌍을 2~3개 프롬프트에 직접 포함시켜 AI가 패턴을 학습하게 만드는 강력한 방법입니다.",
        "how": "CoT 예: '이 알고리즘을 최적화해. 단, 시간 복잡도를 먼저 분석하고, 그 다음 개선 방안을 단계별로 도출해.'\nFew-shot 예: '입력: apple -> 출력: 사과, 입력: banana -> 출력: 바나나, 입력: grape -> 출력:'",
        "checkpoint": "CoT로 논리를 잡아주고, Few-shot으로 형태를 잡아줍니다. 이 두 가지면 AI 통제는 끝납니다.",
        "script": "AI에게 코드를 짜달라고 했는데 로직이 자꾸 꼬일 때가 있습니다. 이럴 때 쓰는 치트키가 바로 'CoT(생각의 사슬)'입니다. 프롬프트 맨 끝에 이 마법의 한 문장만 붙여보세요. '이 문제를 해결하기 위해 단계별로 논리적으로 생각하고 과정을 설명해 줘.' AI가 자신의 논리를 스스로 점검하면서 에러율이 극적으로 떨어집니다. 또 하나의 치트키는 'Few-shot'입니다. 백 번 설명하는 것보다 예시 하나 보여주는 게 빠르죠? 우리가 원하는 결과물의 예시를 딱 2개만 프롬프트 안에 적어주세요. AI는 눈치가 기가 막히게 빨라져서 여러분이 원하는 완벽한 패턴의 코드를 복사하듯 만들어 냅니다.",
        "lab": False,
        "conn_reason": "프롬프트 역량의 심화",
        "bridge": "지금까지 우리는 AI와 소통하는 '기술'을 배웠습니다. 하지만 AI에게 '무엇'을 시킬지가 명확하지 않다면 기술도 무용지물이겠죠? 이제 소프트웨어의 본질, 요구사항으로 넘어갑니다.",
    },
    # 2-3
    {
        "id": "MS-PY101-031",
        "num": "031",
        "title": "요구사항(Requirements)의 본질: 여행 계획서",
        "time": 20,
        "chars": 3500,
        "prev": "030",
        "prev_type": "권장",
        "next": "032",
        "keywords": ["요구사항", "Requirements", "소프트웨어 설계"],
        "diff": "low",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 소프트웨어 공학에서 '요구사항'의 개념과 그 중요성을 비유를 통해 설명할 수 있다.",
        "hook": "코딩을 시작하기 전, 모니터 앞에 앉자마자 키보드부터 두드리시나요? 그건 지옥으로 가는 급행열차입니다.",
        "analogy_title": "지도 없는 세계여행",
        "analogy": "요구사항 없이 코딩을 시작하는 건, 목적지·예산·숙소 아무것도 없이 일단 공항으로 달려가는 것과 같습니다. 비행기는 탔는데 어디로 가죠? 요구사항은 완벽한 휴가를 위한 '치밀한 여행 계획서'입니다.",
        "concept": "요구사항(Requirements)은 '사용자가 이 소프트웨어를 통해 무엇을 해결하고 싶은가'를 정의한 명세입니다. 기능(무엇을 하는가)과 비기능(얼마나 빠르고 안전한가)으로 나뉩니다. 코드를 한 줄도 짜기 전에 프로그램의 목적과 제약사항을 한국어로 명확히 정리하는 과정이 바로 요구사항 분석입니다. 오류 수정 비용은 뒤로 갈수록 기하급수적으로 커지기 때문에 설계 단계의 요구사항이 가장 중요합니다.",
        "how": "내가 만들 프로그램이 '무엇'을 해야 하고, '무엇'을 하면 안 되는지 텍스트로 쭉 적어보는 것부터 시작합니다.",
        "checkpoint": "코드를 짜는 시간보다 요구사항을 고민하는 시간이 길어야 정상입니다.",
        "script": "많은 초보자들이 실수하는 게 있습니다. 아이디어가 떠오르면 신나서 바로 파이썬 파일부터 만들고 코드를 치기 시작해요. 우리는 이걸 '바이브 코딩(느낌대로 코딩하기)'이라고 부릅니다. 결과는 어떨까요? 중간에 무조건 길을 잃습니다. 전문 개발자들은 키보드에 손을 올리기 전에 펜을 듭니다. '이 프로그램은 정확히 누굴 위한 거지? 필수 기능은 3개가 뭐지? 비밀번호는 몇 자리로 제한하지?' 이걸 꼼꼼히 적은 문서를 우리는 '요구사항'이라고 부릅니다. 이 요구사항이 명확할수록, 여러분이 AI에게 시킬 일이 명확해지고, 완성 속도는 10배 빨라집니다.",
        "lab": False,
        "conn_reason": "코딩 이전의 설계 마인드셋 수립",
        "bridge": "요구사항이 중요하다는 건 알았습니다. 그럼 어떻게 하면 빠트리는 것 없이 꼼꼼하게 요구사항을 적어낼 수 있을까요? 다음 세션에서 마법의 체크리스트를 공개합니다.",
    },
    {
        "id": "MS-PY101-032",
        "num": "032",
        "title": "체계적인 요구사항 도출: 5W1H 체크리스트",
        "time": 25,
        "chars": 4000,
        "prev": "031",
        "prev_type": "필수",
        "next": "033",
        "keywords": ["5W1H", "사용자 스토리", "기능/비기능"],
        "diff": "medium",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 5W1H 방법론을 활용하여 추상적인 아이디어를 구체적인 요구사항 항목으로 세분화할 수 있다.",
        "hook": "머릿속에 아이디어는 가득한데 막상 글로 적으려니 막막하신가요? 뉴스 기사 쓰듯 쪼개면 됩니다.",
        "analogy_title": "육하원칙으로 그리는 몽타주",
        "analogy": "경찰이 범인 몽타주를 그릴 때 '나쁜 사람처럼 생겼어요'라고 안 하죠? 언제(When), 어디서(Where), 누가(Who), 무엇을(What), 어떻게(How), 왜(Why) 했는지 캐묻습니다. 프로그램의 몽타주도 5W1H로 그립니다.",
        "concept": "요구사항을 빠짐없이 도출하기 위해 5W1H를 사용합니다. Who(누가 사용?), What(무엇을 해결?), Why(왜 필요한가?), When/Where(언제, 어떤 환경에서 동작?), How(어떻게 구현, 제약사항). 이 질문들에 답을 채우다 보면 자연스럽게 '기능 요구사항(등록, 수정 등)'과 '비기능 요구사항(반응속도, 보안)'이 구별되어 도출됩니다.",
        "how": "포스트잇이나 엑셀을 열고 육하원칙 질문을 던지세요. 'Who: 상점 주인이 / What: 고객 연락처를 / How: 콘솔 창에서 텍스트 입력으로 관리한다.'",
        "checkpoint": "5W1H는 추상적인 아이디어를 콘크리트처럼 단단한 구조로 만들어 줍니다.",
        "script": "여러분이 '고객 정보 관리 프로그램'을 만든다고 해봅시다. 빈 종이에 적으려니 막막하죠? 이때 육하원칙(5W1H)을 꺼내세요. 첫째, Who! 누가 쓰죠? 컴퓨터를 잘 모르는 동네 빵집 사장님. 둘째, Where! 어디서? 사장님의 오래된 Windows 노트북. 셋째, What! 뭘 할 건데요? 고객 이름과 폰번호를 저장하고 싶대요. 벌써 감이 오지 않나요? 아, 화면은 크고 글씨가 잘 보여야겠구나(비기능), 이름과 폰번호만 입력받으면 되겠구나(기능). 이렇게 5W1H 체크리스트에 답을 달기만 해도 완벽한 기초 설계도가 탄생합니다.",
        "lab": False,
        "conn_reason": "구체적인 요구사항 작성 기법 학습",
        "bridge": "이렇게 꼼꼼히 정리한 요구사항, 이제 우리가 직접 코드를 다 짤 필요가 없죠? AI 시대에 걸맞은 새로운 개발 패러다임을 만나러 가시죠.",
    },
    {
        "id": "MS-PY101-033",
        "num": "033",
        "title": "SDD(Specification-Driven Development)의 이해",
        "time": 20,
        "chars": 3500,
        "prev": "032",
        "prev_type": "권장",
        "next": "034",
        "keywords": ["SDD", "명세 주도 개발", "바이브 코딩 극복"],
        "diff": "high",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 SDD의 개념을 설명하고, 왜 AI 시대에 SDD가 핵심 개발 방법론인지 이해한다.",
        "hook": "요즘 유행하는 말 중 '바이브 코딩'이 있죠. 느낌대로 AI한테 시켜서 코딩한다는 뜻인데... 과연 실무에서도 통할까요?",
        "analogy_title": "대기업의 외주 발주",
        "analogy": "구멍가게는 '알아서 인테리어 예쁘게 해주세요'라고 외주를 줍니다(바이브 코딩). 하지만 대기업은 수백 페이지의 '요구사항 명세서'를 던지고 이대로만 만들라고 합니다(SDD). 우리는 AI라는 거대한 외주사를 부리는 대기업이 되어야 합니다.",
        "concept": "SDD(Specification-Driven Development, 명세 주도 개발)는 코드를 직접 작성하는 대신 '명세서(사양서)' 작성에 모든 역량을 집중하는 개발 방법입니다. 코딩은 AI가 훨씬 빠르고 잘합니다. 인간의 역할은 '무엇을 만들 것인가'를 오해의 여지 없이 완벽하게 묘사한 명세서를 쓰는 것으로 옮겨갔습니다. 완벽한 명세서가 있으면 코드는 버튼 클릭 한 번으로 생성됩니다.",
        "how": "코드를 치고 싶어 안달 난 손을 묶고, 마크다운으로 요구사항과 기능 목록을 먼저 완벽하게 문서화하는 훈련을 해야 합니다.",
        "checkpoint": "코딩의 주도권은 AI에게 넘기세요. 여러분은 '설계'의 주도권을 잡아야 합니다.",
        "script": "과거에는 개발자가 하루 종일 까만 화면에 코드를 타이핑했습니다. 하지만 AI 시대가 오면서 판이 바뀌었어요. 이제 코드를 짜는 건 AI의 몫입니다. 그럼 인간은 뭘 할까요? 바로 SDD, 명세 주도 개발을 합니다. '명세'란 프로그램을 아주 정밀하게 묘사한 문서입니다. 우리가 방금 배운 5W1H로 명세서를 기가 막히게 잘 써서 AI에게 던져주면, AI는 1초 만에 천 줄짜리 완벽한 코드를 짜냅니다. 대충 말하면 대충 짜고, 정밀하게 말하면 정밀하게 짭니다. 결국 AI 시대 최고 개발자의 조건은 코딩 실력이 아니라 '명세서 작성 능력'이 된 겁니다.",
        "lab": False,
        "conn_reason": "AI-native 개발의 핵심 철학 이해",
        "bridge": "이론적인 이야기는 여기까지입니다. 이제 우리가 배운 걸 총동원해서, AI와 함께 완벽한 요구사항 명세서를 직접 뽑아내 볼까요?",
    },
    {
        "id": "MS-PY101-034",
        "num": "034",
        "title": "AI와 함께하는 요구사항 작성 실습",
        "time": 25,
        "chars": 4000,
        "prev": "033",
        "prev_type": "필수",
        "next": "035",
        "keywords": ["요구사항 초안", "고객 정보 관리", "실습"],
        "diff": "medium",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 AI(Gemini)를 활용하여 자신의 초기 아이디어를 체계적인 요구사항 문서 초안으로 발전시킬 수 있다.",
        "hook": "명세서 작성이 어렵게 들리나요? 걱정 마세요. 명세서 작성도 AI가 도와줄 겁니다.",
        "analogy_title": "전문 컨설턴트 고용하기",
        "analogy": "창업 아이디어만 들고 가면, 전문 컨설턴트가 시장 분석부터 수익 모델까지 기획서로 쫙 뽑아주죠. 우리는 지금 AI라는 세계 최고의 기획 컨설턴트를 무료로 고용하는 겁니다.",
        "concept": "나의 투박하고 추상적인 아이디어 한 줄을 AI에게 던지고, '이를 바탕으로 5W1H에 맞춘 전문적인 소프트웨어 요구사항 명세서를 작성해줘'라고 프롬프트를 작성하여 초안을 확보하는 실습입니다.",
        "how": "",
        "checkpoint": "빈 종이의 공포는 AI가 없애줍니다. 여러분은 생성된 초안을 입맛에 맞게 '편집'만 하시면 됩니다.",
        "script": "이제 직접 손을 움직여 봅시다. 여러분이 파이썬으로 '고객 정보 관리 프로그램'을 만든다고 가정해 볼게요. 아이디어는 단순합니다. '고객 이름이랑 전화번호 저장하고, 검색하고, 지우는 기능이 있었으면 좋겠어.' 이걸 여러분이 직접 5W1H로 분류해서 써도 좋지만, 우리는 AI-native잖아요? 프롬프트 창을 엽니다. '너는 15년 차 시니어 IT 기획자야. 내가 콘솔 기반의 파이썬 고객 정보 관리 프로그램을 만들고 싶어. 이 아이디어를 바탕으로 5W1H 구조와 필수 기능 요구사항(FR), 비기능 요구사항(NFR)으로 깔끔하게 정리된 초안을 마크다운으로 작성해 줘.' 엔터를 쳐보세요. 어떤 마법이 벌어지는지 눈으로 확인합시다.",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 추상적 아이디어가 AI를 통해 구조화된 요구사항으로 변환되는 마법을 경험한다",
        "lab_steps": [
            {
                "step": 1,
                "time": "5분",
                "inst": "각자 생각하는 '고객 정보 프로그램'의 기능을 메모장(포스트잇)에 3개 이상 적기",
                "res": "비정형화된 아이디어 도출",
            },
            {
                "step": 2,
                "time": "10분",
                "inst": "작성한 아이디어를 재료로 삼아 AI에게 요구사항 명세서 초안 작성 프롬프트 요청",
                "res": "구조화된 마크다운 요구사항 초안 생성",
            },
            {
                "step": 3,
                "time": "10분",
                "inst": "생성된 결과를 보고 내가 생각지 못했던 기획(예외 처리, 데이터 저장 등) 발견하고 보완하기",
                "res": "초안 리뷰 및 개선 완료",
            },
        ],
        "lab_trouble": "- 흔한 오류: AI가 너무 복잡한 웹 서비스 수준의 기획안을 던져줌 (해결법: '초보자를 위한 콘솔 텍스트 기반으로 범위를 축소해줘'라고 추가 지시)",
        "conn_reason": "요구사항 도출의 실제 적용",
        "bridge": "요구사항 초안이 멋지게 나왔네요. 그런데 실무에서는 이걸 더 전문적인 문서 양식으로 바꿉니다. 바로 'PRD'라는 건데요, 035번 세션에서 알아보겠습니다.",
    },
    # 2-4
    {
        "id": "MS-PY101-035",
        "num": "035",
        "title": "PRD(Product Requirements Document)란 무엇인가?",
        "time": 20,
        "chars": 3500,
        "prev": "034",
        "prev_type": "권장",
        "next": "036",
        "keywords": ["PRD", "제품 요구사항 문서", "기획 마스터"],
        "diff": "low",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 PRD의 정의를 이해하고, 단순한 기능 목록과 PRD의 차이점을 설명할 수 있다.",
        "hook": "실리콘밸리의 PM(프로덕트 매니저)들이 가장 많은 시간을 쏟는 문서, 바로 PRD입니다. 대체 뭐길래 그럴까요?",
        "analogy_title": "요리 레시피의 완전판",
        "analogy": "요구사항이 '재료 목록(당근, 양파, 고기)'이라면, PRD는 완성된 '마스터 레시피'입니다. 이 요리를 왜 만드는지(목적), 누가 먹을 것인지(대상), 어떤 순서로 조리하며(시나리오), 다 만들면 어떤 맛이 나야 성공인지(지표)까지 모두 담겨 있습니다.",
        "concept": "PRD(Product Requirements Document, 제품 요구사항 문서)는 개발될 소프트웨어 제품의 목적, 기능, 동작 방식 등을 종합적으로 서술한 마스터 문서입니다. 앞서 배운 요구사항이 기능 위주의 나열이었다면, PRD는 '왜(Why)'와 '사용자(User)'의 관점이 강하게 녹아들어 있습니다. 개발자, 디자이너, 테스터 등 모든 팀원이 이 문서 하나만 보고 같은 목표를 향해 달릴 수 있게 해주는 '나침반' 역할을 합니다.",
        "how": "기존에 만든 요구사항 초안에 '배경 및 목적', '타겟 사용자', '성공 지표'를 덧붙여 문서를 확장합니다.",
        "checkpoint": "좋은 PRD 하나면 수백 번의 회의를 없앨 수 있습니다. 그리고 AI에게는 가장 완벽한 컨텍스트(Context)가 됩니다.",
        "script": "우리가 앞서 요구사항을 뽑아봤죠? '고객 이름 저장, 삭제, 검색 기능' 등등. 이건 훌륭한 '재료'입니다. 하지만 진짜 멋진 소프트웨어를 만들려면 이 재료들을 요리할 '완벽한 레시피'가 필요해요. 그걸 실무에서는 PRD, 제품 요구사항 문서라고 부릅니다. PRD는 단순한 기능 나열이 아니에요. '우리가 왜 이 골치 아픈 프로그램을 만들지?', '도대체 누가 쓸 건데?' 같은 제품의 존재 이유부터 시작합니다. 그리고 이게 다 만들어졌을 때 '어떤 상태가 되어야 성공한 거지?'라는 목표점까지 명확히 찍어주죠. 우리가 AI에게 코드를 맡길 때 이 PRD를 통째로 던져주면, AI는 기능만 돌아가는 깡통이 아니라 '맥락을 이해한' 완벽한 프로그램을 짜줍니다.",
        "lab": False,
        "conn_reason": "실무 표준 문서 체계 이해",
        "bridge": "그렇다면 이 마법의 문서 PRD는 구체적으로 어떻게 생겼을까요? 다음 세션에서 PRD의 뼈대를 낱낱이 파헤쳐 보겠습니다.",
    },
    {
        "id": "MS-PY101-036",
        "num": "036",
        "title": "PRD의 핵심 구조와 기능 명세(FR) 작성법",
        "time": 25,
        "chars": 4000,
        "prev": "035",
        "prev_type": "필수",
        "next": "037",
        "keywords": ["FR", "기능 명세", "구조화"],
        "diff": "medium",
        "type": "code",
        "goal": "이 세션 종료 시 수강생은 PRD의 표준 템플릿 구조를 파악하고, 각 기능을 식별자(FR-001 등)를 부여하여 체계적으로 명세할 수 있다.",
        "hook": "회사마다 PRD 양식은 다르지만, 절대 빠지지 않는 불변의 뼈대가 있습니다. 그 구조를 배워봅시다.",
        "analogy_title": "도서관의 청구기호",
        "analogy": "도서관에서 책을 찾을 때 '파란색 표지의 소설책'이라고 안 하죠? '813.6-김123'처럼 청구기호를 씁니다. 기능도 마찬가지로 '사용자 추가 기능' 대신 'FR-001'이라는 명확한 라벨링을 해야 헷갈리지 않습니다.",
        "concept": "PRD의 기본 구조는 1. 개요/배경, 2. 대상 사용자, 3. 사용자 시나리오, 4. 기능 요구사항(FR), 5. 비기능 요구사항(NFR)으로 이루어집니다. 이 중 가장 중요한 4번 기능 요구사항(Functional Requirements)을 작성할 때는 FR-001(고객 등록), FR-002(고객 조회)처럼 고유 식별코드를 부여합니다. 이렇게 해야 추후 코드를 작성하거나 테스트할 때 특정 기능의 누락 여부를 정확히 추적(Traceability)할 수 있습니다.",
        "how": "테이블 형태로 'ID | 기능명 | 설명 | 우선순위'를 정리합니다. 예: FR-001 | 신규 고객 등록 | 이름, 폰번호를 입력받아 리스트에 저장한다 | High",
        "checkpoint": "이름표(FR-OOO)를 붙여주면 기능들이 체계적으로 관리되기 시작합니다.",
        "script": "PRD 문서의 허리 역할을 하는 가장 중요한 파트, 바로 기능 명세입니다. 여러분이 건물을 지을 때 배관, 전기, 도색 작업에 각각 번호를 매겨서 관리하듯, 소프트웨어의 기능에도 고유 번호를 붙여줘야 해요. 실무에서는 보통 'FR(Functional Requirement)'이라는 약자에 숫자를 붙입니다. 고객 정보를 새로 등록하는 기능은 'FR-001', 검색하는 기능은 'FR-002' 이런 식이죠. 왜 이렇게 딱딱하게 하냐고요? 나중에 AI가 코드를 짜줬을 때, '야, 너 FR-002 기능 빼먹었어 다시 짜와'라고 정확하게 지적하기 위해서입니다. 구조화된 문서가 구조화된 코드를 낳습니다.",
        "lab": False,
        "conn_reason": "PRD 작성의 핵심 실무 기법",
        "bridge": "기능들을 엑셀 표처럼 정리하는 법을 알았습니다. 그런데 사용자는 표를 보고 프로그램을 쓰지 않죠? 흐름을 타며 씁니다. 바로 이 '흐름'을 문서에 담아볼까요?",
    },
    {
        "id": "MS-PY101-037",
        "num": "037",
        "title": "사용자 시나리오와 성공 지표 정의",
        "time": 20,
        "chars": 3500,
        "prev": "036",
        "prev_type": "필수",
        "next": "038",
        "keywords": ["사용자 시나리오", "성공 지표", "User Story"],
        "diff": "medium",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 시간의 흐름에 따른 사용자 시나리오를 작성하고, 프로그램의 성공 여부를 판단할 지표를 정의할 수 있다.",
        "hook": "단추, 지퍼, 소매... 옷의 부속품(기능)을 다 늘어놓는다고 멋진 옷이 될까요? 직접 입어보는 과정(시나리오)이 필요합니다.",
        "analogy_title": "영화 스토리보드 그리기",
        "analogy": "영화감독은 대본을 쓰기 전에 주인공이 어떤 순서로 움직일지 만화처럼 스토리보드를 그립니다. 사용자 시나리오도 똑같습니다. 프로그램이 실행되고 종료될 때까지 사용자의 경험을 순서대로 적어 내려가는 스토리보드입니다.",
        "concept": "사용자 시나리오(User Scenario)는 사용자가 목적을 달성하기 위해 시스템과 상호작용하는 과정을 시간 순서대로 서술한 이야기입니다. '프로그램 실행 -> 메뉴 확인 -> 1번 선택 -> 이름 입력 -> 저장 완료 메시지 확인' 식입니다. 성공 지표(Success Metrics)는 이 프로젝트가 완료되었을 때 '무엇을 달성하면 성공인가'를 측정 가능한 기준으로 적어둔 것입니다.",
        "how": "'만약 빵집 사장님이 단골 고객 연락처를 처음 저장한다면?'이라는 가정을 세우고, 화면에 뜰 텍스트와 사장님의 입력 과정을 대본 쓰듯 쭉 적어봅니다.",
        "checkpoint": "스토리가 있는 코드는 길을 잃지 않습니다. 시나리오는 개발의 훌륭한 길잡이입니다.",
        "script": "이제 PRD에 생명력을 불어넣을 차례입니다. 기능이 다 떨어져 있으면 어떻게 동작할지 감이 안 오죠. 그래서 우리는 '사용자 시나리오'를 씁니다. 영화 대본 쓰듯 상상해 보는 거예요. '자, 프로그램이 켜진다. 빵집 사장님 김씨가 화면을 본다. 화면에는 [1.고객등록 2.조회] 메뉴가 뜬다. 김씨가 1번을 누른다. 삐빅, 이름을 입력하라는 글씨가 뜬다...' 이렇게 써두면 AI도, 우리도 이 프로그램이 어떻게 굴러가야 할지 머릿속에 완벽한 그림이 그려집니다. 마지막으로, 방어막을 칩니다. '버그 없이 고객 5명의 정보가 저장되고 검색되면 이 프로젝트는 성공!'이라고 성공 지표를 박아두는 거죠. 목표가 뚜렷해졌습니다.",
        "lab": False,
        "conn_reason": "제품 관점의 UX 및 목표 설정 기법",
        "bridge": "PRD의 모든 부품이 모였습니다. 이제 조립할 시간입니다. 우리가 전에 만들었던 요구사항 초안을 완벽한 PRD로 업그레이드해 봅시다!",
    },
    {
        "id": "MS-PY101-038",
        "num": "038",
        "title": "고객 정보 관리 프로그램 PRD 완성하기",
        "time": 25,
        "chars": 4000,
        "prev": "037",
        "prev_type": "필수",
        "next": "039",
        "keywords": ["PRD 완성", "문서화 실습", "AI 협업"],
        "diff": "medium",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 요구사항 초안을 바탕으로 AI와 협업하여 완전한 구조(개요, 기능명세, 시나리오 등)를 갖춘 PRD를 완성할 수 있다.",
        "hook": "드디어 실전입니다. 우리가 배운 모든 것을 모아 '고객 정보 관리 프로그램'의 궁극의 마스터 문서, PRD를 완성해 봅시다.",
        "analogy_title": "AI 편집장과 함께 책 출판하기",
        "analogy": "여러분이 초고(요구사항)를 넘기면, AI라는 유능한 편집장이 양식에 맞춰 완벽한 책(PRD)으로 깔끔하게 제본해서 가져옵니다. 우리는 목차와 내용이 맞는지 최종 검수만 하면 됩니다.",
        "concept": "034 세션에서 뽑아둔 요구사항 초안을 바탕으로 프롬프트를 고도화하여 정식 PRD 문서를 생성합니다. 이때 FR-XXX 형태의 기능 명세, 구체적인 사용자 시나리오가 반드시 포함되도록 제약을 걸어주는 것이 실습의 핵심입니다.",
        "how": "",
        "checkpoint": "이 PRD 문서 하나가 앞으로 남은 파이썬 수업 전체를 이끌어갈 든든한 설계도가 됩니다.",
        "script": "자, Antigravity 옆에 브라우저 창을 띄워두세요. 우리는 지금부터 기획자 모드입니다. 아까 만든 요구사항 초안을 복사하세요. 그리고 AI에게 이렇게 명령합니다. '너는 이제부터 실리콘밸리의 수석 프로덕트 매니저야. 아래의 요구사항 초안을 바탕으로 정식 PRD 문서를 마크다운으로 작성해 줘. 단, 기능 요구사항은 반드시 FR-001 형식의 식별자를 표 형식으로 만들어 주고, 사용자가 처음 프로그램을 켜서 데이터를 저장하고 끄는 과정까지의 시나리오를 구체적인 대본처럼 추가해 줘.' 자, 엔터를 쳐볼까요? 화면에 쫙 출력되는 이 아름다운 문서가 바로 여러분이 설계한 첫 번째 소프트웨어의 PRD입니다.",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 AI를 활용하여 실무 수준의 PRD 문서를 생성하고 검토하는 능력을 기른다",
        "lab_steps": [
            {
                "step": 1,
                "time": "5분",
                "inst": "기존 요구사항 초안 준비 및 PRD 템플릿 요건 확인",
                "res": "초안 데이터 확보",
            },
            {
                "step": 2,
                "time": "10분",
                "inst": "FR 식별자, 시나리오, 성공 지표를 포함하라는 상세 프롬프트와 함께 AI에게 문서 생성 요청",
                "res": "구조화된 PRD 마크다운 문서 생성",
            },
            {
                "step": 3,
                "time": "10분",
                "inst": "생성된 문서 내용 검수: 빠진 기능이 없는지, 시나리오가 자연스러운지 확인하고 수정 요청",
                "res": "Day 4~5에서 사용할 마스터 PRD 완성",
            },
        ],
        "lab_trouble": "- 흔한 오류: 문서가 너무 길어져서 중간에 끊김 (해결법: '이어서 계속 작성해줘' 입력)",
        "conn_reason": "PRD 이론의 실전 문서화",
        "bridge": "수고하셨습니다! 요구사항부터 PRD까지 기획 파트를 훌륭히 마쳤습니다. 이제 이 문서로 진짜 코드를 뽑아낼 수 있을지, 오늘의 마지막 여정으로 가볼까요?",
    },
    # 2-5
    {
        "id": "MS-PY101-039",
        "num": "039",
        "title": "미니 스펙 프로젝트: 주제 선정 및 요구사항",
        "time": 25,
        "chars": 4000,
        "prev": "038",
        "prev_type": "필수",
        "next": "040",
        "keywords": ["자유 주제", "기획 실습", "아이디어 발상"],
        "diff": "medium",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 자신만의 자유 주제를 하나 선정하여 핵심 요구사항을 5W1H 기반으로 정의할 수 있다.",
        "hook": "지금까지는 제가 드린 주제(고객 관리)로 연습했습니다. 이제 여러분만의 오리지널 프로그램을 만들 시간입니다!",
        "analogy_title": "나만의 맞춤 양복 재단하기",
        "analogy": "지금까지는 기성복을 입어보며 핏을 맞추는 법을 배웠다면, 이제는 내가 입고 싶은 양복의 원단부터 치수까지 내 마음대로 정해서 세상에 하나뿐인 옷을 짓는 시간입니다.",
        "concept": "Day 2의 배움을 총망라하는 종합 실습의 첫 단계입니다. 할 일 목록(To-do), 단위 변환기, 단어장, 가위바위보 게임 등 간단한 콘솔 기반 프로그램 주제를 하나 선택하고, 누구를 위해 무엇을 해결할지 요구사항을 도출합니다.",
        "how": "너무 거창한 목표(예: 인스타그램 만들기)를 피하고, 100줄 이내의 파이썬 코드로 구현 가능한 텍스트 기반 주제를 고르도록 가이드합니다.",
        "checkpoint": "작고 귀여운 프로그램이라도 완벽한 기획을 거치면 훌륭한 포트폴리오가 됩니다.",
        "script": "자, 지금부터는 완벽한 자유시간입니다. 여러분이 평소에 아쉬웠던 점을 파이썬 프로그램으로 해결해 볼 거예요. 너무 거창할 필요 없습니다. 내가 영단어를 잘 까먹어서 '나만의 단어장 퀴즈 프로그램'을 만들겠다거나, 오늘 점심 메뉴를 골라주는 '랜덤 룰렛'도 좋습니다. 주제를 정하셨나요? 그럼 우리가 배웠던 5W1H를 꺼낼 차례입니다. 누가 쓸 건지, 어떤 기능 3가지가 꼭 들어가야 하는지 포스트잇에 꾹꾹 눌러 적어보세요. 이 짧은 메모가 여러분의 첫 오리지널 소프트웨어의 씨앗이 됩니다.",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 능동적으로 문제를 정의하고 프로그램의 기획 아이디어를 도출한다",
        "lab_steps": [
            {
                "step": 1,
                "time": "10분",
                "inst": "구현 가능한 콘솔 프로그램 주제 아이디어 브레인스토밍 및 1개 선정",
                "res": "개인별 프로젝트 주제 확정",
            },
            {
                "step": 2,
                "time": "15분",
                "inst": "선정된 주제에 대해 5W1H 및 핵심 기능 3가지 요구사항 메모 작성",
                "res": "초기 요구사항 정의 완료",
            },
        ],
        "lab_trouble": "- 흔한 오류: 시각적 그래픽(GUI)이나 서버가 필요한 과도한 주제 선정 (해결법: 콘솔 텍스트 입출력으로 범위를 좁히도록 강사가 1:1 유도)",
        "conn_reason": "종합 실습 1단계 - 기획",
        "bridge": "주제와 뼈대가 잡혔군요. 그럼 이 씨앗에 물을 주고 싹을 틔워볼까요? 방금 만든 메모를 PRD 문서로 변신시키러 갑시다.",
    },
    {
        "id": "MS-PY101-040",
        "num": "040",
        "title": "미니 스펙 프로젝트: PRD 작성 및 프롬프트 준비",
        "time": 25,
        "chars": 4000,
        "prev": "039",
        "prev_type": "필수",
        "next": "041",
        "keywords": ["PRD", "프롬프트 5대 항목", "준비 완료"],
        "diff": "medium",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 자신의 요구사항을 PRD로 변환하고, 이를 바탕으로 AI에게 코드를 요청할 1단계 프롬프트를 작성할 수 있다.",
        "hook": "씨앗을 심었으니 튼튼한 뿌리를 내리게 합시다. 문서를 만들고, AI에게 보낼 첫 번째 지시를 준비할 시간입니다.",
        "analogy_title": "건축 허가서와 착공 지시서",
        "analogy": "PRD를 완성하는 건 시청에서 '건축 허가'를 받는 과정입니다. 허가가 떨어졌으니, 이제 굴삭기 기사(AI)에게 '바닥부터 파주세요'라고 첫 번째 '착공 지시(프롬프트)'를 명확히 내려야 합니다.",
        "concept": "이전 세션의 아이디어를 AI를 활용해 PRD로 문서를 구체화합니다. 그리고 그 PRD를 기반으로, 방금 전 배운 '점진적 개선'과 '코드 프롬프트 5대 항목(기능/입력/출력/제약/예외)'을 적용하여 아주 기초적인 1단계 뼈대 코드를 요청하는 프롬프트를 메모장에 미리 작성해 둡니다.",
        "how": "AI 창에 입력하기 전에, 노트 패드나 텍스트 에디터에 내 프롬프트를 쭉 적어놓고 검토하는 습관을 들이게 합니다.",
        "checkpoint": "코딩을 시작하기 전의 완벽한 준비 상태. 화살을 쏘기 직전 최대한 시위를 당긴 상태입니다.",
        "script": "앞서 작성한 아이디어 메모를 AI에게 넘겨서 '내 아이디어를 PRD 형식으로 정리해줘'라고 명령하세요. AI가 멋진 기획서로 포장해 줄 겁니다. 자, PRD가 완성되었나요? 이제 코드를 짤 차례인데, 잠깐! 바로 엔터 치면 안 됩니다. '점진적 개선' 잊지 않으셨죠? 이 거대한 PRD를 한 번에 다 짜라고 하지 말고, 가장 핵심이 되는 첫 번째 기능만 떼어내세요. 그리고 '코드 프롬프트 5대 항목' 양식에 맞춰서 입력, 출력, 예외 처리를 명시한 1단계 프롬프트를 메모장에 정성스럽게 적어보세요. 이 첫 번째 지시가 프로젝트의 성패를 가릅니다.",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 기획 문서를 개발 지시용 프롬프트로 변환하는 연결 과정을 체득한다",
        "lab_steps": [
            {
                "step": 1,
                "time": "10분",
                "inst": "AI를 활용하여 내 주제에 맞는 PRD 마크다운 문서 최종 생성 및 저장",
                "res": "개인 PRD 파일(.md) 확보",
            },
            {
                "step": 2,
                "time": "15분",
                "inst": "PRD의 FR-001(핵심 기능)을 골라, 5대 항목이 포함된 1차 코드 생성 프롬프트 초안 작성",
                "res": "프롬프트 텍스트 준비 완료",
            },
        ],
        "lab_trouble": "- 흔한 오류: PRD 전체를 복붙해서 한 번에 완성 코드를 달라고 요청함 (해결법: 다시 중지시키고 1단계 뼈대만 요청하도록 분리 지시)",
        "conn_reason": "종합 실습 2단계 - 문서화 및 설계",
        "bridge": "시위는 당겨졌습니다! 041번 세션에서 마침내 화살을 날려 여러분의 아이디어가 실제 파이썬 코드로 살아 숨 쉬는 걸 확인해 봅시다.",
    },
    {
        "id": "MS-PY101-041",
        "num": "041",
        "title": "미니 스펙 프로젝트: 코드 생성 및 실행 검증",
        "time": 25,
        "chars": 4000,
        "prev": "040",
        "prev_type": "필수",
        "next": "042",
        "keywords": ["코드 생성", "실행", "POE 사이클", "점진적 개선"],
        "diff": "high",
        "type": "lab",
        "goal": "이 세션 종료 시 수강생은 자신이 작성한 프롬프트로 코드를 생성하고, 점진적으로 기능을 추가하여 최종 프로그램을 실행 및 검증할 수 있다.",
        "hook": "드디어 마법의 주문을 외울 시간입니다. 여러분의 상상이 파이썬 코드로 렌더링되는 순간을 즐기세요!",
        "analogy_title": "공장 라인 가동과 불량품 검수",
        "analogy": "설계도를 넣고 버튼을 누르면 부품(코드)이 쏟아져 나옵니다. 하지만 그대로 팔 순 없죠. 제대로 동작하는지 전원을 넣어보고(실행), 잘못된 부분이 있으면 설계도를 수정해 다시 찍어내야(점진적 개선) 합니다.",
        "concept": "준비한 프롬프트를 Antigravity 환경의 AI에게 입력하여 코드를 받아냅니다. 코드를 .py 파일로 저장하고 직접 실행합니다. 한 번에 성공하지 않더라도 당황하지 않고 에러 메시지를 다시 AI에게 던지며(트러블슈팅), 기능을 2~3단계에 걸쳐 추가하는 전체 SDD 개발 사이클을 완주합니다.",
        "how": "예측(이 코드 복사하면 이렇게 뜨겠지?) -> 검증(실행해보니 에러가 나네?) -> 설명(아, 이 조건이 빠졌구나. 수정하자)의 POE 방식을 적용합니다.",
        "checkpoint": "코드가 한 번에 돌아가지 않는 것은 정상입니다. 에러는 AI와 대화할 아주 좋은 주제거리일 뿐입니다.",
        "script": "준비된 1단계 프롬프트를 AI에게 던져보세요! 코드가 나왔나요? 눈으로만 보지 말고, Antigravity에 파일을 만들어 붙여넣기 한 뒤 과감하게 실행 버튼을 누르세요. 어라? 빨간 에러가 뜨신 분? 축하합니다. 여러분은 방금 진짜 개발자가 되셨습니다. 개발의 8할은 에러를 잡는 거예요. 당황하지 말고 그 에러 메시지를 그대로 긁어서 AI에게 다시 물어보세요. '이런 에러가 나는데 어떻게 고쳐야 해?' AI가 사과하면서 고쳐줄 겁니다. 첫 기능이 돌아가면 2단계 기능을 추가하고, 또 실행해 보세요. 기획서가 실제 소프트웨어로 변하는 이 짜릿한 과정을 끝까지 즐기시길 바랍니다.",
        "lab": True,
        "lab_target": "이 실습을 통해 수강생은 SDD 사이클(명세->프롬프트->코드생성->실행->개선)을 스스로 한 바퀴 완주하는 성취감을 얻는다",
        "lab_steps": [
            {
                "step": 1,
                "time": "10분",
                "inst": "준비한 프롬프트로 1단계 코드 생성, .py 저장 및 터미널 실행",
                "res": "기본 기능 동작 확인",
            },
            {
                "step": 2,
                "time": "10분",
                "inst": "기능 추가 또는 예외 처리를 위한 2차/3차 프롬프트 입력 (점진적 개선)",
                "res": "완성도 높은 프로그램 완성",
            },
            {
                "step": 3,
                "time": "5분",
                "inst": "최종 코드 실행 테스트 및 에러 트러블슈팅",
                "res": "프로젝트 완성 및 실행 성공",
            },
        ],
        "lab_trouble": "- 흔한 오류: 들여쓰기(Indentation) 복사 오류 (해결법: 파이썬의 들여쓰기 중요성 상기시키고 포맷팅 정리 안내)",
        "conn_reason": "종합 실습 3단계 - 구현 및 검증",
        "bridge": "와우, 여기저기서 프로그램이 돌아가는 소리가 들리네요! 이렇게 멋지게 만든 여러분의 자식 같은 프로그램, 혼자만 보기 아깝지 않나요? 발표 시간입니다.",
    },
    {
        "id": "MS-PY101-042",
        "num": "042",
        "title": "팀별 발표: '나는 이렇게 AI와 대화했다'",
        "time": 15,
        "chars": 2500,
        "prev": "041",
        "prev_type": "필수",
        "next": "043",
        "keywords": ["발표", "프롬프트 공유", "동료 학습"],
        "diff": "low",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 자신이 프로그램을 만드는 과정에서 AI와 어떻게 상호작용했는지 문제 해결 과정을 동료들에게 설명할 수 있다.",
        "hook": "코드 자랑 대회가 아닙니다. '삽질' 자랑 대회입니다. 우리는 남의 삽질에서 가장 많이 배웁니다.",
        "analogy_title": "탐험가의 항해 일지 공유",
        "analogy": "새로운 대륙을 발견하고 돌아온 탐험가들이 술집에 모여 '나는 폭풍우(에러)를 만났을 때 이렇게 빠져나왔어'라고 무용담을 나누는 시간입니다. 이 일지가 모이면 완벽한 항해 지도가 됩니다.",
        "concept": "단순히 결과물(프로그램) 시연을 넘어서, '어떤 프롬프트를 썼고', '어떤 에러를 만났으며', '어떻게 프롬프트를 수정해서 돌파했는지' 과정 중심의 공유를 진행합니다. 동료의 다양한 프롬프트 접근 방식을 보며 프롬프트 엔지니어링의 시야를 넓힙니다.",
        "how": "각 조별로 가장 흥미로운 에러나 삽질을 겪은 1명을 선정해 3분씩 발표하게 합니다.",
        "checkpoint": "코딩에는 하나의 정답이 없습니다. 천 명의 개발자가 있으면 천 개의 프롬프트와 천 개의 코드가 존재합니다.",
        "script": "모두 모니터에서 손을 떼고 앞을 봐주세요. 이제 각 팀의 대표들이 나와서 3분씩 발표를 할 겁니다. 주의할 점! '제 프로그램 멋지죠?' 하고 자랑하는 자리가 아닙니다. '제가 처음에 이렇게 프롬프트를 썼더니 AI가 엉뚱한 코드를 주더라고요. 그래서 제가 이렇게 조건을 콕 집어서 다시 줬더니 그제야 알아듣고 고쳐줬습니다.' 이 '밀당'의 과정을 이야기해 주세요. 에러를 만나고 그걸 극복한 무용담이 바로 진짜 실력입니다. 자, 첫 번째 발표자, 앞으로 모실까요?",
        "lab": False,
        "conn_reason": "경험 공유를 통한 메타 인지 향상",
        "bridge": "발표를 들어보니 정말 기상천외한 방법으로 AI를 부려먹고 계셨군요! 자, 오늘 하루도 엄청난 양을 배웠습니다. 마지막으로 Day 2를 깔끔하게 마무리해 볼까요?",
    },
    {
        "id": "MS-PY101-043",
        "num": "043",
        "title": "Day 2 핵심 요약 및 프롬프트 포트폴리오 정리",
        "time": 15,
        "chars": 2500,
        "prev": "042",
        "prev_type": "필수",
        "next": "",
        "keywords": ["요약", "프롬프트 노트", "Day 3 예고"],
        "diff": "low",
        "type": "narrative",
        "goal": "이 세션 종료 시 수강생은 Day 2의 핵심 내용(4요소, 5항목, SDD)을 요약하고, 자신이 작성한 성공적인 프롬프트를 자산화하여 저장할 수 있다.",
        "hook": "오늘 배운 지식이 휘발되기 전에 단단히 저장고에 묶어둘 시간입니다.",
        "analogy_title": "마법 주문서 갈무리하기",
        "analogy": "마법사가 하루 종일 실험실에서 완벽한 마법 주문을 찾아냈다면, 자기 전에 반드시 '마법 주문서(그리모어)'에 또박또박 적어둬야 내일 또 쓸 수 있습니다. 우리의 프롬프트도 똑같습니다.",
        "concept": "Day 2의 세 가지 큰 축인 '프롬프트 4요소', '코드 생성 5대 항목', '명세 주도 개발(SDD)'을 리마인드합니다. 그리고 오늘 실습하며 가장 결과가 좋았던 프롬프트 템플릿을 자신만의 '프롬프트 노트(마크다운 파일 등)'에 저장하여 자산화하는 습관을 들여줍니다.",
        "how": "Q&A를 통해 남은 궁금증을 해소하고, 내일 다룰 '파이썬 데이터 다루기'에 대한 기대감을 심어줍니다.",
        "checkpoint": "여러분은 이제 AI를 통제할 수 있는 설계자입니다. 내일부터는 AI와 함께 진짜 파이썬의 깊은 바다로 들어갑니다.",
        "script": "긴 하루였습니다. 오늘 우리는 엄청난 무기를 장착했어요. 단순한 질문을 완벽한 지시로 바꾸는 '프롬프트 4요소', 버그를 막아주는 '코드 생성 5대 항목', 그리고 코딩보다 중요한 '명세 주도 개발(SDD)와 PRD'까지. 여러분은 이미 평범한 코더를 넘어섰습니다. 자, 가기 전에 마지막 할 일이 있습니다. 오늘 여러분이 작성해서 대성공을 거뒀던 프롬프트 있죠? 그걸 복사해서 '나만의 프롬프트 노트.md' 파일에 저장하세요. 이게 여러분의 평생 자산이 됩니다. 내일은 본격적으로 파이썬이 데이터를 어떻게 주무르는지 문법의 세계로 들어갑니다. 오늘 배운 프롬프트 기술이 내일 엄청난 빛을 발할 겁니다. 모두 고생하셨습니다!",
        "lab": False,
        "conn_reason": "Day 2 총정리 및 지식 내재화",
        "bridge": "수고하셨습니다. 내일 만나요!",
    },
]

template = """# 마이크로 세션: {num}-{title}

## 📋 메타 정보
| 항목 | 값 |
|------|-----|
| **세션 ID** | {id} |
| **소요 시간** | {time}분 |
| **예상 교안 분량** | {chars}자 |
| **선행 세션** | 세션-{prev} ({prev_type}) |
| **후행 세션** | 세션-{next} |
| **핵심 키워드** | {keywords} |
| **난이도** | {diff} |
| **청크 타입** | {type} |

## 🎯 학습 목표
단 1개의 구체적인 학습 목표 (SMART 원칙 적용):
- {goal}

## 🗣️ 강사 대본 구성

### 예상 분량
- **최소**: 공백 포함 1,500자
- **최대**: 공백 포함 2,000자
- **화법**: 친근한 구어체 (~해요, ~입니다)

### 서술 흐름 (반드시 포함)
1. **도입 (Hook)**: {hook}
2. **비유 (Analogy)**: {analogy}
3. **개념 설명 (What)**: {concept}
4. **실제 활용 (How)**: {how}
5. **정리 (Checkpoint)**: {checkpoint}

### 예시 스크립트 (필수 - 작성자 참고용)
> "{script}"

"""

lab_template = """## 🎙️ 실습 가이드 (해당 시)

### 실습 목표
- {lab_target}

### 단계별 지시
| 단계 | 소요 시간 | 강사 지시사항 | 예상 결과 |
|------|----------|--------------|----------|
"""

for s in sessions:
    content = template.format(
        num=s["num"],
        title=s["title"],
        id=s["id"],
        time=s["time"],
        chars=s["chars"],
        prev=s["prev"],
        prev_type=s["prev_type"],
        next=s["next"],
        keywords=", ".join(s["keywords"]),
        diff=s["diff"],
        type=s["type"],
        goal=s["goal"],
        hook=s["hook"],
        analogy=s["analogy"],
        concept=s["concept"],
        how=s["how"],
        checkpoint=s["checkpoint"],
        script=s["script"],
    )

    if s["lab"]:
        content += lab_template.format(lab_target=s["lab_target"])
        for step in s["lab_steps"]:
            content += f'| {step["step"]} | {step["time"]} | "{step["inst"]}" | {step["res"]} |\n'
        content += f"\n### 주의사항 및 트러블슈팅\n{s['lab_trouble']}\n\n"

    content += f"""## 💡 비유 및 스토리텔링

### 핵심 비유
- **비유**: {s["analogy_title"]}
- **설명**: {s["analogy"]}
- **AI 시대의 서사 연결**: AI 시대에는 코드를 외우는 것보다 요구사항과 맥락을 AI에게 얼마나 정확히 전달하느냐가 핵심 경쟁력입니다. 이 비유는 바로 그 '정확한 소통'의 중요성을 체감하게 합니다.

### 스토리텔링 포인트
- 감정적 연결: 복잡한 코드 에러에 부딪혔을 때의 막막함을 공감하고, 프롬프트가 이 문제를 해결해 줄 수 있다는 안도감을 줍니다.
- 전환 멘트: 다음 세션으로 넘어가는 브릿지 역할을 합니다.

## 🔗 의존성 및 연결성

### 필수 선행 지식
- 세션-{s["prev"]}: {s.get("prev_title", "이전 세션")} ({s["conn_reason"]})

### 후속 연결
- 세션-{s["next"]}: {s.get("next_title", "다음 세션")} (이 세션과 자연스럽게 연결됨)

### 브릿지 노트 예시
> "{s["bridge"]}"

## 📝 Gemini 프롬프트 최적화 태그
```yaml
gemini_optimized:
  chunk_type: {s["type"]}
  complexity: {s["diff"]}
  estimated_chars: {s["chars"]}
  output_style: continuous_prose
  tone: friendly_spoken_korean
  include:
    - instructor_script: true
    - lab_guide: {"true" if s["lab"] else "false"}
    - analogy: detailed_situation
    - mermaid_diagram: {"true" if s["type"] == "diagram" else "false"}
  prerequisites:
    mandatory: [{s["prev"] if s["prev_type"] == "필수" else ""}]
    recommended: [{s["prev"] if s["prev_type"] == "권장" else ""}]
```

## ✅ 체크리스트 (작성자 자가 검증)

- [x] 단 1개의 핵심 학습 목표만 명시했는가?
- [x] 소요 시간이 15~25분 범위인가?
- [x] 강사 대본 예상 분량이 1,500~2,000자 범위인가?
- [x] chunk_type, complexity 태그를 부여했는가?
- [x] 선행/후행 세션을 명확히 연결했는가?
- [x] 비유가 'AI 시대의 서사' 톤과 일치하는가?
"""

    file_path = os.path.join(
        base_dir,
        f"세션-{s['num']}-{s['title'].replace(' ', '_').replace('/', '_').replace(':', '')}.md",
    )
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)

print("Files generated successfully.")
