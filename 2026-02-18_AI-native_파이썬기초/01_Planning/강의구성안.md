# AI-native 파이썬 기초 과정 — 커리큘럼 & 세션 상세표

> **버전**: v3.0 | **생성일**: 2026-02-18 | **최종 검증**: 2026-02-24 (run_20260224_204705)  
> **워크플로우**: 01_Lecture_Planning Pipeline (Planner Team)  
> **참고자료**: `참고자료/` 폴더 전수 분석 완료 (7개 파일)  
> **소스 기반 리서치**: NotebookLM 소스 3건 쿼리 결과 반영 (Trend_Report.md 참조)  
> **시간 기준**: 1일 8시간 = 09:00–18:00 (점심 1시간 제외, 오후 휴식 15분 포함)

---

## 0. 워크플로우 실행 결과 요약

### Step 0 — Scope Definition

| 항목 | 내용 |
|------|------|
| **강의 제목** | AI-native 파이썬 기초 과정 |
| **핵심 철학** | "코드를 타이핑하는 사람"이 아닌 "문제를 정의하고 AI와 협업하는 사람" 양성 |
| **대상** | "AI 시대의 서사 v3" 이수한 비전공 취업준비생 |
| **총 시간** | 40시간 (8h × 5일) |
| **실습 환경** | Windows 11, Google Antigravity IDE, Gemini 3 Pro |
| **산출물 범위** | 커리큘럼 + 세션 상세표 |
| **학습 방법론** | SDD(명세 주도 개발) 지향 — 프롬프트 작성 → 코드 생성 → 예측→검증→설명 사이클 (AI-first) |
| **실습 비율** | 60% 이상 |
| **톤** | 비유 중심 설명 ("AI 시대의 서사" 스타일 유지) |

**참고자료 충분성 판단**: *보충 완료*
- "AI 시대의 서사 v3" 문서가 핵심 철학·비유 체계·패러다임 여정을 풍부하게 제공 (커버율 ~70%)
- NotebookLM 소스 기반 리서치로 SDD 방법론, 코드 리뷰 5대 체크포인트, 테스트 시나리오 도출 방법 등 보강 완료
- Deep Research로 Antigravity IDE 상세 사용법, uv 최신 명령 체계, Gemini 3 Pro 코딩 활용법 보충 완료

---

### Step 1 — Trend Report (핵심 요약)

> 📋 **전체 리포트**: `01_Planning/Trend_Report.md` 참조

#### 1. AI-First 교육 패러다임 & SDD 방법론 (NotebookLM 소스 + Deep Research 기반)
- **SDD(Specification-Driven Development)**: "바이브 코딩"의 한계를 극복 — 인간은 명세서를 설계하고 AI는 이를 코드로 구현하는 역할 분리. "말이 되어야 프로그램이 된다" 원칙
- **거꾸로 학습 (Output-First)**: 문법 먼저가 아닌, 스펙(결과물)에서 출발하여 필요한 문법을 역으로 학습
- **예측→검증→설명 사이클**: AI 생성 코드의 결과를 먼저 예측 → 실행으로 검증 → 원리 설명하는 능동적 학습법
- **5 Whys 기법**: 에러 발생 시 "왜?"를 연속으로 던져 근본 원인 파악 훈련
- **SDD 학술적 검증 (2026년 신규)**: arxiv 논문 "Spec-Driven Development: From Code to Contract in the Age of AI Coding Assistants" (2026-01-30, arxiv:2602.00180v1) — SDD의 이론적 기반 확립
- **JetBrains 2026 예측**: VP Arun Gupta가 SDD를 2026년 주류 방법론으로 예측 (TFiR, 2026-02-12) — "코드보다 명세가 먼저" 패러다임이 업계 표준으로 자리잡는 중
- **Vibe Coding의 부상**: Google DeepMind가 Gemini 3 Pro를 "vibe coding과 agentic coding에 최적화된 모델"로 공식 명명
- **멀티모달 프로토타이핑**: Firebase Studio의 App Prototyping agent는 자연어·이미지·드로잉으로 코드 없이 풀스택 앱 생성 가능
- DeepLearning.AI의 "AI Python for Beginners" 등 AI 도구 통합 학습이 글로벌 표준으로 부상
- 메타인지(Metacognition) 기반 AI 보조 학습 — 학생이 AI에게 의존하지 않고 "왜 이 코드가 이렇게 동작하는지" 이해하도록 유도
- Citizen Developer 양성 수요 급증

#### 2. 프롬프트 & 코드 리뷰 방법론 (NotebookLM 소스 기반)
- **프롬프트 5대 필수 명시 항목** (코드 생성용): 기능, 입력, 출력, 제약 사항, 예외 처리
- **프롬프트 고급 기법**: 생각의 사슬(CoT), 퓨샷 러닝(Few-shot)
- **코드 리뷰 5대 체크포인트**: 요구사항 충족, 입력 검증, 경계값 처리, 자료구조 적절성, 가독성/구조
- **테스트 시나리오 3분류**: 정상 케이스, 경계값 케이스, 예외 케이스
- **리뷰 코멘트 3요소**: ① 문제 위치 ② 문제점 내용 ③ 재현 입력값/상황

#### 3. Antigravity IDE (2026년 2월 최신 업데이트)
- Google이 **2025.11.18** 출시한 **Agent-first IDE** (VS Code 포크) — 공식 사이트: antigravity.google
- **Firebase Studio 통합**: 구 Project IDX → Firebase Studio → Antigravity로 진화. 브라우저 기반 클라우드 환경과 데스크톱 IDE 동시 지원
- **3-Surface 아키텍처**: Editor(동기적 코딩) + Manager(자율 에이전트 오케스트레이션) + Browser(자동 테스트)
- **멀티에이전트 워크플로우**: 동시에 여러 에이전트 스레드 실행 가능
- **Gemini 3.1 Pro 기본 내장**: 별도 API 키 설정 없이 즉시 AI 기능 사용 가능
- **2026년 신규 기능**: Skills 지원 (2026-01), MCP Servers 연동 (2025-12), Workflows/Rules (2025-11)
- **App Prototyping Agent**: 코드 없이 자연어·이미지·드로잉으로 Next.js 풀스택 앱 생성 (Firebase Studio)
- VS Code에서 **30초 마이그레이션**

#### 4. uv 패키지 매니저 (2026년 2월 최신)
- **Astral사**(Ruff 개발사)의 **Rust 기반** 초고속 Python 패키지/프로젝트 관리 도구
- **최신 버전**: v0.10.5 (2026-02-23 릴리스) | **GitHub Stars**: 79,700+
- **GitHub Octoverse 2025**: 컨트리뷰터 수 기준 최고 성장 프로젝트 선정
- pip 대비 **10-100배 빠른** 의존성 해결 및 설치
- **단일 도구로 대체**: pip, pip-tools, pipx, pyenv, poetry, virtualenv → uv 하나로 통합
- 핵심 명령어: `uv init`, `uv add`, `uv run`, `uv venv`, `uv pip install`, `uv lock`, `uv sync`, `uv python install`
- **v0.10.x 신규**: CPython 3.15 지원, `uv format` 프리뷰, `pylock.toml` 표준 지원 (PEP 751)

#### 5. Gemini 3 시리즈 (2026년 2월 최신)
- **Gemini 3.1 Pro**: 복잡한 작업, 창의적 개념 구현, 고급 agentic 코딩 | SWE-Bench Verified **80.6%**, LiveCodeBench Pro **2887 Elo**
- **Gemini 3 Pro**: vibe coding 최적화, 인터랙티브 시각화, 3D 코딩 | Antigravity IDE에 기본 탑재
- **Gemini 3 Flash**: 속도 최적화, 실시간 UI 생성
- **Gemini 3 Deep Think**: ARC-AGI-2 **84.6%**, Codeforces Elo **3455** — 복잡한 문제에 대한 깊은 추론 지원
- **1M 토큰 컨텍스트 윈도우** — 대규모 코드베이스 이해 가능

#### 6. 2026 채용 트렌드 & AI 리터러시
- AI 리터러시 + 문제 정의력이 핵심 역량
- "코드를 쓰는 개발자"에서 "AI를 지휘하는 개발자"로 역할 전환
- **AI 리터러시 4단계 모델**: 사용자(User) → 협업자(Collaborator) → 감독자(Supervisor) → 설계자(Architect)
- **신규 요구 역량**: 프롬프트 엔지니어링, AI 출력 검증, 에이전트 오케스트레이션, 시스템 설계
- PBL(문제해결 중심) 실습 교육 전환 가속
#### 7. 프롬프트 엔지니어링 최신 기법 (2026년 신규)
- **Firebase Studio 공식 가이드 기반 5원칙**: 구체성(Specificity), 컨텍스트(Context), 예시(Examples), 반복적 접근(Iterative), 추론 요청(Reasoning)
- **멀티모달 프롬프팅**: 텍스트 + 이미지 + 드로잉 동시 입력이 2026년 표준으로 자리잡음
- **SDD 명세 작성 5단계 프레임워크**: 목적(Purpose) → 사용자(User) → 데이터(Data) → UI/UX → 제약(Constraints)

---

### Step 2 — Learner Persona & Pain Points

**페르소나**: 김하늘 (26세, 경영학 전공, 취업준비생)

| 특성 | 설명 |
|------|------|
| **선행 학습** | "AI 시대의 서사 v3" 이수 → 개발 패러다임 여정·AI 역할 이해 완료. 비유(네비게이션, 통역사, 붕어빵 틀 등)에 친숙 |
| **IT 리터러시** | 웹 브라우징, 파일 관리, 기본 문서 작성 가능. 터미널 경험은 없음 |
| **프로그래밍 경험** | 없음 |
| **동기** | AI 시대 취업 경쟁력 확보, "내가 직접 만들 수 있다"는 자신감 |
| **불안 요소** | "코딩은 어려울 것 같다", "수학 못해도 되나?", "용어가 너무 낯설다" |

**핵심 Pain Points & 대응 전략**:

| # | Pain Point | 대응 전략 |
|---|-----------|----------|
| 1 | **용어 장벽** — 변수, 함수, 클래스 등 프로그래밍 용어에 대한 두려움 | "AI 시대의 서사"에서 배운 비유 체계를 일관되게 연결 (변수="이름표 상자", 함수="레시피 카드" 등) |
| 2 | **환경 설정 좌절** — 설치·환경 구축 단계에서 포기하기 쉬움 | Day 1 전체를 환경 구축에 할당. AI에게 물어보며 진행하는 방식으로 좌절 최소화 |
| 3 | **추상 개념 이해 어려움** — 제어문, OOP 등 추상적 개념의 체감 난이도 | 비유 → 프롬프트로 코드 생성 → 예측→검증→설명 3단계 루프로 점진적 이해 |
| 4 | **실무 연결 부재** — "이걸 배워서 뭐에 쓰지?" | "고객 정보 관리 프로그램"이라는 실무형 관통 프로젝트로 Day 2~5 연결 |
| 5 | **타이핑 코딩 공포** — 빈 화면에 코드를 치라는 압박감 | 100% AI-first: 모든 코드를 프롬프트로 생성. 빈 에디터 공포 제거 |
| 6 | **AI 의존 우려** — AI가 해주면 내가 뭘 배우는 건지 | 예측→검증→설명 사이클 + 5 Whys 기법으로 능동적 이해 보장 (NotebookLM 소스 기반) |

---

### Step 5 — Differentiation Strategy (USP)

| # | 차별화 포인트 | 설명 |
|---|------------|------|
| 1 | **100% AI-first + SDD 학습** | 모든 코드를 프롬프트로 생성·리뷰하며 배움. SDD(명세 주도 개발) 기반으로 "말이 되어야 프로그램이 된다" |
| 2 | **"AI 시대의 서사" 연계** | 선행 교육의 비유 체계(네비게이션, 통역사, 붕어빵 틀, 레시피 카드 등)를 이어받아 일관된 학습 경험 |
| 3 | **Antigravity + Gemini 3 Pro 실전 환경** | 2025년 출시된 최신 Agent-first IDE에서 실습. 멀티에이전트 워크플로우 체험 |
| 4 | **일관된 관통 프로젝트** | "고객 정보 관리 프로그램"을 Day 2(PRD) → Day 4(절차적→구조적) → Day 5(OOP→DI) 점진적 리팩토링 |
| 5 | **예측→검증→설명 3단계 루프** | 비유로 개념 이해 → 프롬프트로 코드 생성 → 결과 예측 → 실행 검증 → 원리 설명. 매 세션 반복 |
| 6 | **체계적 코드 리뷰 & 테스트** | 코드 리뷰 5대 체크포인트 + 정상/경계값/예외 3분류 테스트 시나리오 도출 (NotebookLM 소스 기반) |

---

## 1. 커리큘럼 전체 구조

```
Day 1 ▸ 파트1-A  환경 구축 & AI 도구 이해
Day 2 ▸ 파트1-B  프롬프트 작성법 & 요구사항/PRD/SDD
Day 3 ▸ 파트2    파이썬 기초문법 (변수·자료구조·제어문·함수)
Day 4 ▸ 파트3    절차적·구조적 프로그래밍 & 코드 리뷰·테스트
Day 5 ▸ 파트4    객체지향 프로그래밍 & DI 패턴
```

| 일차 | 파트 | 핵심 키워드 | 이론:실습 |
|------|------|-----------|----------|
| Day 1 | 파트1-A | Antigravity, Python, uv, 가상환경, 첫 프로그램 | 30:70 |
| Day 2 | 파트1-B | 프롬프트 5대 항목, 점진적 개선, 요구사항, PRD, SDD 개념 | 35:65 |
| Day 3 | 파트2 | 변수, 자료구조, 제어문, 예외처리, 함수, 리스트 컴프리헨션 읽기 | 40:60 |
| Day 4 | 파트3 | 절차적, 구조적, 함수 분리, 모듈화, 코드 리뷰 5대 체크포인트, 테스트 시나리오 | 30:70 |
| Day 5 | 파트4 | 클래스, OOP, 상속, 캡슐화, DI, @dataclass 소개, 고객관리 v3→v4 | 30:70 |

### 학습 방법론 — 예측→검증→설명 사이클 (NotebookLM 소스 기반)

모든 세션에서 아래 사이클을 반복 적용:

```
① 비유 이해 → ② 프롬프트 작성 (5대 필수 항목) → ③ 코드 생성
    → ④ 결과 예측 ("이 코드를 실행하면 어떤 결과가 나올까?")
    → ⑤ 실행 검증 ("예측과 맞나?")
    → ⑥ 원리 설명 ("왜 이렇게 동작하는가?")
    → (에러 시) 5 Whys 기법 적용
```

---

## 2. 세션 상세표

---

### DAY 1 — 환경 구축과 AI 도구 이해 (8시간)

#### 세션 1-1: 오리엔테이션 & AI 시대의 서사 복습 (09:00–10:00, 60분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 과정 전체 흐름을 이해하고, "AI 시대의 서사"에서 배운 핵심 개념을 환기한다 |
| **핵심 개념** | 문제 정의 vs 문제 해결, 네비게이션 비유, "말이 되어야 프로그램이 된다", SDD 지향 소개 |
| **비유** | 이 과정은 **"네비게이션을 직접 써보는 운전 실습"**이다 — 목적지(요구사항)를 정하고, 네비게이션(AI)에게 경로(코드)를 물어보고, 그 경로가 맞는지 지도(문법)를 읽는 법을 배운다 |
| **활동** | ① 아이스브레이킹: "AI에게 시켜본 가장 재미있는 일" 공유 ② 과정 로드맵 소개 (Day 1~5 전체 흐름) ③ "AI 시대의 서사" 핵심 3가지 복습 퀴즈: 문제 정의, 패러다임 여정, AI의 역할 ④ 학습 방법론 소개: 예측→검증→설명 사이클, SDD 개념 미리보기 ⑤ "요리사 vs 메뉴 기획자" 비유 복습 — 우리는 메뉴 기획자가 되는 과정을 시작한다 |
| **산출물** | 과정 로드맵 핸드아웃 이해 |

#### 세션 1-2: Antigravity 설치 & 기본 사용법 (10:00–11:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Windows 11에서 Antigravity를 설치하고, Editor 뷰와 Agent Manager의 기본 사용법을 익힌다 |
| **핵심 개념** | Antigravity IDE, Agent-first 패러다임, Editor 뷰, Agent Manager, 멀티에이전트 오케스트레이션 |
| **비유** | Antigravity는 **"AI 비서가 상주하는 사무실"**이다 — 왼쪽은 당신의 책상(Editor 뷰), 오른쪽은 AI 비서들의 자리(Agent Manager). 비서에게 "이 보고서 좀 작성해줘"라고 말하면, 비서가 알아서 초안을 만들어주고, 당신은 검토만 하면 된다. 심지어 비서 여러 명에게 동시에 다른 일을 시킬 수도 있다(멀티에이전트) |
| **실습** | ① antigravity.google에서 Antigravity 다운로드 및 설치 (강사 시연 → 수강생 따라하기) ② VS Code 사용 경험이 있다면 30초 마이그레이션 확인 ③ Editor 뷰 기본 조작: 파일 생성, 저장, 폴더 열기 ④ Agent Manager에서 Gemini 3 Pro와 첫 대화 — "안녕! 너는 누구야? 무엇을 할 수 있어?" ⑤ 멀티에이전트 체험: 에이전트 탭 2개를 동시에 열어 각각 다른 질문하기 |
| **산출물** | Antigravity 설치 완료, 에이전트와 첫 대화 성공 |

#### 세션 1-3: 시스템 환경 확인 & Python 설치 (11:30–12:30, 60분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Antigravity의 AI를 이용해 시스템 환경을 확인하고, Python이 설치되어 있지 않은 경우 프롬프트로 설치 방법을 알아내어 실행한다 |
| **핵심 개념** | 시스템 환경 확인, Python 설치, 터미널 기본 사용 |
| **비유** | 요리를 시작하기 전에 **"냉장고에 뭐가 있는지"**(시스템 환경) 확인하고, 재료가 없으면 **"장보기 목록"**(설치 명령)을 AI에게 물어보는 것 |
| **실습** | ① 프롬프트: "내 컴퓨터의 운영체제와 Python 설치 여부를 확인해줘" → 결과 리뷰 ② 프롬프트: "Windows 11에 Python 3.12를 설치하는 방법을 알려줘" → 설치 실행 ③ 터미널에서 `python --version` 확인 ④ 트러블슈팅 실습: "python 명령이 안 돼요" → AI에게 물어보기 + 5 Whys 기법 적용 ("왜 안 되지?" → "PATH가 뭐지?" → ...) |
| **산출물** | Python 3.12+ 설치 완료, 버전 확인 성공 |

> 🍽️ **점심시간 (12:30–13:30)**

#### 세션 1-4: uv 설치 & 가상환경 이해 (13:30–15:00, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | uv를 설치하고, 가상환경의 개념을 이해하며, uv로 가상환경을 생성·활성화한다 |
| **핵심 개념** | 패키지 매니저, 가상환경(Virtual Environment), 의존성 격리, uv 핵심 명령어 |
| **비유** | 가상환경은 **"프로젝트별 전용 도구함"**이다 — 요리사가 이탈리안 요리용 도구함과 한식 요리용 도구함을 따로 쓰는 것처럼, 각 프로젝트마다 필요한 라이브러리를 분리해서 관리한다. uv는 **"초고속 도구함 관리자"** — 기존 도구함 관리자(pip)보다 10~100배 빠르게 도구를 정리해준다 |
| **실습** | ① 프롬프트: "uv가 뭔지, 그리고 Windows에서 설치하는 방법을 알려줘" → PowerShell 명령으로 설치 ② `uv --version`으로 설치 확인 ③ 프롬프트: "uv를 이용해서 Python 3.12 가상환경을 만드는 방법을 알려줘" ④ `uv venv --python 3.12` 실행 → 가상환경 생성 ⑤ 가상환경 활성화(`.venv\Scripts\activate`) / 비활성화(`deactivate`) 실습 ⑥ `uv pip install requests` → 패키지 설치 체험 → pip와 속도 차이 체감 |
| **산출물** | uv 설치 완료, 가상환경 생성·활성화 성공, 패키지 1개 설치 |

#### 세션 1-5: 첫 Python 프로그램 실행 (15:00–16:00, 60분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Antigravity에서 프롬프트를 이용해 첫 Python 프로그램을 생성하고 실행한다 |
| **핵심 개념** | .py 파일, 스크립트 실행, print() 함수, input() 함수, 프로그램 실행 흐름 |
| **비유** | 첫 프로그램은 **"AI에게 부탁한 첫 번째 편지"**이다 — AI가 써준 편지(코드)를 읽어보고, 봉투에 넣어 보내는(실행) 과정. "통역사"에게 한국어로 말했더니 파이썬어로 번역해준 것 |
| **실습** | ① 프롬프트: "이름을 입력받아서 환영 인사를 출력하는 파이썬 프로그램을 만들어줘" ② 예측→검증→설명: 실행 전 "어떤 결과가 나올까?" 예측 → 실행 → 왜 이렇게 동작하는지 설명 ③ 생성된 코드를 한 줄씩 리뷰 — input(), print(), 변수 할당 맛보기 ④ 변형 프롬프트: "생년월일도 입력받아서 나이를 계산해줘" → 코드 변화 관찰 |
| **산출물** | hello.py 파일 실행 성공 |

> ☕ **휴식 (16:00–16:15)**

#### 세션 1-6: Day 1 종합 실습 & 정리 (16:15–18:00, 105분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Day 1에서 배운 환경 구축 과정을 처음부터 되짚으며 내재화한다 |
| **활동** | ① 종합 실습: "새 프로젝트 폴더 생성 → uv 가상환경 생성 → 프롬프트로 간단한 계산기 프로그램 생성 → 실행" 전 과정 독립 수행 ② 미니 스펙: 고객 1명의 이름·전화번호를 입력받아 출력하는 프로그램 (관통 프로젝트 Day 1 버전) ③ 트러블슈팅 실습: 자주 발생하는 오류 3가지(PATH 문제, 가상환경 미활성화, 인코딩 오류)를 AI에게 물어보며 5 Whys 적용 ④ 동료 학습: 옆 사람과 서로의 환경 구축 과정을 비교하고 다른 점 공유 (15분) ⑤ Day 1 핵심 정리 퀴즈 (5문항) ⑥ 개인별 Q&A — 환경 구축 중 해결하지 못한 문제 해결 (15분) ⑦ Day 2 예고: "내일은 AI에게 일 시키는 기술을 배웁니다!" |
| **평가** | 체크리스트: Antigravity 설치 ✓ Python 설치 ✓ uv 가상환경 생성 ✓ 프로그램 실행 ✓ |

---

### DAY 2 — 프롬프트 작성법 & 요구사항/PRD/SDD (8시간)

#### 세션 2-1: 프롬프트 기본 이해 (09:00–10:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 프롬프트의 구성 요소를 이해하고, 좋은 프롬프트와 나쁜 프롬프트의 차이를 체험한다 |
| **핵심 개념** | 프롬프트 구성 4요소 (Persona, Task, Context, Format), 명확성, 구체성 |
| **비유** | 프롬프트는 **"AI에게 보내는 업무 지시서"**이다 — "밥 해줘"라고 하면 뭘 만들지 모르지만, "2인분 김치찌개를 돼지고기 200g으로 30분 안에 만들어줘"라고 하면 원하는 결과가 나온다. Google Gemini Prompting Guide의 4요소를 기억하라: **누가**(Persona) **무엇을**(Task) **어떤 상황에서**(Context) **어떤 형태로**(Format) |
| **실습** | ① 나쁜 프롬프트 vs 좋은 프롬프트 비교 실험 (3쌍): "계산기 만들어" vs "사칙연산(+,-,×,÷)을 지원하고, 0으로 나누면 에러 메시지를 보여주는 콘솔 계산기를 파이썬으로 만들어줘" ② 각각 Antigravity에서 실행하고 결과 비교 ③ 4요소(Persona, Task, Context, Format) 분해 연습 ④ 나만의 프롬프트 개선: 짝과 교환하여 피드백 |
| **산출물** | 프롬프트 비교 실험 결과 기록, 4요소 체크시트 |

#### 세션 2-2: 코드 생성을 위한 프롬프트 작성 (10:30–12:00, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 코드 생성에 특화된 프롬프트 5대 필수 명시 항목을 익히고, 점진적 개선(Iterative Refinement) 방법을 실습한다 |
| **핵심 개념** | 프롬프트 5대 필수 항목 (기능·입력·출력·제약·예외), 단계적 요청, 반복 개선, CoT(생각의 사슬), Few-shot |
| **비유** | 코드 생성 프롬프트는 **"건축 의뢰서"**이다 — 한 번에 "집 지어줘"가 아니라, 먼저 설계도(기본 구조) → 골조(핵심 로직) → 인테리어(세부 기능) 순서로 요청한다 |
| **실습** | ① 프롬프트 5대 필수 항목 학습: 기능, 입력, 출력, 제약 사항, 예외 처리 (NotebookLM 소스 기반) ② 1단계 프롬프트: "비밀번호 강도 확인 프로그램의 기본 구조를 만들어줘" (기능·입력·출력 명시) ③ 2단계: "8자 이상, 대소문자 포함, 숫자 포함 조건을 추가해줘" (제약 사항 추가) ④ 3단계: "특수문자 포함 여부도 검사하고, 각 조건별로 ✓/✗ 표시해줘" (출력 형식 + 예외 처리) ⑤ 각 단계별 예측→검증→설명 수행 ⑥ 고급 기법 소개: CoT("단계별로 생각해서..."), Few-shot(입출력 예시 제공) |
| **산출물** | 3단계 점진적 개선 프롬프트 & 코드 결과물, 5대 항목 체크시트 |

> 🍽️ **점심시간 (12:00–13:00)**

#### 세션 2-3: 요구사항 이해 & AI를 이용한 요구사항·SDD 작성 (13:00–14:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 소프트웨어 요구사항이 무엇인지 이해하고, AI를 활용해 요구사항을 체계적으로 작성한다. SDD(명세 주도 개발)의 개념을 이해한다 |
| **핵심 개념** | 요구사항(Requirements), 기능/비기능 요구사항, 사용자 스토리, 5W1H, SDD(Specification-Driven Development) |
| **비유** | 요구사항은 **"여행 계획서"**이다 — "여행 가자!"만으로는 준비할 수 없다. 어디로?(목적지) 언제?(일정) 누구와?(인원) 예산은?(제약) 뭐할 건데?(활동) 이 모든 것을 정리한 것이 요구사항이다. SDD는 **"건축 허가서 받고 짓기"** — "느낌대로 짓기"(바이브 코딩)가 아니라 설계도를 먼저 완성한 뒤 AI에게 시공을 맡기는 것 |
| **실습** | ① "고객 정보 관리 프로그램"에 대한 요구사항을 자유롭게 적어보기 (포스트잇) ② 프롬프트: "고객 정보를 등록·조회·수정·삭제할 수 있는 콘솔 프로그램의 요구사항을 체계적으로 정리해줘" ③ AI가 정리한 요구사항과 본인 것 비교 ④ 5W1H 체크리스트 학습 및 적용 ⑤ SDD 개념 소개: "바이브 코딩의 한계" vs "명세 주도 개발" — 기능·데이터·제약 조건을 명세서로 설계하면 AI가 더 정확한 코드 생성 |
| **산출물** | "고객 정보 관리 프로그램" 요구사항 문서 (초안), SDD 개념 이해 |

#### 세션 2-4: AI를 이용한 PRD 문서 작성 (14:30–16:00, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | PRD(Product Requirements Document)의 구조를 이해하고, AI를 활용해 PRD를 작성한다 |
| **핵심 개념** | PRD 문서, 문제 정의, 사용자 시나리오, 기능 명세(FR-001~FR-004), 성공 지표 |
| **비유** | PRD는 **"요리 레시피의 완전판"**이다 — 재료(기능), 조리 순서(사용자 흐름), 완성 사진(목표), 주의사항(제약)을 모두 담은 마스터 레시피. "AI 시대의 서사"에서 배운 **"메뉴 기획자"**가 작성하는 문서가 바로 PRD |
| **실습** | ① PRD 템플릿 소개: 목적, 배경, 사용자, 기능 목록(FR-001~FR-004), 비기능 요구사항, 성공 지표 ② 프롬프트: "다음 요구사항을 바탕으로 고객 정보 관리 프로그램의 PRD 문서를 작성해줘 [세션 2-3 요구사항]" ③ 생성된 PRD 리뷰 및 수정 요청: "사용자 시나리오를 좀 더 구체적으로 작성해줘" ④ 기능 명세 코드화: FR-001(등록), FR-002(조회/검색), FR-003(수정), FR-004(삭제) 식별 ⑤ 최종 PRD 완성 — 이 문서가 Day 4~5의 개발 기반이 된다 |
| **산출물** | "고객 정보 관리 프로그램" PRD 문서 (완성, FR 코드 포함) |

> ☕ **휴식 (16:00–16:15)**

#### 세션 2-5: Day 2 종합 실습 & 정리 (16:15–18:00, 105분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 프롬프트 작성→요구사항→PRD 전체 파이프라인을 독립적으로 수행한다 |
| **활동** | ① 미니 프로젝트(미니 스펙): 자유 주제(예: 할 일 목록, 단위 변환기, 가위바위보 등) 선택 → 요구사항 작성(5대 항목 적용) → PRD 작성 → 프롬프트로 코드 생성 → 예측→검증→설명 ② 팀별 발표 (3분×4팀) — "나는 이렇게 AI와 대화했다" (20분) ③ 프롬프트 포트폴리오 정리: 오늘 작성한 프롬프트를 "나만의 프롬프트 노트"에 정리 (15분) ④ Day 2 핵심 정리 퀴즈 (5문항) ⑤ 개인별 Q&A — 프롬프트 작성 중 어려웠던 부분 해결 (15분) ⑥ Day 3 예고: "내일은 파이썬이 데이터를 어떻게 다루는지 배웁니다!" |
| **평가** | 체크리스트: 프롬프트 5대 항목 활용 ✓ 요구사항 작성 ✓ PRD 작성 ✓ 코드 생성·실행 ✓ |

---

### DAY 3 — 파이썬 기초문법 (8시간)

#### 세션 3-1: 데이터의 이해 — 변수와 타입 (09:00–10:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | "데이터에 이름을 붙인다"는 개념으로 변수를 이해하고, 데이터 타입의 종류와 특징을 안다 |
| **핵심 개념** | 변수(Variable), 데이터 타입(int, float, str, bool), 타입 변환, 할당 연산자, f-string |
| **비유** | 변수는 **"이름표가 붙은 상자"**이다 — `name = "철수"`는 "name"이라는 이름표가 붙은 상자에 "철수"를 넣는 것. 상자의 종류(타입)에 따라 넣을 수 있는 물건이 다르다: 숫자 상자(int), 소수 상자(float), 글자 상자(str), 참/거짓 상자(bool) |
| **실습** | ① 프롬프트: "파이썬의 기본 데이터 타입 4가지를 각각 변수에 저장하고 type() 함수로 확인하는 예제를 만들어줘" → 예측→검증→설명 ② 프롬프트: "문자열 '123'을 숫자로, 숫자 456을 문자열로 변환하는 예제" → 타입 변환 리뷰 ③ f-string 실습: 변수를 섞어 문장 출력하기 ④ 연산자 실습: 프롬프트로 사칙연산, 문자열 결합, 비교 연산 예제 생성 ⑤ 직접 변수 이름과 값 바꿔보며 실행 — "값을 바꾸면 어떤 결과가?" 예측 후 검증 |
| **산출물** | 변수와 타입 실습 코드 실행 완료 |

#### 세션 3-2: 데이터에서 정보로 — 자료구조 (10:30–12:00, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 여러 데이터를 묶어 하나의 정보 단위로 다루는 자료구조(리스트, 딕셔너리)를 이해한다 |
| **핵심 개념** | 리스트(List), 딕셔너리(Dictionary), 인덱싱, 슬라이싱, 키-값 쌍, CRUD 연산 |
| **비유** | 리스트는 **"번호표가 붙은 사물함"** — 0번 칸, 1번 칸, 2번 칸... 순서대로 물건을 넣고 번호로 찾는다. 딕셔너리는 **"이름표가 붙은 서랍장"** — "이름" 서랍, "나이" 서랍, "전화번호" 서랍... 이름으로 찾는다. **한 명의 고객 정보 = 딕셔너리, 여러 고객 = 리스트 안에 딕셔너리들** |
| **실습** | ① 프롬프트: "과일 5개를 리스트에 저장하고, 추가·삭제·검색하는 예제를 만들어줘" → 리스트 CRUD + 인덱싱·슬라이싱 리뷰 ② 프롬프트: "한 명의 고객 정보(이름, 나이, 전화번호, 이메일)를 딕셔너리로 만들고 접근하는 예제" → 딕셔너리 리뷰 ③ 프롬프트: "고객 3명의 정보를 리스트 안의 딕셔너리로 저장하고 전체 출력하는 예제" → 복합 구조 리뷰 (Day 4 고객관리의 데이터 구조 선행 학습, NotebookLM 소스의 `[{}, {}, {}]` 패턴) |
| **산출물** | 리스트/딕셔너리 실습 코드 |

> 🍽️ **점심시간 (12:00–13:00)**

#### 세션 3-3: 제어문 & 문자열·예외 처리 (13:00–14:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 조건문(if)과 반복문(for, while)으로 프로그램 흐름을 제어하고, 문자열 처리와 예외 처리를 이해한다 |
| **핵심 개념** | if/elif/else, for, while, break/continue, range(), 비교·논리 연산자, 문자열 메서드, try/except |
| **비유** | 제어문은 **"교통 신호등"** — if문은 "빨간불이면 멈추고, 초록불이면 가라"(조건 분기), for문은 "이 줄의 모든 사람에게 번호표를 나눠주라"(반복), while문은 "사람이 남아있는 동안 계속 서비스하라"(조건 반복). 예외 처리(try/except)는 **"비상 대피 계획"** — 화재(에러)가 나면 비상구(except)로 대피한다 |
| **실습** | ① 프롬프트: "점수를 입력받아 A/B/C/D/F 학점을 출력하는 프로그램" → 미니 스펙: 경계값(0, 100) + 예외값(-1, 101) 처리 포함 ② 프롬프트: "1부터 100까지 숫자 중 3의 배수만 출력하는 프로그램" → for + range 리뷰 ③ 프롬프트: "사용자가 'quit'을 입력할 때까지 계속 메시지를 입력받는 프로그램" → while + break 리뷰 ④ 프롬프트: "숫자 나누기를 하되, 0으로 나누면 에러 메시지를 보여주는 프로그램" → try/except 리뷰 |
| **산출물** | 제어문·예외처리 실습 코드 |

#### 세션 3-4: 로직에 이름 붙이기 — 함수 & 리스트 컴프리헨션 읽기 (14:30–16:00, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | "로직에 이름을 붙인다"는 개념으로 함수의 재사용성을 이해하고, 함수 문법을 익힌다. AI가 자주 생성하는 리스트 컴프리헨션을 읽는 법을 배운다 |
| **핵심 개념** | 함수 정의(def), 매개변수(Parameter), 기본값, 반환값(return), 지역 변수, 내장 함수, 리스트 컴프리헨션 읽기 |
| **비유** | 함수는 "AI 시대의 서사"에서 배운 **"레시피 카드"**이다 — 김치찌개 만드는 방법을 `김치찌개_만들기(재료)` 카드에 적어두면, 재료만 바꿔서 호출할 수 있다. `def 김치찌개_만들기(재료):` → `김치찌개_만들기("돼지고기")` |
| **실습** | ① 프롬프트: "두 숫자를 받아서 사칙연산 결과를 반환하는 함수 4개를 만들어줘" → 기본 함수 리뷰 ② 프롬프트: "고객 이름을 받아서 환영 메시지를 출력하는 함수와, 고객 목록을 받아서 전체를 출력하는 함수" → 매개변수/반환값 리뷰 ③ 프롬프트: "BMI를 계산하는 함수를 만들어줘. 키(cm)와 몸무게(kg)를 입력받아 BMI 값과 비만 여부를 반환" → 복합 함수 리뷰 ④ 리스트 컴프리헨션 읽기 (NotebookLM 소스 기반): `[x for x in nums if x > 0]` — 직접 작성하기보다 AI가 생성한 코드에서 읽고 해석하는 능력 훈련 ⑤ 내장 함수(len, max, min, sorted) vs 사용자 정의 함수 비교 |
| **산출물** | 함수 실습 코드, 리스트 컴프리헨션 읽기 연습 |

> ☕ **휴식 (16:00–16:15)**

#### 세션 3-5: Day 3 종합 실습 & 정리 (16:15–18:00, 105분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Day 3 기초문법 전체를 하나의 프로그램으로 통합하여 내재화한다 |
| **활동** | ① 종합 미니 스펙: 프롬프트로 "학생 성적 관리 프로그램" 생성 — 변수·리스트·딕셔너리·제어문·함수 모두 활용 ② 미니 스펙 추가: "점수 통계 분석기" — 여러 점수의 평균·최고·최저 계산 (NotebookLM 소스 기반) ③ 생성 코드 리뷰 게임: "이 코드에서 변수는 어디? 리스트는? 딕셔너리는? 함수는?" 찾기 (15분) ④ 함수 조합 심화: 성적 관리 프로그램에 "평균 계산", "최고/최저 성적" 함수를 프롬프트로 추가 (15분) ⑤ Day 3 핵심 정리 퀴즈 (5문항) ⑥ 개인별 Q&A — 문법 중 가장 헷갈리는 부분 집중 해결 (15분) ⑦ Day 4 예고: "내일은 진짜 프로그램을 만듭니다! Day 2의 PRD가 코드가 됩니다!" |
| **평가** | 체크리스트: 변수·타입 이해 ✓ 리스트/딕셔너리 활용 ✓ 제어문 이해 ✓ 함수 작성 ✓ |

---

### DAY 4 — 절차적·구조적 프로그래밍 & 코드 리뷰·테스트 (8시간)

#### 세션 4-1: 절차적 프로그래밍이란? (09:00–10:00, 60분)

> 🔍 **마이크로 세션**
> - [MS-PY101-065: 절차적 프로그래밍의 개념과 특징](micro_sessions/세션-065-절차적_프로그래밍의_개념과_특징.md) (20분)
> - [MS-PY101-066: AI 시대의 서사 복습: 구조적 프로그래밍으로의 여정](micro_sessions/세션-066-AI_시대의_서사_복습.md) (20분)
> - [MS-PY101-067: 고객 정보 관리 프로그램 PRD 복습 및 설계](micro_sessions/세션-067-고객_정보_관리_프로그램_PRD_설계.md) (20분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 절차적 프로그래밍의 개념을 이해하고, "AI 시대의 서사"에서 배운 패러다임 여정과 연결한다 |
| **핵심 개념** | 절차적 프로그래밍, 순차 실행, 전역 변수, 코드의 선형 흐름 |
| **비유** | 절차적 프로그래밍은 **"일렬로 늘어선 도미노"** — 첫 번째 도미노를 쓰러뜨리면 순서대로 쓰러진다. 간단하고 직관적이지만, 도미노가 1,000개가 되면 중간에 하나 빼거나 순서를 바꾸기가 매우 어렵다. "AI 시대의 서사" 2부에서 배운 **GOTO → 구조적 프로그래밍** 여정의 시작점 |
| **활동** | ① "AI 시대의 서사" 복습: 절차적 프로그래밍이 왜 등장했는지 (스파게티 코드 → 함수) ② 절차적 코드의 특징: 위에서 아래로, 전역 변수 사용, 함수가 데이터와 분리 ③ "고객 정보 관리 프로그램"의 PRD 복습 (Day 2 산출물) — 오늘 이 PRD를 코드로 만든다! |
| **산출물** | PRD 기반 기능 목록 확정 (FR-001~FR-004) |

#### 세션 4-2: AI로 절차적 고객관리 프로그램 생성 (10:00–12:00, 120분)

> 🔍 **마이크로 세션**
> - [MS-PY101-068: CRUD 개념 이해 및 1차 프롬프트 작성 실습](micro_sessions/세션-068-CRUD_개념_이해_및_1차_프롬프트_작성_실습.md) (25분)
> - [MS-PY101-069: 데이터 저장 구조\(전역 리스트, 딕셔너리\) 이해](micro_sessions/세션-069-데이터_저장_구조\(전역_리스트,_딕셔너리\)_이해.md) (20분)
> - [MS-PY101-070: 절차적 Create, Read 기능 구현 및 테스트](micro_sessions/세션-070-절차적_Create_Read_구현_및_테스트.md) (25분)
> - [MS-PY101-071: 절차적 Update, Delete 기능 구현 및 통합 테스트](micro_sessions/세션-071-절차적_Update_Delete_구현_및_통합_테스트.md) (25분)
> - [MS-PY101-072: 코드 리뷰: 전역 변수와 코드 중복의 한계점 발견](micro_sessions/세션-072-코드_리뷰-_전역_변수와_코드_중복의_한계점_발견.md) (20분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | AI를 활용해 절차적 방식으로 고객 정보 관리 프로그램을 생성하고, 코드를 리뷰한다 |
| **핵심 개념** | CRUD (Create, Read, Update, Delete), 메뉴 시스템, 데이터 저장(리스트+딕셔너리) |
| **프롬프트 전략** | 단계적 생성 (5대 필수 항목 적용): 전체 구조 → 기능별 구현 → 통합 |
| **실습** | ① 1차 프롬프트 (5대 항목 적용): "고객 정보(이름, 전화번호, 이메일)를 등록·조회·수정·삭제할 수 있는 콘솔 프로그램을 절차적으로 작성해줘. 전역 리스트에 딕셔너리로 저장하고, while True 메뉴 루프 사용" ② 예측→검증: 코드 실행 전 각 CRUD 기능의 동작 예측 → 실행 테스트 ③ 코드 리뷰: "이 코드를 한 줄씩 설명해줘" → AI의 설명을 보며 이해 ④ 코드 리뷰 5대 체크포인트 적용 (NotebookLM 소스 기반): 요구사항 충족? 입력 검증? 경계값? 자료구조? 가독성? ⑤ 문제점 발견: "이 코드의 문제점이나 개선할 점을 알려줘" → 전역 변수 문제, 코드 중복 등 식별 |
| **산출물** | customer_manager_v1.py (절차적 버전) |

> 🍽️ **점심시간 (12:00–13:00)**

#### 세션 4-3: 구조적 프로그래밍으로 업그레이드 (13:00–14:30, 90분)

> 🔍 **마이크로 세션**
> - [MS-PY101-073: 절차적 코드의 구조적 리팩토링 프롬프트 작성](micro_sessions/세션-073-절차적_코드의_구조적_리팩토링_프롬프트_작성.md) (20분)
> - [MS-PY101-074: 구조적 데이터 흐름\(매개변수와 리턴\)의 이해](micro_sessions/세션-074-구조적_데이터_흐름\(매개변수와_리턴\)의_이해.md) (20분)
> - [MS-PY101-075: 절차적 vs 구조적 코드 나란히 비교 분석](micro_sessions/세션-075-절차적_vs_구조적_코드_나란히_비교_분석.md) (20분)
> - [MS-PY101-076: 요구사항 추가를 통한 구조적 확장성 체험](micro_sessions/세션-076-요구사항_추가를_통한_구조적_확장성_체험.md) (25분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 절차적 코드를 구조적으로 리팩토링하는 프롬프트를 작성하고, 두 버전의 차이를 이해한다 |
| **핵심 개념** | 함수 분리, 모듈화, 매개변수 전달, 코드 재사용, 관심사 분리 |
| **비유** | 절차적→구조적은 **"원룸을 투룸으로 리모델링"** — 한 방에 침대·책상·주방이 다 있던 원룸(전역 변수+순차 코드)에서, 침실·서재·주방을 분리(함수 분리)하면 각 공간을 독립적으로 관리할 수 있다. "AI 시대의 서사"에서 배운 **데이크스트라의 구조적 프로그래밍**이 바로 이것 |
| **실습** | ① 프롬프트: "앞서 만든 절차적 고객관리 프로그램을 구조적으로 리팩토링해줘. 각 CRUD 기능을 별도 함수로 분리하고, 전역 변수 대신 함수 매개변수로 데이터를 전달해줘" ② 예측→검증: v2가 v1과 동일하게 작동하는지 확인 ③ 두 버전 코드 나란히 비교: 전역 변수 vs 매개변수, 인라인 코드 vs 함수 호출 ④ 프롬프트: "v1과 v2 코드를 비교해서 장단점을 표로 정리해줘" ⑤ 추가 요구사항: "검색 기능을 추가해줘" → 구조적 코드에서 함수 추가가 얼마나 쉬운지 체감 |
| **산출물** | customer_manager_v2.py (구조적 버전) |

#### 세션 4-4: 테스트 시나리오 & 코드 리뷰 종합 실습 (14:30–16:00, 90분)

> 🔍 **마이크로 세션**
> - [MS-PY101-077: 테스트는 시승이다: 테스트 시나리오 3분류 이해](micro_sessions/세션-077-테스트는_시승이다-_테스트_시나리오_3분류_이해.md) (20분)
> - [MS-PY101-078: 고객 관리 프로그램 테스트 시나리오 작성 실습](micro_sessions/세션-078-고객_관리_프로그램_테스트_시나리오_작성_실습.md) (25분)
> - [MS-PY101-079: 품질 검사관: 코드 리뷰 5대 체크포인트](micro_sessions/세션-079-품질_검사관-_코드_리뷰_5대_체크포인트.md) (20분)
> - [MS-PY101-080: 완벽한 리뷰 코멘트 작성 및 AI 피드백 실습](micro_sessions/세션-080-완벽한_리뷰_코멘트_작성_및_AI_피드백_실습.md) (25분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 테스트 시나리오 3분류(정상/경계값/예외)를 도출하고, 코드 리뷰 5대 체크포인트를 체계적으로 적용한다 |
| **핵심 개념** | 테스트 시나리오 도출, 정상·경계값·예외 케이스, 코드 리뷰 5대 체크포인트, 리뷰 코멘트 3요소 |
| **비유** | 테스트는 **"시승(Test Drive)"**이다 — 자동차를 만든 뒤(코드 생성) 바로 판매하지 않고, 직선 도로(정상), 급커브(경계값), 비포장 도로(예외)에서 시승해보는 것. 코드 리뷰는 **"품질 검사관"**의 체크리스트 |
| **활동** | ① 테스트 시나리오 3분류 학습 (NotebookLM 소스 기반): 정상 케이스(올바른 입력), 경계값 케이스(범위 끝값), 예외 케이스(잘못된 입력) ② v2 고객관리 프로그램에 대한 테스트 시나리오 표 작성 ③ 미니 스펙: "재고 관리 시스템" — 재고 추가·차감·기준 이하 조회 스펙 분석 → 테스트 시나리오 도출 → AI에 구현 요청 → 5대 체크포인트로 리뷰 (NotebookLM 소스 기반) ④ 리뷰 코멘트 작성 실습: 위치 + 문제점 + 재현 방법 3요소로 결함 기록 ⑤ 토론: "구조적으로도 충분하지 않나? 왜 다음 단계(OOP)가 필요할까?" → 한계 체감: "고객 데이터를 파일로 저장하는 기능을 추가해줘" → 데이터·함수 분리의 한계 |
| **산출물** | 절차적 vs 구조적 비교 분석표, 테스트 시나리오 표, 코드 리뷰 보고서 |

> ☕ **휴식 (16:00–16:15)**

#### 세션 4-5: Day 4 종합 실습 & 정리 (16:15–18:00, 105분)

> 🔍 **마이크로 세션**
> - [MS-PY101-081: Day 4 종합: 절차에서 구조로, 그리고 테스트까지](micro_sessions/세션-081-Day_4_종합-_절차에서_구조로,_그리고_테스트까지.md) (20분)
> - [MS-PY101-082: 나만의 미니 프로젝트: 기획 및 절차적 코드 생성](micro_sessions/세션-082-나만의_미니_프로젝트-_기획_및_절차적_코드_생성.md) (20분)
> - [MS-PY101-083: 미니 프로젝트: 구조적 리팩토링 및 퀄리티 체크](micro_sessions/세션-083-미니_프로젝트-_구조적_리팩토링_및_퀄리티_체크.md) (20분)
> - [MS-PY101-084: 미니 프로젝트: 극한의 테스트 시나리오 도출](micro_sessions/세션-084-미니_프로젝트-_극한의_테스트_시나리오_도출.md) (20분)
> - [MS-PY101-085: 미니 프로젝트: 코드 리뷰 기반 최종 완성 및 회고](micro_sessions/세션-085-미니_프로젝트-_코드_리뷰_기반_최종_완성_및_회고.md) (25분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Day 4 학습 내용을 내재화하고, Day 5 OOP를 위한 동기를 형성한다 |
| **활동** | ① 개인 실습: 자유 주제(예: 도서 관리, 메뉴 관리 등)를 절차적→구조적으로 2단계 생성 + 테스트 시나리오 작성 ② 코드 품질 비교 토론: v1 코드와 v2 코드를 AI에게 "코드 품질 점수"를 매겨달라고 요청하여 비교 (15분) ③ "AI 시대의 서사" 연결: 패러다임 여정 중 "데이터와 함수가 분리된 한계" → OOP 탄생 배경 복습 ④ Day 4 핵심 정리 퀴즈 (5문항) ⑤ 개인별 Q&A — 리팩토링·테스트 중 어려웠던 부분 해결 (15분) ⑥ Day 5 예고: "내일은 붕어빵 틀(클래스)을 배웁니다!" |
| **평가** | 체크리스트: 절차적 코드 생성 ✓ 구조적 리팩토링 ✓ 차이점 설명 가능 ✓ 테스트 시나리오 작성 ✓ 코드 리뷰 체크포인트 적용 ✓ |

---

### DAY 5 — 객체지향 프로그래밍 & DI 패턴 (8시간)

#### 세션 5-1: 클래스/인스턴스 — 붕어빵 틀과 붕어빵 (09:00–10:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 클래스와 인스턴스의 개념을 이해하고, 속성(attribute)과 메서드(method) 문법을 익힌다 |
| **핵심 개념** | 클래스(Class), 인스턴스(Instance/Object), `__init__`, self, 속성, 메서드, @dataclass 소개 |
| **비유** | "AI 시대의 서사"에서 배운 **"붕어빵 틀"** 비유를 이어간다 — 클래스 = 붕어빵 틀(설계도), 인스턴스 = 붕어빵(실제 만들어진 것). `class Customer:` = 고객 설계도, `customer1 = Customer("철수", "010-1234")` = 철수라는 실제 고객 |
| **실습** | ① 프롬프트: "고객(Customer) 클래스를 만들어줘. 이름, 전화번호, 이메일 속성을 가지고, 정보를 출력하는 메서드가 있어야 해" ② 생성 코드 리뷰: class, `__init__`, self, 메서드 한 줄씩 설명 ③ 인스턴스 생성 실습: 고객 3명 만들고 각각 정보 출력 ④ @dataclass 맛보기 (NotebookLM 소스 기반): "같은 Customer 클래스를 @dataclass로 만들어줘" → 코드 비교 — 딕셔너리의 한계를 극복하고 데이터를 더 체계적으로 다루는 방법 ⑤ 프롬프트: "학생(Student) 클래스도 만들어줘 — 이름, 학번, 성적 목록, 평균 성적 계산 메서드" |
| **산출물** | Customer, Student 클래스 코드, @dataclass 비교 |

#### 세션 5-2: OOP 리팩토링 — 고객관리 프로그램 v3 (10:30–12:00, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | Day 4의 구조적 고객관리 프로그램을 OOP로 리팩토링하고, 캡슐화 개념을 이해한다 |
| **핵심 개념** | OOP 리팩토링, 캡슐화(Encapsulation), 메서드 책임, 데이터+로직 통합, 데이터 검증 함수 |
| **비유** | OOP 리팩토링은 **"부서 조직 재편"** — 이전에는 "데이터 관리부"와 "기능 실행부"가 따로였는데, OOP에서는 "고객 관리팀(Customer 클래스)"이 고객 데이터와 관련 기능을 모두 갖고 자체적으로 처리한다. 캡슐화는 **"자동차 운전"** — 엔진 구조를 몰라도 핸들과 페달만 쓰면 된다 |
| **실습** | ① 프롬프트: "customer_manager_v2.py를 객체지향으로 리팩토링해줘. Customer 클래스와 CustomerManager 클래스를 만들어줘" ② 생성 코드 리뷰: v2와 v3 비교 — 데이터+함수가 클래스로 통합된 것 확인 ③ 데이터 검증 함수 추가 (NotebookLM 소스 기반): 전화번호 형식 검증, 이메일 형식 검증, 중복 전화번호 검증 ④ 캡슐화 체험: "고객의 전화번호를 직접 수정하지 못하게 하고, 메서드를 통해서만 수정하게 해줘" ⑤ 실행 테스트 + 코드 리뷰 5대 체크포인트 적용: v2와 동일하게 작동하는지 확인 |
| **산출물** | customer_manager_v3.py (OOP 버전, 데이터 검증 포함) |

> 🍽️ **점심시간 (12:00–13:00)**

#### 세션 5-3: 상속 — 확장과 재사용 (13:00–14:00, 60분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 상속의 개념을 이해하고, 기존 클래스를 확장하는 방법을 실습한다 |
| **핵심 개념** | 상속(Inheritance), 부모/자식 클래스, super(), 메서드 오버라이딩, 다형성 소개 |
| **비유** | "AI 시대의 서사"에서 배운 **"유산 상속"** 비유 — Customer(일반 고객)가 부모, VIPCustomer(VIP 고객)가 자식. VIP 고객은 일반 고객의 모든 기능을 물려받으면서 "할인율", "포인트 적립" 같은 고유 기능을 추가. 다형성은 **"리모컨의 전원 버튼"** — TV든 에어컨이든 같은 버튼인데 다른 동작 |
| **실습** | ① 프롬프트: "Customer 클래스를 상속받아 VIPCustomer 클래스를 만들어줘. 할인율과 포인트 속성을 추가하고, 정보 출력 시 VIP 표시" ② 생성 코드 리뷰: 상속, super(), 메서드 오버라이딩 확인 ③ 다형성 체험: 일반 고객과 VIP 고객을 같은 리스트에 넣고 반복문으로 정보 출력 → 같은 메서드 호출이 다른 결과 |
| **산출물** | VIPCustomer 상속 코드 |

#### 세션 5-4: DI 패턴 — 파일 저장 모듈화 (14:00–15:30, 90분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | DI(Dependency Injection) 개념을 이해하고, 고객 정보 저장 방식을 파일→DB로 교체 가능하도록 모듈화한다 |
| **핵심 개념** | 의존성 주입(DI), 인터페이스/추상 클래스, 저장소 패턴(Repository), 모듈 분리 |
| **비유** | DI는 **"교체 가능한 부품"** — 자동차의 타이어를 생각해보자. 일반 타이어(파일 저장)에서 스노우 타이어(DB 저장)로 바꿀 때, 자동차 전체(프로그램)를 바꾸는 게 아니라 타이어(저장 모듈)만 교체한다. "타이어 규격"(인터페이스)이 정해져 있으면 어떤 타이어든 끼울 수 있다 |
| **실습** | ① 프롬프트: "고객 정보를 JSON 파일로 저장하고 불러오는 FileStorage 클래스를 만들어줘" → 파일 저장 모듈 생성·리뷰 ② 프롬프트: "FileStorage와 같은 인터페이스를 가지는 SQLiteStorage 클래스를 만들어줘" → DB 저장 모듈 생성·리뷰 ③ 프롬프트: "CustomerManager가 저장소 객체를 외부에서 받도록(DI) 수정해줘. FileStorage든 SQLiteStorage든 교체 가능하게" ④ 실행 테스트: FileStorage로 실행 → SQLiteStorage로 교체 실행 → 같은 프로그램인데 저장 방식만 바뀌는 것 체감 ⑤ 최종 코드 리뷰 5대 체크포인트 적용 |
| **산출물** | customer_manager_v4.py + file_storage.py + sqlite_storage.py |

> ☕ **휴식 (15:30–15:45)**

#### 세션 5-5: 전체 과정 회고 & Day 5 종합 정리 (15:45–18:00, 135분)

| 항목 | 내용 |
|------|------|
| **학습 목표** | 5일간의 학습을 전체적으로 회고하고, AI-native 개발자로서의 방향성을 정립한다 |
| **활동** | ① 고객관리 프로그램 v1→v2→v3→v4 진화 과정 총정리: 절차적→구조적→OOP→DI. 프롬프트로 비교표 생성 ② "AI 시대의 서사" 최종 연결: **"문제를 정의하고 AI와 협업하는 사람"** — 우리는 이번 과정에서 이 역할을 실제로 해봤다 ③ SDD 총정리: 바이브 코딩 → 명세 주도 개발로의 여정 회고 ④ 개인 회고: "가장 인상 깊었던 것", "아직 어려운 것", "더 배우고 싶은 것" ⑤ 수료 프로젝트 공유: 각자의 v4 코드를 AI에게 "코드 리뷰"를 요청하여 결과 공유 + 5대 체크포인트 최종 적용 (15분) ⑥ 최종 퀴즈 (10문항): 전 과정 핵심 개념 확인 ⑦ 수료 후 학습 로드맵: 웹 개발(Flask/Django), 데이터 분석(Pandas), 자동화(Selenium) 등 ⑧ 심화 학습 상담: 개인별 관심 분야에 따른 학습 경로 추천 (15분) ⑨ 마무리 메시지: "여러분은 이제 AI에게 무엇을 시킬 수 있는 사람입니다" |
| **최종 평가** | 3대 필수 역량 점검: ① 파이썬 기초문법 이해 ✓ ② AI 도구로 코드 생성·리뷰 ✓ ③ AI 도구로 간단한 프로그램 작성 ✓ |

---

## 3. Step 6 — QA 검증 보고서

### 3.1 입력 사양 vs 커리큘럼 정합성 검증

| 입력 사양 | 검증 결과 | 상태 |
|-----------|----------|------|
| 40시간 (8h × 5일) | Day 1~5 각 8시간 (09:00–18:00, 점심 1h 제외) = 총 40시간. 일일 수업 465분 + 휴식 15분 = 480분(8h) | ✅ 충족 |
| 실습 60% 이상 | 전체 이론:실습 가중 평균 = 약 33:67 | ✅ 충족 |
| 비전공 취업준비생 대상 | 전문 용어 최소화, 비유 중심 설명, 타이핑 부담 제거 | ✅ 충족 |
| "AI 시대의 서사" 이수 전제 | 비유 체계 연계 (네비게이션, 붕어빵 틀, 레시피 카드 등), 패러다임 복습 세션 포함 | ✅ 충족 |
| Windows 11, Antigravity, Gemini 3 Pro | 전 실습 해당 환경 기반, Antigravity 상세 사용법 Day 1에 배치 | ✅ 충족 |
| 파트1: 환경 구축 & 프롬프트 | Day 1(환경) + Day 2(프롬프트/요구사항/PRD/SDD) | ✅ 충족 |
| 파트2: 기초문법 | Day 3 전체 | ✅ 충족 |
| 파트3: 절차적·구조적 | Day 4 전체 + 코드 리뷰·테스트 | ✅ 충족 |
| 파트4: OOP·DI | Day 5 전체 | ✅ 충족 |
| 산출물: 커리큘럼 + 세션 상세표 | 본 문서에 포함 | ✅ 충족 |
| NotebookLM 소스 기반 리서치 반영 | Trend_Report.md 생성, 본 문서 전반에 소스 기반 인사이트 통합 | ✅ 충족 |

### 3.2 "반드시 할 수 있어야 하는 것" 3가지 달성 경로

| 필수 역량 | 달성 경로 |
|-----------|----------|
| 파이썬 기초문법 이해 | Day 3 전체(변수·타입·자료구조·제어문·함수·리스트 컴프리헨션 읽기) + Day 4~5 실전 적용으로 내재화 |
| AI 도구로 코드 생성·리뷰 | Day 1 첫 프로그램부터 모든 세션에서 **예측→검증→설명** 사이클 반복 + Day 4 **코드 리뷰 5대 체크포인트** + **테스트 시나리오 3분류** |
| AI 도구로 간단한 프로그램 작성 | Day 4~5 고객관리 프로그램 v1→v4 점진적 구축, 미니 스펙 4회(Day 1~4) |

### 3.3 NotebookLM 소스 기반 반영 검증

| NotebookLM 인사이트 | 반영 위치 | 상태 |
|-------------------|----------|------|
| SDD(명세 주도 개발) 방법론 | Day 2 세션 2-3, Step 0 학습 방법론, USP #1 | ✅ |
| 거꾸로 학습 (Output-First) | Step 1 Trend Report, 학습 방법론 사이클 | ✅ |
| 예측→검증→설명 사이클 | 모든 세션의 실습 활동에 반영 | ✅ |
| 5 Whys 기법 | Day 1 세션 1-3, 1-6 트러블슈팅 실습 | ✅ |
| 프롬프트 5대 필수 명시 항목 | Day 2 세션 2-2, Day 4 세션 4-2 | ✅ |
| 코드 리뷰 5대 체크포인트 | Day 4 세션 4-4, Day 5 세션 5-2, 5-5 | ✅ |
| 테스트 시나리오 3분류 | Day 4 세션 4-4 (신규 추가) | ✅ |
| 리뷰 코멘트 3요소 | Day 4 세션 4-4 | ✅ |
| 미니 스펙 과제 | Day 1~4 종합실습에 통합 | ✅ |
| @dataclass 소개 | Day 5 세션 5-1 | ✅ |
| 리스트 컴프리헨션 읽기 | Day 3 세션 3-4 | ✅ |
| 데이터 검증 함수 | Day 5 세션 5-2 | ✅ |

### 3.4 학습 흐름 연속성 검증

```
Day 1: 환경 준비 (도구 갖추기) — Antigravity + Python + uv + 5 Whys 트러블슈팅
  ↓ "도구는 준비됐다. 이제 AI와 대화하는 법을 배우자"
Day 2: 프롬프트 작성법 (AI와 대화하는 법) — 5대 항목 + SDD + 요구사항 + PRD
  ↓ "대화법을 익혔다. 이제 파이썬의 언어를 이해하자"
Day 3: 기초문법 (파이썬 언어 이해) — 변수·자료구조·제어문·함수·컴프리헨션 읽기
  ↓ "언어를 알았다. 이제 진짜 프로그램을 만들고 검증하자"
Day 4: 절차적→구조적 (실전 프로그램 + 코드 리뷰·테스트) — 고객관리 v1→v2 + 5대 체크포인트
  ↓ "프로그램은 만들었다. 이제 더 좋은 구조로 발전시키자"
Day 5: OOP→DI (프로그램 진화) — 고객관리 v3→v4 + @dataclass + 최종 검증
```

- **관통 프로젝트**: "고객 정보 관리 프로그램"이 Day 2(PRD)부터 Day 5(DI)까지 일관되게 관통
- **미니 스펙 과제**: 일차별 독립 과제로 개념 강화 (성적 판정기, 통계 분석기, 할인가 계산기, 재고 관리)
- **비유 체계**: "AI 시대의 서사"의 비유가 전 과정에 걸쳐 일관되게 참조
- **패러다임 여정**: Day 4~5에서 "AI 시대의 서사" 2부의 패러다임 진화(절차적→구조적→OOP)를 직접 체험

---

## 4. 부록

### A. 일차별 필요 소프트웨어

| 일차 | 소프트웨어 | 비고 |
|------|-----------|------|
| Day 1 | Google Antigravity IDE, Python 3.12+, uv | 설치 과정이 실습 자체 |
| Day 2 | 위와 동일 | — |
| Day 3 | 위와 동일 | — |
| Day 4 | 위와 동일 + (선택) JSON 뷰어 | 고객 데이터 JSON 확인용 |
| Day 5 | 위와 동일 + SQLite (Python 내장) | (선택) DB Browser for SQLite |

### B. 일차별 핵심 산출물

| 일차 | 산출물 |
|------|--------|
| Day 1 | 환경 구축 완료 (Antigravity + Python + uv), hello.py, 고객 1명 입출력 프로그램 |
| Day 2 | 프롬프트 실험 기록 (5대 항목), 요구사항 문서, PRD 문서 (FR 코드 포함), 미니 프로젝트 |
| Day 3 | 기초문법 실습 코드 (변수/자료구조/제어문/함수/컴프리헨션), 학생 성적 관리 프로그램, 점수 통계 분석기 |
| Day 4 | customer_manager_v1.py (절차적), customer_manager_v2.py (구조적), 비교 분석표, 테스트 시나리오 표, 코드 리뷰 보고서 |
| Day 5 | customer_manager_v3.py (OOP, 데이터 검증 포함), customer_manager_v4.py (DI) + file_storage.py + sqlite_storage.py, @dataclass 비교 코드 |

### C. 평가 체계

| 평가 항목 | 방법 | 시점 |
|-----------|------|------|
| 일일 체크리스트 | 자가 점검 (4~5항목) | 매일 마지막 세션 |
| 일일 퀴즈 | 객관식 + 단답형 (5문항) | 매일 마지막 세션 |
| 미니 스펙 프로젝트 | 스펙 기반 프로그램 생성 | Day 1~4 |
| 최종 퀴즈 | 전 과정 핵심 (10문항) | Day 5 마지막 |
| 최종 산출물 | 고객관리 프로그램 v4 완성 | Day 5 |

### D. v2.2 개선 사항 (v2.1 대비)

| 항목 | v2.1 | v2.2 |
|------|------|------|
| **NotebookLM 리서치** | 미반영 | NotebookLM 소스 3건 쿼리 결과 통합, Trend_Report.md 별도 생성 |
| **학습 방법론** | AI-first (프롬프트→생성→리뷰) | SDD + 거꾸로 학습 + 예측→검증→설명 사이클 + 5 Whys 기법 (소스 기반 강화) |
| **프롬프트 교육** | 4요소 (Persona, Task, Context, Format) | 4요소 + **5대 필수 명시 항목** (기능·입력·출력·제약·예외) + CoT + Few-shot |
| **코드 리뷰** | 일반적 리뷰 | **5대 체크포인트** + 리뷰 코멘트 3요소 (체계적 프레임워크) |
| **테스트** | 미포함 | **테스트 시나리오 3분류** (정상/경계값/예외) — Day 4 세션 4-4 신규 추가 |
| **미니 스펙** | 미포함 | 일차별 미니 스펙 과제 (성적 판정기, 통계 분석기, 할인가 계산기, 재고 관리) 통합 |
| **Day 3 세션 3-4** | 함수만 | 함수 + **리스트 컴프리헨션 읽기** 추가 |
| **Day 4 제목** | 절차적·구조적 프로그래밍 | 절차적·구조적 프로그래밍 & **코드 리뷰·테스트** |
| **Day 4 세션 4-4** | 절차적 vs 구조적 비교 분석 & 정리 (60분) | **테스트 시나리오 & 코드 리뷰 종합 실습** (90분) — 미니 스펙 "재고 관리" 포함 |
| **Day 5 @dataclass** | 미포함 | **@dataclass 기초 소개** (Day 5 세션 5-1) |
| **Day 5 데이터 검증** | 미포함 | **전화번호·이메일·중복 검증 함수** (Day 5 세션 5-2, FR 코드 기반) |
| **Pain Point** | 5가지 | 6가지 — **AI 의존 우려** 추가 + 예측→검증→설명으로 대응 |
| **USP** | 5가지 | 6가지 — **체계적 코드 리뷰 & 테스트** 추가 |
| **QA 검증** | 11항목 | 12항목 — **NotebookLM 소스 반영 검증** 섹션 추가 (12개 인사이트별 반영 위치 매핑) |
| **run_id 추적** | run_20260224_193214 | run_20260224_194045, NotebookLM 쿼리 3건 실행 이력 |


### D-2. v3.0 개선 사항 (v2.2 대비)

| 항목 | v2.2 | v3.0 |
|------|------|------|
| **트렌드 리서치** | NotebookLM 소스 3건 | NotebookLM + **Deep Research (실시간 웹 검색 15건)** 통합 |
| **SDD 방법론** | 개념 소개 | + **학술적 검증** (arxiv:2602.00180v1, 2026-01-30) + **JetBrains 2026 예측** (TFiR, 2026-02-12) |
| **Antigravity IDE** | 2025.11 출시 정보 | + **Firebase Studio 통합**, Skills/MCP/Workflows 신규 기능, App Prototyping Agent |
| **uv 패키지 매니저** | 기본 명령어 | + **v0.10.5** (2026-02-23), GitHub Stars 79,700+, **Octoverse 2025 최고 성장**, 단일 도구 통합, PEP 751 |
| **Gemini 모델** | Gemini 3 Pro 단일 | **Gemini 3 시리즈 전체** (3.1 Pro, 3 Pro, 3 Flash, 3 Deep Think) + 벤치마크 수치 |
| **채용 트렌드** | 3항목 | + **AI 리터러시 4단계 모델**, 신규 요구 역량 4가지 |
| **프롬프트 엔지니어링** | 5대 필수 항목 | + **섹션 7 신규**: Firebase Studio 5원칙, 멀티모달 프롬프팅, SDD 5단계 프레임워크 |
| **run_id 추적** | run_20260224_194045 | run_20260224_204705, Deep Research 웹 검색 15건 + 백그라운드 에이전트 실행 |
### E. 이전 버전 개선 이력

| 버전 | 주요 변경 |
|------|----------|
| v1.0 → v2.0 | Antigravity IDE 상세, uv 명령어 확대, Gemini 3 Pro 상세, 프롬프트 4요소 반영, 비유 체계 강화 |
| v2.0 → v2.1 | 시간 계산 정합성(8h), 종합 실습 확대(105분), QA 시간 검증 명시, 트렌드 재검증 |
| v2.1 → v2.2 | **NotebookLM 소스 기반 리서치 통합** — SDD, 5대 체크포인트, 테스트 3분류, 미니 스펙, @dataclass, 리스트 컴프리헨션 등 |
| v2.2 → v3.0 | **Deep Research 실시간 웹 검색 통합** — SDD 학술 검증, Antigravity/Firebase Studio 최신 기능, uv v0.10.5, Gemini 3 시리즈 벤치마크, AI 리터러시 4단계, 프롬프트 엔지니어링 섹션 7 신규 |

---

*본 문서는 01_Lecture_Planning Pipeline 워크플로우의 전체 8단계(Step 0~7)를 실행하여 생성되었습니다. NotebookLM 소스 기반 리서치(3건 쿼리) + Deep Research 실시간 웹 검색(15건) 결과가 전반에 통합되었습니다. (v3.0, run_20260224_204705)*
