# 마이크로 세션: 058-내장 함수 활용

## 📋 메타 정보
| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-Python-058 |
| **소요 시간** | 15분 |
| **예상 교안 분량** | 3,000자 |
| **선행 세션** | 세션-048, 057 (필수) |
| **후행 세션** | 세션-059 |
| **핵심 키워드** | 내장 함수, len, max, min, sorted |
| **난이도** | low |
| **청크 타입** | code |

## 🎯 학습 목표
단 1개의 구체적인 학습 목표 (SMART 원칙 적용):
- 이 세션 종료 시 수강생은 파이썬이 기본 제공하는 대표적인 내장 함수(len, max, min, sorted)를 활용하여 데이터를 손쉽게 가공할 수 있다.

## 🗣️ 강사 대본 구성

### 예상 분량
- **최소**: 공백 포함 1,500자
- **최대**: 공백 포함 2,000자
- **화법**: 친근한 구어체 (~해요, ~입니다)

### 서술 흐름 (반드시 포함)
1. **도입 (Hook)**: "우리가 100명의 학생 점수가 담긴 리스트를 가지고 있습니다. 여기서 가장 점수가 높은 1등의 점수를 찾으려면 어떻게 해야 할까요? 반복문으로 하나하나 꺼내서 다 비교해 봐야 할까요?"
2. **비유 (Analogy)**: "다행히 그럴 필요가 없습니다. 파이썬에는 '내장 함수(Built-in Function)'라는 게 있거든요. 이건 파이썬을 설치할 때 기본으로 제공되는 **다이소 만능 공구함**과 같습니다. 자주 쓰는 공구들은 굳이 우리가 대장간(def)에서 쇠를 두드려 만들 필요 없이, 다이소에서 꺼내 쓰기만 하면 되는 거죠."
3. **개념 설명 (What)**: "가장 대표적인 공구 4가지를 소개할게요. 먼저 `len()`입니다. 리스트 안에 아이템이 몇 개 있는지 길이를 재주는 줄자예요. `max()`와 `min()`은 가장 큰 놈과 작은 놈을 단박에 찾아주는 족집게입니다. 마지막으로 `sorted()`는 마구잡이로 섞인 데이터를 오름차순으로 예쁘게 정렬해주는 마법의 정리함입니다."
4. **실제 활용 (How)**: "우리가 어제 배운 `print()`나 `type()`, `int()` 같은 것들도 사실 전부 이 공구함에 들어있던 내장 함수들이었습니다. 공구를 쓰는 방법은 우리가 함수를 쓸 때와 완벽히 똑같아요. 공구 이름(함수명)을 부르고 괄호 안에 재료(리스트나 변수)를 넣어주면 됩니다. `max(scores)`라고 쓰면 1등 점수를 반환(return)해 주는 식이죠."
5. **정리 (Checkpoint)**: "코드를 짤 때 '이거 누군가 이미 만들어놓지 않았을까?' 하는 의심을 갖는 건 훌륭한 개발자의 덕목입니다. 웬만한 건 파이썬 다이소에 다 있습니다. 프롬프트를 쓸 때도 '파이썬 내장 함수를 써서 코드를 짜줘'라고 하면 훨씬 깔끔한 코드가 나옵니다."

### 예시 스크립트 (필수 - 작성자 참고용)
> "100명의 점수 중 1등을 찾으려면 어떻게 할까요? 반복문으로 다 돌면서 비교하려면 코드가 꽤 길어집니다. 다행히 파이썬에는 '내장 함수'라는 게 있습니다. 파이썬이 기본으로 주는 **다이소 만능 공구함**이죠. 자주 쓰는 공구는 굳이 직접 만들 필요 없이 꺼내 쓰면 됩니다.
가장 많이 쓰는 4대 천왕을 소개할게요. `len()`은 리스트에 물건이 몇 개 있는지 길이를 재주는 줄자입니다. `max()`와 `min()`은 가장 큰 값과 작은 값을 0.1초 만에 찾아내는 족집게예요. `sorted()`는 뒤죽박죽인 점수들을 예쁘게 오름차순 정렬해 줍니다. 
쓰는 법도 아주 쉬워요. 우리가 방금 배운 함수 호출과 똑같습니다. `max([10, 50, 20])`이라고 자판기에 동전 넣듯 넣어주면, 자판기가 50이라는 결과를 덜컹 뱉어냅니다. AI에게 프롬프트를 줄 때 '파이썬 내장 함수를 적극적으로 활용해줘'라고 하면 코드가 훨씬 짧고 우아해집니다!"

## 🎙️ 실습 가이드 (해당 시)

### 실습 목표
- 이 실습을 통해 수강생은 대표적인 파이썬 내장 함수의 편리함을 체험하고 결과를 출력한다.

### 단계별 지시
| 단계 | 소요 시간 | 강사 지시사항 | 예상 결과 |
|------|----------|--------------|----------|
| 1 | 3분 | "AI에게 '무작위 숫자 7개가 들어간 파이썬 리스트를 하나 만들어줘'라고 하세요." | `nums = [45, 12, ...]` 리스트 생성 |
| 2 | 5분 | "그 밑에 이 리스트의 길이(len), 최댓값(max), 최솟값(min)을 구해서 출력하는 코드를 프롬프트 없이 직접 손으로 쳐보세요!" | `print(len(nums))`, `print(max(nums))` 등 |
| 3 | 2분 | "마지막으로 `sorted(nums)`를 써서 리스트가 예쁘게 정렬되는지 확인해 보세요." | 오름차순 정렬된 리스트 출력 확인 |

### 주의사항 및 트러블슈팅
- 흔한 오류 1: `len`을 리스트의 메서드처럼 `nums.len()`으로 작성 (해결법: 내장 함수는 괄호 안에 리스트를 집어넣는 형태 `len(nums)`임을 비교 설명)
- 흔한 오류 2: `sorted`의 결과를 저장하지 않고 원본이 바뀌었다고 착각 (해결법: `sorted()`는 정렬된 '새로운 복사본'을 반환한다는 점 살짝 언급)

## 💡 비유 및 스토리텔링

### 핵심 비유
- **비유**: 다이소 만능 공구함
- **설명**: 필요할 때마다 처음부터 도구를 만드는 것이 아니라, 이미 최적화되어 잘 만들어진 기성품 도구를 가져다 쓰는 프로그래밍의 효율성을 강조합니다.
- **AI 시대의 서사 연결**: "AI는 이 수천 개의 공구함 목록을 완벽하게 외우고 있습니다. 우리가 일일이 로직을 고민할 필요 없이 '가장 큰 값 찾아줘'라고 하면 AI가 알아서 공구를 꺼내 씁니다."

### 스토리텔링 포인트
- 감정적 연결: 복잡한 수학 로직(최댓값 찾기 알고리즘)을 직접 짜야 할까 봐 겁먹었던 수강생들에게 "사실 그거 다 만들어져 있어"라는 큰 안도감을 줍니다.
- 전환 멘트: "자판기도 만들었고 공구함도 썼습니다. 코딩이 참 편해졌죠? 그런데 파이썬 개발자들은 더 심한 귀차니즘에 걸렸습니다. 4줄짜리 for문을 단 1줄로 줄여버리는 외계어 같은 마법을 만들었거든요."

## 🔗 의존성 및 연결성

### 필수 선행 지식
- 세션-057: 함수 호출 원리 (재료를 넣고 결과를 돌려받는 구조)
- 세션-048: 리스트 구조 (내장 함수의 주 사용 대상)

### 후속 연결
- 세션-059: 리스트 컴프리헨션 읽는 법 (파이썬 특유의 축약 문법 학습)

### 브릿지 노트 예시
> "다이소 공구함 덕분에 코드가 아주 짧고 우아해졌습니다. 그런데 파이썬의 고수들은 여기서 만족하지 않아요. 그들은 3~4줄짜리 for 반복문을 단 1줄로 압축해버리는 기가 막힌 문법을 만들었습니다. AI도 이 문법을 정말 좋아해서 숨 쉬듯이 만들어냅니다. 세션-059에서 이 외계어(?)를 해독하는 법을 배워봅시다."

## 📝 Gemini 프롬프트 최적화 태그
```yaml
gemini_optimized:
  chunk_type: code
  complexity: low
  estimated_chars: 3000
  output_style: continuous_prose
  tone: friendly_spoken_korean
  include:
    - instructor_script: true
    - lab_guide: true
    - analogy: detailed_situation
    - mermaid_diagram: false
  prerequisites:
    mandatory: [048, 057]
    recommended: []
```

## ✅ 체크리스트 (작성자 자가 검증)
- [x] 단 1개의 핵심 학습 목표만 명시했는가?
- [x] 소요 시간이 15~25분 범위인가?
- [x] 강사 대본 예상 분량이 1,500~2,000자 범위인가?
- [x] chunk_type, complexity 태그를 부여했는가?
- [x] 선행/후행 세션을 명확히 연결했는가?
- [x] 비유가 'AI 시대의 서사' 톤과 일치하는가?
