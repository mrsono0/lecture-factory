# 마이크로 세션: 076-요구사항 추가를 통한 구조적 확장성 체험

## 📋 메타 정보
| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-076 |
| **소요 시간** | 25분 |
| **예상 교안 분량** | 4,000자 |
| **선행 세션** | 세션-075 (필수) |
| **후행 세션** | 세션-077 |
| **핵심 키워드** | 유지보수, 확장성, 기능 추가, 플러그인 |
| **난이도** | medium |
| **청크 타입** | lab |

## 🎯 학습 목표
단 1개의 구체적인 학습 목표 (SMART 원칙 적용):
- 이 세션 종료 시 수강생은 구조적으로 분리된 v2 코드에 '검색 기능'을 추가하는 프롬프트를 실행하고, 기존 코드에 미치는 영향을 최소화하며 기능이 확장됨을 검증할 수 있다.

## 🗣️ 강사 대본 구성

### 예상 분량
- **최소**: 공백 포함 1,500자
- **최대**: 공백 포함 2,000자
- **화법**: 친근한 구어체 (~해요, ~입니다)

### 서술 흐름 (반드시 포함)
1. **도입 (Hook)**: 실제 현장에서는 프로그램 런칭 다음 날 무조건 '기능 추가 요구'가 들어온다는 현실(Horror) 상황 가정 (2~3문장)
2. **비유 (Analogy)**: 구조적 확장을 '레고 블록 조립'이나 '멀티탭에 새 플러그 꽂기'에 비유 (5~8문장)
3. **개념 설명 (What)**: 기존 함수들은 전혀 건드리지 않고, 새로운 `def search_customer()` 함수만 추가하여 메인 메뉴에 연결하는 확장성(Scalability) 원리 설명 (8~12문장)
4. **실제 활용 (How)**: AI에게 "v2 코드에 검색 기능을 추가해줘"라고 요구하고, 수정된 코드 부분을 추적
5. **정리 (Checkpoint)**: 이것이 우리가 리팩토링이라는 귀찮은 작업을 한 진짜 이유임을 강조 (2~3문장)

### 예시 스크립트 (필수 - 작성자 참고용)
> "자, 오픈 첫날 사장님이 말합니다. '아이고, 고객이 1,000명이 넘어가니까 Read로 전체 목록을 보는 게 너무 힘드네. 이름으로 한 명만 찾는 검색 기능 좀 추가해줘.' 만약 v1이었다면? 거대한 `while`문 뱃속을 갈라서 `if`문을 우겨넣다가 다른 기능까지 고장 냈을 겁니다. 하지만 v2는 어떨까요? 레고 블록 꽂는 거랑 똑같아요. 기존의 C, R, U, D 방은 문 꽉 닫아놓고 전혀 건드리지 않아요. 그냥 옆에 '검색'이라는 예쁜 방(`def search_customer`)을 하나 새로 짓고, 메인 팀장님(`while` 루프)한테 '5번 누르면 저 방으로 보내세요'라고 한 줄만 추가하면 끝입니다. AI에게 이 지시를 내려볼까요? 얼마나 깔끔하게 확장되는지 확인해 봅시다."

## 🎙️ 실습 가이드 (해당 시)

### 실습 목표
- 이 실습을 통해 수강생은 모듈화된 코드가 새로운 기능 추가 시 얼마나 유연하고 안전한지 직접 체험한다.

### 단계별 지시
| 단계 | 소요 시간 | 강사 지시사항 | 예상 결과 |
|------|----------|--------------|----------|
| 1 | 5분 | "Gemini에게 'v2 코드를 바탕으로 이름으로 검색하는 기능을 새로 추가해줘. 기존 함수는 수정하지 말고 새 함수를 만들어 메인 메뉴에 연결해'라고 요청하세요." | 새 코드가 포함된 v2.1 코드 생성 |
| 2 | 5분 | "생성된 코드에서 어떤 부분만 바뀌었는지 눈으로 확인하세요. (새 def 추가됨, 메뉴 번호 하나 추가됨)" | 변경 범위의 최소화 체감 |
| 3 | 5분 | "코드를 실행해서 데이터 2~3개를 넣고, 새로 만든 5번(검색) 기능을 테스트해 보세요." | 검색 기능 정상 작동 확인 |

### 주의사항 및 트러블슈팅
- 흔한 오류 1: AI가 검색 함수를 만들었지만 메인 루프에 메뉴 번호를 연결하지 않은 경우 (해결법: 사용자가 메뉴 번호가 없으면 실행할 수 없다는 점을 인지시키고 추가 요청하게 함)

## 💡 비유 및 스토리텔링

### 핵심 비유
- **비유**: 멀티탭에 플러그 꽂기와 레고 블록
- **설명**: 잘 모듈화된 코드는 기존 구조를 훼손하지 않고 새로운 기능을 마치 플러그를 꽂듯이 부착할 수 있음을 시각화.
- **AI 시대의 서사 연결**: "AI로 코딩하면 유지보수가 안 된다"는 말은 v1 같은 스파게티로 짰을 때의 이야기입니다. v2처럼 블록화해 두면, AI에게 "다른 건 놔두고 딱 이 블록 하나만 만들어줘"라고 지시할 수 있어 훨씬 빠르고 안전한 AI 개발이 가능해집니다.

### 스토리텔링 포인트
- 감정적 연결: 기능을 하나 추가했더니 멀쩡하던 다른 기능이 터져버리던 악몽에서 해방되는 기쁨
- 전환 멘트: "멋집니다! 방도 예쁘게 나누고 확장까지 완벽하네요. 그럼 이 코드, 내일 당장 출시해도 될까요? 아뇨, 그 전에 반드시 거쳐야 할 '안전 검사'가 남아있습니다."

## 🔗 의존성 및 연결성

### 필수 선행 지식
- 세션-075: 절차적 vs 구조적 코드 나란히 비교 분석 (구조적 코드의 장점을 인지한 상태)

### 후속 연결
- 세션-077: 테스트는 시승이다: 테스트 시나리오 3분류 이해

### 브릿지 노트 예시
> "프로그램이 구조적으로 탄탄해졌다고 확신하시나요? 자동차 공장에서 뼈대를 잘 맞췄다고 바로 팔진 않죠. 고객에게 가기 전, 우리는 이 차를 '시승'해봐야 합니다. 다음 세션부터는 버그를 잡아내는 '테스트'의 세계로 진입하겠습니다."

## 📝 Gemini 프롬프트 최적화 태그
```yaml
gemini_optimized:
  chunk_type: lab
  complexity: medium
  estimated_chars: 4000
  output_style: continuous_prose
  tone: friendly_spoken_korean
  include:
    - instructor_script: true
    - lab_guide: true
    - analogy: detailed_situation
    - mermaid_diagram: false
  prerequisites:
    mandatory: [MS-PY101-075]
    recommended: []
```


## 📚 참고자료 매핑

| 참고자료 | 관련 섹션 | 활용 방법 |
|----------|----------|----------|
| 7 기획.pdf | §7.3 PRD 구조 | PRD 복습 및 활용 |
| 8 코딩.pdf | §8.10 리팩토링과 구조적 프로그래밍 | 코드 개선 패턴 및 전략 |

## ✅ 체크리스트 (작성자 자가 검증)
- [x] 단 1개의 핵심 학습 목표만 명시했는가?
- [x] 소요 시간이 15~25분 범위인가?
- [x] 강사 대본 예상 분량이 1,500~2,000자 범위인가?
- [x] chunk_type, complexity 태그를 부여했는가?
- [x] 선행/후행 세션을 명확히 연결했는가?
- [x] 비유가 'AI 시대의 서사' 톤과 일치하는가?