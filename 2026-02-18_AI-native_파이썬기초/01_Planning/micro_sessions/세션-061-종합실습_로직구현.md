# 마이크로 세션: 061-[종합 실습 2] 제어문과 함수로 로직 구현

## 📋 메타 정보
| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-Python-061 |
| **소요 시간** | 25분 |
| **예상 교안 분량** | 3,800자 |
| **선행 세션** | 세션-060 (필수) |
| **후행 세션** | 세션-062 |
| **핵심 키워드** | 종합 실습, 함수 모듈화, 제어문 통합 |
| **난이도** | high |
| **청크 타입** | lab |

## 🎯 학습 목표
단 1개의 구체적인 학습 목표 (SMART 원칙 적용):
- 이 세션 종료 시 수강생은 준비된 데이터를 바탕으로 개별 로직을 처리하는 함수를 생성하고, 이를 반복문으로 연결하는 전체 프로그램 흐름을 구현할 수 있다.

## 🗣️ 강사 대본 구성

### 예상 분량
- **최소**: 공백 포함 1,500자
- **최대**: 공백 포함 2,000자
- **화법**: 친근한 구어체 (~해요, ~입니다)

### 서술 흐름 (반드시 포함)
1. **도입 (Hook)**: "데이터는 완벽하게 준비되었습니다. 이제 요구사항의 두 번째 미션을 볼까요? '각 학생의 수학/영어 평균을 구하고, 평균이 80점 이상이면 PASS, 아니면 FAIL을 판별하라.' 어떻게 시작해야 할까요?"
2. **비유 (Analogy)**: "큰 문제를 한 번에 풀려고 하면 체합니다. **공장의 컨베이어 벨트**를 생각해 보세요. 한 직원이 조립, 도색, 포장을 다 하지 않습니다. '평균 구하는 기계(함수 1)', '합격 판별하는 기계(함수 2)'를 따로 만들고, 컨베이어 벨트(반복문)로 데이터를 쭉 흘려보내는 겁니다."
3. **개념 설명 (What)**: "이것이 바로 '모듈화'의 기초입니다. 코드를 잘게 쪼개는 거죠. 우리는 프롬프트를 2번 나눠서 쓸 겁니다. 첫째, 한 명의 딕셔너리를 던져주면 평균과 결과를 return하는 함수를 만들어달라고 합니다. 둘째, for문으로 리스트를 쭉 돌면서 방금 만든 함수에 학생들을 한 명씩 집어넣어 달라고 하는 거죠."
4. **실제 활용 (How)**: "프롬프트로 이렇게 지시해 봅시다. '이전에 만든 students 리스트를 for문으로 순회해줘. 순회하면서 학생 1명의 딕셔너리를 받아 평균을 계산하고 80점 이상인지 판별해 출력하는 함수를 호출해줘.' AI는 우리가 생각한 이 컨베이어 벨트 구조를 완벽하게 파이썬 코드로 번역해 줄 겁니다."
5. **정리 (Checkpoint)**: "데이터(리스트)를 반복문(for)으로 돌리면서, 개별 처리(함수)와 판단(if)을 수행한다! 이것이 파이썬, 아니 모든 프로그래밍 언어를 관통하는 절대적인 패턴입니다."

### 예시 스크립트 (필수 - 작성자 참고용)
> "데이터가 준비되었으니 두 번째 요구사항을 봅니다. '평균을 구하고 80점 이상이면 PASS를 판별하라.' 한 줄의 코드로 다 짜려고 하지 마세요. **공장의 컨베이어 벨트**처럼 생각해야 합니다. '평균 구하고 판별하는 기계(함수)'를 하나 만들고, '컨베이어 벨트(for문)'를 돌려 학생을 한 명씩 기계에 넣는 겁니다. 
이게 로직을 잘게 쪼개는 '모듈화'의 기초입니다. 우리는 AI에게 이 구조를 명확히 지시할 겁니다. '학생 1명의 정보를 받아서 평균을 계산하고 PASS/FAIL을 판별하는 함수를 먼저 만들어. 그리고 그 밑에 for문으로 students 리스트를 순회하면서 그 함수에 한 명씩 밀어 넣어줘.'
이렇게 지시하면 코드가 굉장히 깔끔해집니다. 리스트를 for문으로 순회하고, if문으로 판별하고, 함수로 묶는다. 이 콤보가 모든 프로그래밍의 핵심 뼈대입니다. 바로 실습해 보죠!"

## 🎙️ 실습 가이드 (해당 시)

### 실습 목표
- 이 실습을 통해 수강생은 함수와 제어문을 조합하여 실질적인 비즈니스 로직을 처리하는 코드를 AI의 도움을 받아 구현한다.

### 단계별 지시
| 단계 | 소요 시간 | 강사 지시사항 | 예상 결과 |
|------|----------|--------------|----------|
| 1 | 5분 | "AI에게 '학생 1명의 딕셔너리 데이터를 매개변수로 받아서 평균을 계산하고, 80점 이상이면 PASS, 아니면 FAIL을 문자열로 반환(return)하는 함수 `evaluate_student`를 짜줘'라고 하세요." | `def evaluate_student(student):` 함수 생성 |
| 2 | 5분 | "다음으로 '앞서 만든 students 리스트를 for문으로 순회하면서, 각 학생을 evaluate_student 함수에 넣고, 그 결과(이름, 평균, PASS/FAIL)를 f-string으로 예쁘게 출력해줘'라고 지시하세요." | for문 내부에서 함수를 호출하는 흐름 생성 |
| 3 | 5분 | "생성된 전체 코드를 IDE에 합쳐서 실행해 보세요! 3명의 학생 결과가 주르륵 출력되나요?" | 학생별 평가 결과가 포맷팅되어 콘솔에 출력됨 |

### 주의사항 및 트러블슈팅
- 흔한 오류 1: 함수 선언 위치 오류 (해결법: 파이썬은 위에서 아래로 읽기 때문에, `def` 함수 선언이 항상 `for`문 호출보다 위에 있어야 함을 짚어줍니다)
- 흔한 오류 2: 함수에 리스트 통째로 넣기 (해결법: 컨베이어 벨트 비유를 다시 들며, 기계에는 한 번에 1명(딕셔너리 1개)씩만 들어가야 함을 강조)

## 💡 비유 및 스토리텔링

### 핵심 비유
- **비유**: 공장 컨베이어 벨트(for문)와 전용 기계(함수)
- **설명**: 대량의 데이터 묶음을 반복문을 통해 하나씩 분리한 뒤, 특정 작업을 수행하는 함수라는 기계에 통과시키는 일련의 시스템입니다.
- **AI 시대의 서사 연결**: "복잡한 요구사항을 '컨베이어 벨트'와 '기계' 단위로 분해해서 AI에게 설명하는 능력, 이것이 바로 프롬프트 엔지니어링의 정수입니다."

### 스토리텔링 포인트
- 감정적 연결: 복잡해 보이는 로직도 쪼개면 "반복하기"와 "판별하기"일 뿐이라는 것을 깨닫게 하여 코딩에 대한 자신감을 줍니다.
- 전환 멘트: "개별 학생에 대한 처리는 완벽하게 끝났습니다. 그런데 교장 선생님이 '우리 학교 전체 수학 평균이 몇 점이야?'라고 물어본다면 어떨까요? 이 데이터들을 다시 뭉쳐서 통계를 내야겠죠."

## 🔗 의존성 및 연결성

### 필수 선행 지식
- 세션-060: 데이터 구조 세팅 (실습의 기반 데이터)
- 세션-052~057: 제어문, 반복문, 함수 기본 문법 종합

### 후속 연결
- 세션-062: [종합 실습 3] 통계 분석기 추가 (집계 로직 구현)

### 브릿지 노트 예시
> "훌륭합니다! 데이터 뼈대(세션-060) 위에 개별 평가 로직(세션-061)까지 완벽하게 돌아가고 있습니다. 그런데 개별 학생 평가는 되는데, 반 전체의 1등이 누구인지, 전체 평균은 몇 점인지 알고 싶어지네요. 세션-062에서는 우리가 배운 내장 함수들을 총동원해서 강력한 '통계 분석기'를 프로그램에 부착해 보겠습니다."

## 📝 Gemini 프롬프트 최적화 태그
```yaml
gemini_optimized:
  chunk_type: lab
  complexity: high
  estimated_chars: 3800
  output_style: continuous_prose
  tone: friendly_spoken_korean
  include:
    - instructor_script: true
    - lab_guide: true
    - analogy: detailed_situation
    - mermaid_diagram: false
  prerequisites:
    mandatory: [060]
    recommended: []
```

## ✅ 체크리스트 (작성자 자가 검증)
- [x] 단 1개의 핵심 학습 목표만 명시했는가?
- [x] 소요 시간이 15~25분 범위인가?
- [x] 강사 대본 예상 분량이 1,500~2,000자 범위인가?
- [x] chunk_type, complexity 태그를 부여했는가?
- [x] 선행/후행 세션을 명확히 연결했는가?
- [x] 비유가 'AI 시대의 서사' 톤과 일치하는가?
