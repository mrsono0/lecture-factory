# 마이크로 세션: 098-파일 저장 모듈(FileStorage) 구현

## 📋 메타 정보
| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-AI-native_파이썬기초-098 |
| **소요 시간** | 25분 |
| **예상 교안 분량** | 4,000자 |
| **선행 세션** | 세션-097 (필수) |
| **후행 세션** | 세션-099 |
| **핵심 키워드** | JSON 파일, `FileStorage`, 모듈 분리, 추상화 |
| **난이도** | medium |
| **청크 타입** | code |

## 🎯 학습 목표
단 1개의 구체적인 학습 목표 (SMART 원칙 적용):
- 이 세션 종료 시 수강생은 파이썬의 `json` 모듈을 활용하여 고객 데이터를 파일로 영구 저장하고 불러오는 `FileStorage` 클래스를 별도의 모듈 파일로 구현할 수 있다.

## 🗣️ 강사 대본 구성

### 예상 분량
- **최소**: 공백 포함 1,500자
- **최대**: 공백 포함 2,000자
- **화법**: 친근한 구어체 (~해요, ~입니다)

### 서술 흐름
1. **도입 (Hook)**: "방금 우리는 DI 개념을 배우며 '타이어'를 따로 만들기로 결정했습니다. 그럼 우리의 첫 번째 타이어, '파일 저장 타이어'를 직접 만들어 볼까요?"
2. **비유 (Analogy)**: '서류함 전담 직원' 비유. 매니저(CustomerManager)가 직접 펜을 들고 서류를 작성하는 대신, 서류함 전담 직원(FileStorage)에게 "이 데이터 좀 파일로 써줘!"라고 서류 뭉치만 넘기는 상황을 묘사합니다.
3. **개념 설명 (What)**: `file_storage.py`라는 새로운 파이썬 파일을 만들고, 파이썬 내장 `json` 라이브러리를 사용해 딕셔너리 데이터를 텍스트 파일로 안전하게 변환해 주는 `FileStorage` 클래스를 정의합니다.
4. **실제 활용 (How)**: AI에게 "JSON 형식으로 데이터를 저장하는 `save()`와 불러오는 `load()` 메서드를 가진 FileStorage 클래스를 만들어줘"라고 지시합니다. 이 부품이 메인 코드와 완전히 독립적으로 동작한다는 것을 강조합니다.
5. **정리 (Checkpoint)**: 이제 프로그램이 꺼져도 데이터가 `customers.json` 파일에 영구적으로 살아있게 됨을 축하하고, 다음 세션에서 두 번째 타이어(DB)를 만들 것을 예고합니다.

### 예시 스크립트
> "자, 자동차 본체는 잠시 두고, 타이어 공장으로 이동해 봅시다. 파이썬에서 새 파일 `file_storage.py`를 하나 만드세요. 이게 우리의 첫 번째 타이어 공장입니다.
> 여기에 서류함 전담 직원을 한 명 채용할 겁니다. 이름은 `FileStorage` 클래스예요. 이 직원의 유일한 임무는 고객 데이터를 받아서 `customers.json`이라는 파일에 예쁘게 적어두고, 필요할 때 다시 읽어오는 겁니다. 
> 파이썬에는 딕셔너리를 텍스트로 예쁘게 바꿔주는 `json`이라는 마법의 도구가 기본으로 들어있어요. AI에게 이렇게 부탁해 봅시다. 'json을 써서 데이터를 파일로 저장하는 save 함수와 load 함수를 가진 FileStorage 클래스를 짜줘.' 이 직원은 오직 '파일 입출력'이라는 하나의 책임만 가지게 됩니다."

## 🎙️ 실습 가이드 (해당 시)

### 실습 목표
- 이 실습을 통해 수강생은 독립적인 파일 저장 모듈(클래스)을 생성하고 단일 책임 원칙(SRP)을 체험한다.

### 단계별 지시
| 단계 | 소요 시간 | 강사 지시사항 | 예상 결과 |
|------|----------|--------------|----------|
| 1 | 5분 | "새로운 파일 `file_storage.py`를 생성하고, AI에게 JSON 파일 저장/불러오기 기능이 있는 `FileStorage` 클래스를 만들어 달라고 요청하세요." | `save()`, `load()` 메서드를 가진 클래스 코드 출력 |
| 2 | 5분 | "생성된 코드를 `file_storage.py`에 붙여넣습니다. 코드 맨 위에 `import json`이 있는지 확인하세요." | 저장소 모듈 준비 완료 |
| 3 | 5분 | "이 파일 맨 아래에 테스트 코드를 살짝 넣어서, 임의의 데이터를 `FileStorage`를 통해 저장해 봅시다." | 폴더에 `customers.json` 파일이 실제로 생성됨 |
| 4 | 5분 | "생성된 `customers.json` 파일을 열어보세요. 여러분이 넣은 데이터가 글자로 잘 저장되어 있나요?" | 데이터 영속성(Persistence) 확인에 따른 성취감 |

### 주의사항 및 트러블슈팅
- 흔한 오류 1: 한글 데이터가 깨져서 저장되는 경우 (해결법: AI에게 "json 저장 시 한글이 안 깨지게 `ensure_ascii=False`를 넣어줘"라고 추가 지시하도록 안내합니다.)

## 💡 비유 및 스토리텔링

### 핵심 비유
- **비유**: 서류함 전담 직원
- **설명**: 영업 매니저(CustomerManager)는 고객 응대에만 집중하고, 서류를 창고(하드디스크)에 넣고 빼는 지루한 일은 서류 전담 직원(FileStorage)에게 완전히 맡깁니다.
- **AI 시대의 서사 연결**: "역할을 쪼개는 것(단일 책임 원칙)은 AI에게 일을 시킬 때도 매우 중요합니다. '고객도 관리하고 파일도 저장하는 만능 클래스를 짜줘'라고 하면 코드가 꼬이기 쉽지만, '파일 입출력 전용 클래스를 짜줘'라고 하면 AI가 훨씬 완벽한 코드를 만들어 냅니다."

### 스토리텔링 포인트
- 감정적 연결: 터미널 창에만 머물던 내 데이터가 실제로 눈에 보이는 `.json` 파일로 바탕화면에 생성될 때의 짜릿함을 강조합니다. "프로그램이 죽어도 내 데이터는 살아남았다!"
- 전환 멘트: "첫 번째 타이어를 성공적으로 깎았습니다! 그런데 만약 고객이 100만 명이라면 JSON 파일 하나로 버틸 수 있을까요? 좀 더 강력하고 튼튼한 '스노우 타이어'가 필요할 것 같습니다."

## 🔗 의존성 및 연결성

### 필수 선행 지식
- 세션-097: 의존성 주입(DI) 개념 (왜 이 클래스를 따로 만드는지에 대한 이유)

### 권장 선행 지식
- 없음

### 후속 연결
- 세션-099: DB 저장 모듈(SQLiteStorage) 구현

### 브릿지 노트 예시
> "JSON 파일 저장은 쉽고 빠르지만, 데이터가 수십만 건으로 늘어나면 파일 전체를 덮어써야 해서 매우 느려집니다. 그래서 실무에서는 보통 데이터베이스(DB)를 쓰죠. 세션 99에서는 우리의 두 번째 타이어, 'DB 저장 모듈'을 만들어 보겠습니다. 규격(save, load)은 똑같지만 내부는 훨씬 튼튼한 놈으로요!"

## 📝 Gemini 프롬프트 최적화 태그
```yaml
gemini_optimized:
  chunk_type: code
  complexity: medium
  estimated_chars: 4000
  output_style: continuous_prose
  tone: friendly_spoken_korean
  include:
    - instructor_script: true
    - lab_guide: true
    - analogy: detailed_situation
    - mermaid_diagram: false
  prerequisites:
    mandatory: [97]
    recommended: []
```


## 📚 참고자료 매핑

| 참고자료 | 관련 섹션 | 활용 방법 |
|----------|----------|----------|
| 8 코딩.pdf | §8.14 데이터 영속화 (파일/DB) | JSON/SQLite 저장 모듈 구현 |

## ✅ 체크리스트 (작성자 자가 검증)
- [x] 단 1개의 핵심 학습 목표만 명시했는가?
- [x] 소요 시간이 15~25분 범위인가?
- [x] 강사 대본 예상 분량이 1,500~2,000자 범위인가?
- [x] chunk_type, complexity 태그를 부여했는가?
- [x] 선행/후행 세션을 명확히 연결했는가?
- [x] 비유가 'AI 시대의 서사' 톤과 일치하는가?
