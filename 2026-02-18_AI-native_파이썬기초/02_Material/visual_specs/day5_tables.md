# Day 5: AI-Native 파이썬 기초 시각화 명세서

## 1. 객체지향 프로그래밍(OOP) 핵심 개념 요약

- **추천 위치**: 오전 세션 (Day5_AM_클래스_OOP_리팩토링_v3)
- **강사 설명 포인트**: 붕어빵 틀 비유와 함께, 데이터(상태)와 기능(행동)을 하나로 묶는 패러다임임을 강조.

| 개념어 | 비유 / 의미 | 구현 예시 | 강사 설명 팁 |
|:---|:---|:---|:---|
| **클래스 (Class)** | 붕어빵 틀, 설계도 | `class Customer:` | 여러 고객을 찍어내는 원본 문서 (추상적) |
| **객체/인스턴스 (Object/Instance)** | 팥 붕어빵, 실체 | `c1 = Customer("홍길동")` | 메모리에 생성되어 동작하는 구체적 데이터 (실제 데이터 포함) |
| **속성 (Attribute/Property)** | 붕어빵의 속(팥/슈크림), 상태 | `self.name`, `self.phone` | 클래스가 기억(저장)해야 하는 데이터 변수 |
| **메서드 (Method)** | 붕어빵이 하는 행동(구워짐), 기능 | `def update_phone(self, new_num):` | 클래스 내부에서 동작하는 전용 함수 (행동) |

---

## 2. 일반 Class vs Dataclass 비교

- **추천 위치**: 오전 세션 (Day5_AM_클래스_OOP_리팩토링_v3)
- **강사 설명 포인트**: 왜 최신 파이썬 트렌드에서는 `dataclass`를 선호하는지, 코드량이 어떻게 줄어드는지 보여줌. AI에게 최신 문법을 써달라고 지시할 때 유용한 지식.

| 구분 | 일반 파이썬 클래스 | 데이터클래스 (`@dataclass`) |
|:---|:---|:---|
| **초기화 메서드** | `__init__`을 수동으로 긴 코드로 작성해야 함 | 타이핑된 변수만 선언하면 자동 생성 |
| **출력 (print)** | `<__main__.Customer object at 0x...>` 형태로 나옴 | `Customer(name='홍길동', phone='010-...')` 형태로 예쁘게 나옴 (`__repr__` 자동 제공) |
| **비교 (==)** | 메모리 주소가 다르면 다르다고 판단 | 내부 데이터 값이 같으면 같다고 판단 (`__eq__` 자동 제공) |
| **타입 힌트** | 선택사항이지만 강제되지 않음 | 필수사항 (`name: str`) |
| **장점** | 세밀한 제어가 가능 | 코드가 간결해지고, 데이터 구조체가 명확히 보임 |

---

## 3. 상속(Inheritance)의 목적과 이점

- **추천 위치**: 오후 세션 (Day5_PM_상속_DI_전체회고)
- **강사 설명 포인트**: 중복을 제거하고, 공통된 기능을 재사용하면서도 세부 기능만 변경(오버라이딩)할 수 있는 강력함을 설명. "VIP 회원"과 "일반 회원"의 차이점으로 비유.

| 구분 | 부모 클래스 (Super class) | 자식 클래스 (Sub class) |
|:---|:---|:---|
| **역할** | 공통된 속성과 기능을 제공 (예: 일반 고객) | 부모의 기능을 물려받으면서 특화된 기능 추가 (예: VIP 고객) |
| **구현 방법** | `class Customer:` | `class VIPCustomer(Customer):` |
| **오버라이딩 (Overriding)** | 자식 클래스가 부모의 메서드를 가져와 자신의 입맛에 맞게 재정의(수정)하는 것 |
| **장점** | 공통 로직(예: 할인율 계산 기본 로직)을 부모에 한 번만 작성하면 모든 자식에게 적용됨 |

---

## 4. 의존성 주입(DI, Dependency Injection)의 장점

- **추천 위치**: 오후 세션 (Day5_PM_상속_DI_전체회고)
- **강사 설명 포인트**: DI라는 용어가 어렵지만, 사실은 레고 블록을 갈아끼우는 개념임을 강조 (파일 저장 방식에서 DB 저장 방식으로 변경 등).

| 특징 | DI 사용 안 함 (강한 결합) | DI 사용 (느슨한 결합) |
|:---|:---|:---|
| **객체 생성 주체** | 내가 직접 생성 (`storage = FileStorage()`) | 외부에서 만들어져서 들어옴 (`def __init__(self, storage):`) |
| **부품 교체** | 코드 내부를 직접 뜯어 고쳐야 함 | 코드 수정 없이, 외부에서 다른 부품(DBStorage)을 주입하면 됨 |
| **유닛 테스트** | 가짜 부품(Mock)을 끼우기 어려워 테스트가 힘듦 | 테스트용 가짜 부품(Mock Storage)을 주입하기 매우 쉬움 |
| **실생활 비유** | 벽에 내장된 배터리를 쓰는 무선 청소기 (배터리 고장 시 본체 뜯어야 함) | 교체형 배터리를 쓰는 드릴 (배터리만 다른 용량으로 갈아끼우면 됨) |

---

## 5. 고객관리 프로그램 진화 단계 (v1 ~ v4) 총정리

- **추천 위치**: 오후 세션 (Day5_PM_상속_DI_전체회고 - 과정 회고)
- **강사 설명 포인트**: 4일에 걸친 여정이 하나의 프로그램을 점진적으로 리팩토링하는 과정이었음을 상기시키며 마무리.

| 버전 | 패러다임 | 핵심 특징 | AI-Native 개발 관점 |
|:---|:---|:---|:---|
| **v1** | 절차적(Procedural) | 모든 코드가 위에서 아래로 순차 실행, 단일 파일 (스파게티 조짐) | 프롬프트로 한 번에 찍어낸 기초적 코드 수준 |
| **v2** | 구조적(Structural) | 함수(def)를 통해 기능을 분리하고 재사용, 책임 소재를 분리 시작 | 함수의 입력과 출력(I/O)을 명확히 정의하여 AI에게 리팩토링 요청 |
| **v3** | 객체지향(OOP) | 데이터(`dataclass`)와 기능(`class`)을 캡슐화, 명확한 객체 단위 협력 | 도메인 모델(Customer, Manager)을 AI에게 설계해 달라고 요청 |
| **v4** | 의존성 주입(DI) + 상속 | 파일 저장소, 메모리 저장소 등 모듈 교체가 쉬운 플러그인 구조 완성 | 인터페이스(Protocol/ABC)를 정의하고 다형성을 활용하는 고급 구조 구현 |

