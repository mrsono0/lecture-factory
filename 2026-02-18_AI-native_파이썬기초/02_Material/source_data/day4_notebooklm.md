# Day 4 NotebookLM 데이터 (세션 065-085)
> Source: NotebookLM notebook/28d70970-864a-485b-82e9-ebdd7c233c9a
> Collected: 2026-02-25
> Query: Day 4 핵심 교육 콘텐츠 (절차적 프로그래밍, 구조적 프로그래밍, CRUD, 전역변수 한계, 리팩토링, 테스트, 코드 리뷰)

---

## 1. 절차적 프로그래밍의 개념

### 정의
코드가 기능의 분리 없이 위에서 아래로, 작성된 순서대로 순차적으로 실행되는 프로그래밍 패러다임[1][2]

### 핵심 개념
- 컴퓨터가 '어떻게' 작업을 수행해야 하는지 절차에 집중
- 초기 단계에서는 직관적이지만, 프로그램이 커질수록 GOTO문이나 무한 루프 내에서 코드의 흐름이 얽히고설키는 '스파게티 코드'가 발생하기 쉬움[1][3]

### 실습 예시
고객 정보를 관리할 때 `while True:` 루프 하나 안에 데이터 입력, 출력, 검증 로직이 모두 한 덩어리로 섞여 있는 형태[4][5]

---

## 2. 구조적 프로그래밍으로의 여정

### 정의
절차적 프로그래밍의 한계(스파게티 코드)를 극복하기 위해, 반복되거나 독립적인 논리를 '함수(Function)'라는 블록으로 묶어 재사용하고 구조화하는 방식[1][6]

### 핵심 개념
- GOTO문의 사용을 지양하고 순차, 선택(조건문), 반복(루프)의 세 가지 구조만으로 프로그램을 논리적으로 전개
- 코드를 상자(함수)에 담아 용도별로 분류하므로 마치 '잘 정리된 서랍장'처럼 코드를 관리[1][7]

### 실습 예시
고객 정보 관리 프로그램에서 중복으로 사용되는 출력 로직 등을 `add_customer()`, `search_customer()` 등의 독립된 함수로 분리하여 메인 로직을 단순화[2][4]

---

## 3. CRUD 개념과 구현

### 정의
소프트웨어 시스템의 가장 기본적인 데이터 처리 기능인 생성(Create), 읽기(Read), 수정(Update), 삭제(Delete)[8]

### 핵심 개념
사용자의 요구사항(스펙)을 실제 시스템의 기능으로 매핑할 때 주로 사용되는 기준

### 실습 예시
고객 정보 관리 시스템에서의 매핑:
- **C (등록)**: `register_customer()` — 이름, 전화번호, 이메일 입력 및 저장[8]
- **R (조회)**: `show_all_customers()`, `search_by_name()`[8]
- **U (수정)**: `update_customer()` — 기존 고객 정보 변경[8]
- **D (삭제)**: `delete_customer()` — 고객 정보 삭제 및 확인 절차[8]

---

## 4. 전역 변수와 코드 중복의 한계

### 정의
프로그램 전체에서 공유되는 전역 변수의 남용과, 복사-붙여넣기로 인해 동일한 로직이 여러 곳에 존재하는 코드 중복의 문제점

### 핵심 개념
- 비슷한 출력 코드가 여러 곳에 반복될 경우, 출력 형식을 하나 수정하기 위해 코드의 10곳, 100곳을 전부 찾아 고쳐야 하는 유지보수의 악몽 발생[4][6]
- 함수 내부의 독립적인 스코프(지역 변수)를 활용하지 않으면 데이터가 의도치 않게 변경될 위험이 큼[9]

### 실습 예시
10번 등장하는 고객 정보 `print()` 문을 하나의 `print_customer_info()` 함수로 묶어 코드 중복을 제거[4][6]

---

## 5. 구조적 리팩토링과 데이터 흐름 (매개변수/리턴)

### 정의
겉으로 보이는 프로그램의 동작은 바꾸지 않으면서 내부 코드를 함수와 적절한 자료구조를 활용해 깔끔하게 재설계하는 과정[4][6]

### 핵심 개념
- 함수 간의 데이터 흐름은 **매개변수(Parameter)**를 통해 함수 내부로 입력되고, **반환값(Return)**을 통해 호출한 곳으로 출력
- 단순한 `print()`는 화면에 보여주고 끝이지만, `return`을 사용하면 결괏값을 변수에 저장해 재사용하거나 테스트 가능[9][10]

### 실습 예시
할인 계산기를 만들 때 `def calculate_discount(price, rate):`처럼 원가와 할인율을 매개변수로 받고, 계산된 할인가를 `return`하도록 리팩토링[11]

---

## 6. 절차적 vs 구조적 코드 비교

### 정의
기능 분리 없이 변수가 흩어져 있는 코드와 데이터와 기능이 체계적으로 분리된 코드를 대조[4]

### 핵심 개념
- **절차적 (Before)**: 데이터가 `name1`, `phone1`처럼 개별 변수로 흩어져 있고, 모든 로직이 하나의 큰 `while` 루프 안에 덩어리져 있어 흐름 파악이 어려움[4]
- **구조적 (After)**: 데이터는 `[{"name": "철수", "phone": "010..."}]` 형태의 리스트 안의 딕셔너리로 묶이고, 로직은 `add_customer`처럼 역할 단위로 분리되어 함수명만 봐도 전체 흐름을 파악 가능[4][12]

### 실습 예시
Day 2에 짠 하나의 거대한 코드를 Day 3에서 함수와 딕셔너리를 활용해 재조립하며 가독성과 유지보수성이 어떻게 높아지는지 확인[4]

---

## 7. 테스트 시나리오 3분류

### 정의
AI가 생성한 코드나 직접 작성한 코드가 스펙대로 동작하는지 검증하기 위해 미리 설계하는 테스트 케이스의 3가지 기준[13]

### 핵심 개념
- **정상 케이스**: 올바른 입력이 주어졌을 때 기대하는 기본 기능이 수행되는지 검증 (예: 85점 입력 시 "B" 반환)[13]
- **경계값 케이스**: 범위의 끝값을 테스트하여 조건문(>= vs >)의 실수를 방지 (예: 정확히 90점을 입력하여 "A"가 나오는지 확인)[13]
- **예외 케이스**: 유효하지 않은 잘못된 입력이 들어왔을 때의 오류 처리 검증 (예: 점수에 -1이나 문자열을 넣었을 때 "INVALID" 반환 여부)[13][14]

### 실습 예시
요구사항 명세서를 읽고 코드를 작성하기 전에, 원가 10000원(정상), 0원(경계값), -100원(예외) 등의 케이스를 표로 먼저 작성[14]

---

## 8. 코드 리뷰 5대 체크포인트

### 정의
AI(codex)가 생성한 코드를 무비판적으로 수용하지 않고, 비판적인 시각으로 평가하고 결함을 찾아내기 위한 체계적인 기준[15][16]

### 핵심 개념 및 실습 예시
1. **요구사항 충족**: 스펙에 명시된 기능이 모두 구현되었는가? (누락된 기능 확인)[16]
2. **입력 검증**: 잘못된 타입이나 빈 값이 들어오는 것을 방어하는가? (예: 빈 리스트 `[]` 입력 시 `ZeroDivisionError`가 발생하지 않는지 방어 코드 확인)[16]
3. **경계값 처리**: 범위의 끝값이 올바르게 처리되는가? (예: "평균 점수 이상"이라는 스펙에 맞게 `>`가 아닌 `>=`를 사용했는지 검토)[16]
4. **자료구조 적절성**: 상황에 맞게 list와 dict가 올바르게 선택되었는가? (예: 잦은 검색이 필요한 경우 딕셔너리 권장)[16][17]
5. **가독성/구조**: 함수와 변수명이 역할을 명확히 설명하며 불필요한 중복은 없는가?[16][17]
