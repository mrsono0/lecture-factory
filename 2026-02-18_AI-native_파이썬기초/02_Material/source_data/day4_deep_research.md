# Day 4 교수 콘텐츠 리서치 패킷
## 절차적 → 구조적 프로그래밍 진화 & 고객 관리 CRUD
*Sessions: 065-085 | 핵심 프로젝트: 고객 관리 프로그램*

---

## 1. 절차적 → 구조적 프로그래밍 진화

### 1.1 핵심 비교

| 구분 | 절차적 프로그래밍 | 구조적 프로그래밍 |
|------|-----------------|-----------------|
| 정의 | 순차 실행, 전역 변수 공유 | 함수·모듈로 책임 분리, 매개변수/리턴 |
| 역사 | 1950–60년대 | 1968 Dijkstra "GOTO Considered Harmful" |
| 제어 구조 | GOTO, 전역 점프 | 순차+선택+반복 3가지만 |
| 데이터 흐름 | 전역 변수 (암묵적) | 매개변수→함수→리턴값 (명시적) |

**Böhm-Jacopini 정리 (1966)**: 어떤 프로그램도 순차·선택·반복 세 가지만으로 표현 가능.

### 1.2 절차적 코드의 3대 문제점

1. **전역 상태 오염**: 어디서든 변경 가능 → 버그 추적 불가
2. **코드 중복**: 검증 로직이 여러 곳에 복사
3. **테스트 불가**: 함수가 없으니 단위 테스트 작성 불가

### 1.3 데이터 흐름 다이어그램

```
【절차적】 전역 변수 ←→ 코드 블록 (누가 언제 바꿨는지 추적 불가)
【구조적】 입력(매개변수) → [함수: 처리] → 출력(리턴값) (명시적)
```

### 1.4 교수법: 나란히 비교

1. "작동하는 나쁜 코드" 먼저 실행
2. 문제 상황 연출 → 고통 체험
3. AI에게 리팩토링 요청 → 비교

---

## 2. Python CRUD 구현

### 2.1 데이터 저장 구조 진화 3단계

```python
# 단계 1: 전역 리스트 (위험)
customers = ["홍길동", "김철수"]

# 단계 2: 딕셔너리 리스트 (구조화)
customers = [{"id": 1, "name": "홍길동", "phone": "010-1234-5678"}]

# 단계 3: 함수 기반 CRUD (구조적)
def create_customer(customers, name, phone, email): ...
def read_customers(customers, search=""): ...
def update_customer(customers, customer_id, **kwargs): ...
def delete_customer(customers, customer_id): ...
```

### 2.2 AI-First 구현 접근법

```
1단계: "함수 없이 절차적으로 작성해줘"
2단계: "문제점을 분석해줘"
3단계: "구조적 프로그래밍으로 리팩토링해줘"
```

---

## 3. 초보자를 위한 테스트 방법론

### 3.1 핵심 비유: "테스트는 시승이다" 🚗

- **정상 주행**: 일반 입력으로 잘 작동 (정상 케이스)
- **경계 상황**: 급브레이크, 급커브 (경계값)
- **예외 상황**: 연료 없음, 타이어 펑크 (예외 상황)

### 3.2 3가지 테스트 시나리오 유형

| 유형 | 고객 관리 예시 |
|------|--------------|
| 정상 케이스 | 이름/전화/이메일 모두 입력 → 성공 |
| 경계값 | 이름 1글자, ID=0, ID=999 |
| 예외 상황 | 빈 이름, 잘못된 이메일, 없는 ID |

### 3.3 Test-Think-Fix 사이클

```
1. TEST → 테스트 실행
2. THINK → 실패 분석 ("왜 실패?")
3. FIX → 코드 수정
4. TEST → 다시 실행 → 반복
```

---

## 4. 코드 리뷰 방법론

### 4.1 5대 체크포인트

| # | 체크포인트 | 핵심 질문 |
|---|----------|----------|
| 1 | 가독성 | 처음 보는 사람이 5분 안에 이해? |
| 2 | 유지보수성 | 요구사항 변경 시 수정 범위 최소? |
| 3 | 에러 처리 | 잘못된 입력에 프로그램 안 죽음? |
| 4 | 성능 | 불필요한 반복/중복 연산 없음? |
| 5 | 보안 | 민감 정보 노출/입력값 검증? |

### 4.2 효과적인 리뷰 코멘트

```
❌ "이 코드 별로예요"
✅ "[에러처리] int(input()) 호출 시 사용자가 문자를 입력하면 ValueError.
   try-except로 감싸는 것을 권장합니다."
```

규칙: **문제 + 이유 + 제안** 3요소

### 4.3 AI를 코드 리뷰어로 활용

```
"다음 Python 코드를 시니어 개발자 관점에서 리뷰해줘.
5가지 측면에서 분석: 가독성, 유지보수성, 에러처리, 성능, 보안."
```

---

## 5. AI를 활용한 구조적 리팩토링

### 5.1 Before/After 비교

| 항목 | Before (절차적) | After (구조적) |
|------|----------------|---------------|
| 전역 변수 | `customers`, `next_id` 전역 | 함수 매개변수로 전달 |
| 데이터 흐름 | 암묵적 | 명시적 (매개변수 → 리턴) |
| 테스트 가능성 | ❌ | ✅ |
| 재사용성 | ❌ | ✅ |
| 에러 처리 | ❌ | ✅ None 반환 |

---

## 6. 미니 프로젝트 방법론

### 6.1 Day 4 종합 프로젝트 플로우 (~3시간)

```
Phase 1: 기획 (30분) — 요구사항, 기능 목록, 데이터 구조
Phase 2: 절차적 코드 생성 (30분) — AI 생성 → 실행 → 문제점 목록
Phase 3: 구조적 리팩토링 (45분) — AI 리팩토링 → Before/After
Phase 4: 테스트 (30분) — 정상/경계/예외 시나리오
Phase 5: 코드 리뷰 (30분) — AI 리뷰 + 코멘트 작성
Phase 6: 최종 완성 (15분) — 정리 + README + 발표
```

### 6.2 평가 루브릭

| 평가 항목 | 배점 |
|----------|------|
| 기능 완성도 | 30점 |
| 구조적 설계 | 25점 |
| 에러 처리 | 20점 |
| 코드 가독성 | 15점 |
| 테스트 시나리오 | 10점 |

---

## 세션별 배분 (65-85)

```
세션 65-67: 절차적 프로그래밍 특징과 한계
세션 68-70: 구조적 프로그래밍 개념 (Böhm-Jacopini)
세션 71-73: 함수 분리 실습 (라이브 리팩토링)
세션 74-76: CRUD 구현 (완전한 앱)
세션 77-78: 테스트 방법론 (시승 비유, 3분류)
세션 79-80: 테스트 실습
세션 81-82: 코드 리뷰 방법론 (5대 체크포인트)
세션 83: AI 코드 리뷰 실습
세션 84-85: 미니 프로젝트 (기획→코드→테스트→리뷰→완성)
```

**핵심 교육 프레임 3가지**:
1. "작동하는 나쁜 코드" → 고통 체험 → 리팩토링 동기 부여
2. "테스트는 시승이다" → 정상/경계/예외 3분류
3. "리뷰 코멘트 = 문제 + 이유 + 제안"

*리포트 작성: 2026-02-25*
