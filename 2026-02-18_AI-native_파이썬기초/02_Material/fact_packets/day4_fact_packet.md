# Day 4 팩트 패킷 (세션 065-085)
> 3-Source Mandatory | Source A: 로컬 참고자료 | Source B: NotebookLM | Source C: Deep Research

## 세션별 교육 콘텐츠

### 세션 065: 절차적 프로그래밍의 개념과 특징
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.9 절차적 프로그래밍 패턴), [Source B] NotebookLM (§1), [Source C] Deep Research (§1.1, 1.2)
* **정의**: 코드가 기능 분리 없이 위에서 아래로 순차적으로 실행되며, 전역 변수를 공유하는 프로그래밍 패러다임.
* **핵심 개념**: 
  - 컴퓨터가 '어떻게' 작업을 수행해야 하는지 절차에 집중함 [Source B].
  - 전역 상태 오염, 코드 중복, 단위 테스트 불가라는 3대 문제점을 내재함 [Source C].
* **실습 예시**:
  ```python
  # 절차적 방식의 단면
  name1 = "홍길동"
  phone1 = "010-1234-5678"
  print(f"고객 추가: {name1}, {phone1}")
  # 다른 곳에서 또 비슷한 출력
  name2 = "김철수"
  phone2 = "010-9876-5432"
  print(f"고객 추가: {name2}, {phone2}")
  ```
* **🗣️ 강사 스크립트 포인트**: "여러분, 코드가 위에서 아래로 그냥 쭉 실행되는 걸 절차적이라고 해요. 처음엔 쉽고 직관적이지만, 기능이 많아지면 어떻게 될까요? 수정할 때마다 10군데, 100군데를 다 고쳐야 하는 악몽이 시작됩니다."

### 세션 066: AI 시대의 서사 복습: 구조적 프로그래밍으로의 여정
* **📚 참고자료 매핑**: [Source A] AI 시대의 서사 v3 - Claude.md (§구조적 프로그래밍으로의 여정), [Source B] NotebookLM (§2), [Source C] Deep Research (§1.1)
* **정의**: 스파게티 코드를 해결하기 위해 GOTO문을 지양하고, 순차, 선택, 반복 3가지 구조만 사용하여 프로그램을 통제하는 패러다임 [Source B, C].
* **핵심 개념**:
  - Böhm-Jacopini 정리(1966): 모든 프로그램은 순차, 선택, 반복만으로 표현 가능 [Source C].
  - 함수라는 상자에 코드를 담아 용도별로 분류, 잘 정리된 서랍장처럼 코드를 관리 [Source B].
* **실습 예시**: GOTO문으로 얽힌 스파게티 코드를 while과 if로 깔끔하게 정리하는 개념적 비교.
* **🗣️ 강사 스크립트 포인트**: "GOTO문이 많았던 옛날 코드는 마치 엉킨 이어폰 줄 같았어요. 구조적 프로그래밍은 이 이어폰 줄을 풀어서 예쁘게 감아두는 겁니다. 순차, 선택, 반복. 딱 3가지만 기억하세요!"

### 세션 067: 고객 정보 관리 프로그램 PRD 복습 및 설계
* **📚 참고자료 매핑**: [Source A] 7 기획.pdf (§7.3 PRD 구조), [Source C] Deep Research (§2, 6.1)
* **정의**: Day 2-3에서 다룬 요구사항 정의서(PRD)를 바탕으로, 본격적인 CRUD 앱 개발을 위한 데이터 및 기능 설계 [Source A].
* **핵심 개념**:
  - 사용자 요구사항을 시스템의 기능으로 매핑.
  - 고객 데이터(이름, 전화번호, 이메일)를 어떻게 메모리에 들고 있을 것인가에 대한 고민 시작 [Source C].
* **실습 예시**: 요구사항(FR-01: 고객 등록, FR-02: 고객 조회)을 표로 재정리.
* **🗣️ 강사 스크립트 포인트**: "우리가 만들 고객 관리 프로그램의 설계도를 다시 펴봅시다. 어떤 기능이 필요한지 명세서에 다 적혀있죠? 이제 이걸 실제 코드로 옮길 차례입니다."

### 세션 068: CRUD 개념 이해 및 1차 프롬프트 작성 실습
* **📚 참고자료 매핑**: [Source B] NotebookLM (§3), [Source C] Deep Research (§2.2)
* **정의**: 시스템의 기본 데이터 처리 기능인 생성(Create), 읽기(Read), 수정(Update), 삭제(Delete) [Source B].
* **핵심 개념**:
  - 모든 소프트웨어 시스템(게시판, 쇼핑몰, 고객관리)의 뼈대가 되는 개념.
  - AI에게 명확하게 CRUD 기능 구현을 지시하는 프롬프트 엔지니어링 [Source C].
* **실습 예시**: AI에게 전달할 프롬프트 구조화. "고객 정보를 관리하는 프로그램을 절차적으로 작성해줘. C, R, U, D 기능을 메뉴로 선택할 수 있게 해줘."
* **🗣️ 강사 스크립트 포인트**: "웹 서비스든 앱이든 본질은 결국 CRUD입니다. 고객을 만들고(Create), 보고(Read), 고치고(Update), 지우는(Delete) 거죠. 이걸 AI에게 어떻게 잘 지시할지 프롬프트를 써봅시다."

### 세션 069: 데이터 저장 구조(전역 리스트, 딕셔너리) 이해
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.9 절차적 프로그래밍 패턴), [Source B] NotebookLM (§6), [Source C] Deep Research (§2.1)
* **정의**: 고객 데이터를 흩어진 변수가 아닌, 하나의 구조체(딕셔너리를 담은 리스트)로 관리하는 방법 [Source B, C].
* **핵심 개념**:
  - 전역 리스트의 위험성과 데이터 구조화의 필요성 [Source C].
  - 딕셔너리로 속성(이름, 번호)을 묶고, 리스트로 딕셔너리를 모음.
* **실습 예시**:
  ```python
  # 파편화된 데이터 (Bad)
  names = ["홍길동", "김철수"]
  phones = ["010-1111", "010-2222"]
  
  # 구조화된 데이터 (Good)
  customers = [
      {"id": 1, "name": "홍길동", "phone": "010-1111"},
      {"id": 2, "name": "김철수", "phone": "010-2222"}
  ]
  ```
* **🗣️ 강사 스크립트 포인트**: "이름과 전화번호를 따로 관리하면 실수로 홍길동의 전화번호 자리에 김철수의 번호가 섞일 수 있습니다. 데이터를 하나의 딕셔너리 꾸러미로 묶어서 관리해야 안전합니다."

### 세션 070: 절차적 Create, Read 기능 구현 및 테스트
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.9 절차적 프로그래밍 패턴), [Source B] NotebookLM (§3), [Source C] Deep Research (§1.4)
* **정의**: while 루프 안에서 if문을 통해 Create(등록)와 Read(조회)를 절차적으로 구현 [Source B].
* **핵심 개념**:
  - 작동은 하지만 모든 로직이 한 덩어리에 뭉쳐 있는 '작동하는 나쁜 코드' 체험 [Source C].
* **실습 예시**:
  ```python
  # 절차적 Create & Read (메인 루프 안에서)
  while True:
      menu = input("1.등록 2.조회: ")
      if menu == '1':
          name = input("이름: ")
          customers.append({"name": name})
          print("등록 완료")
      elif menu == '2':
          for c in customers:
              print(f"고객이름: {c['name']}")
  ```
* **🗣️ 강사 스크립트 포인트**: "AI가 짜준 코드를 실행해 볼까요? 네, 등록도 되고 조회도 잘 됩니다. 하지만 이 거대한 루프 안에 코드가 계속 쌓이면 어떨까요? 점점 읽기가 힘들어질 겁니다."

### 세션 071: 절차적 Update, Delete 기능 구현 및 통합 테스트
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.9), [Source B] NotebookLM (§3)
* **정의**: 동일한 while 루프 안에 Update(수정)와 Delete(삭제) 로직을 마저 추가하여 완전한 절차적 CRUD 완성 [Source B].
* **핵심 개념**:
  - 수정과 삭제 로직을 추가하면서 발생하는 급격한 코드 팽창과 중복 확인.
  - 검색 로직이 Read, Update, Delete에 모두 중복 등장하는 문제 발생.
* **실습 예시**: Read 부분의 검색 로직을 복사해서 Update와 Delete에 붙여넣기하는 상황 연출.
* **🗣️ 강사 스크립트 포인트**: "수정과 삭제를 추가했더니 코드가 100줄이 넘어갔습니다! 특히 고객 이름을 찾는 코드가 조회, 수정, 삭제 세 군데나 복사/붙여넣기 되어있네요. 이게 바로 유지보수의 늪입니다."

### 세션 072: 코드 리뷰: 전역 변수와 코드 중복의 한계점 발견
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.12 코드 리뷰), [Source B] NotebookLM (§4), [Source C] Deep Research (§1.2)
* **정의**: 절차적으로 작성된 CRUD 코드의 구조적 결함(전역 변수 오염, 코드 중복)을 비판적으로 분석하는 과정 [Source B].
* **핵심 개념**:
  - 절차적 코드의 3대 문제: 전역 상태 오염, 중복, 테스트 불가 [Source C].
  - "출력 형식을 바꾼다면 코드를 몇 군데 수정해야 하는가?"라는 질문으로 고통 체험.
* **실습 예시**: 출력 형식을 `이름: 홍길동`에서 `[고객명] 홍길동`으로 변경할 때 여러 곳을 수정하다가 누락하는 실수 연출.
* **🗣️ 강사 스크립트 포인트**: "출력 양식을 조금 바꿨을 뿐인데, 빼먹은 곳에서 에러가 나죠? 함수가 없기 때문에 단위 테스트도 할 수가 없습니다. 이 코드, 이대로 둬서는 안 됩니다."

### 세션 073: 절차적 코드의 구조적 리팩토링 프롬프트 작성
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.10 리팩토링), [Source B] NotebookLM (§5), [Source C] Deep Research (§2.2, 5.1)
* **정의**: 겉동작은 유지하면서 내부를 깔끔하게(함수로 분리) 재설계하도록 AI에게 지시하는 과정 [Source B].
* **핵심 개념**:
  - AI를 활용한 구조적 리팩토링 접근법 (절차적 → 문제 분석 → 구조적) [Source C].
* **실습 예시**: AI 프롬프트 작성 - "기존 절차적 CRUD 코드를 구조적 프로그래밍 패러다임에 맞게 리팩토링해줘. 각 기능(C, R, U, D)을 독립된 함수로 분리하고, 전역 변수 사용을 최소화해줘."
* **🗣️ 강사 스크립트 포인트**: "이제 이 엉망인 코드를 AI에게 고쳐달라고 해보겠습니다. '기능별로 함수를 나눠서 구조적으로 바꿔줘!'라고 명확히 지시해보세요."

### 세션 074: 구조적 데이터 흐름(매개변수와 리턴)의 이해
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.10), [Source B] NotebookLM (§5), [Source C] Deep Research (§1.1, 1.3)
* **정의**: 함수 내부의 독립적 스코프를 활용하고, 매개변수(입력)와 반환값(출력)으로 데이터 흐름을 명시적으로 만드는 원리 [Source B].
* **핵심 개념**:
  - 전역 변수의 암묵적 변경(Side-effect) 방지 [Source C].
  - 단순 print()와 return의 결정적 차이 이해 [Source B].
* **실습 예시**:
  ```python
  # 전역 변수 의존 (Bad)
  def calculate_discount():
      global price, rate
      print(price * rate)
  
  # 명시적 데이터 흐름 (Good)
  def calculate_discount(price, rate):
      return price * rate
  ```
* **🗣️ 강사 스크립트 포인트**: "함수에 데이터를 넘겨줄 때는 '매개변수'라는 출입문을 이용하고, 결과를 받을 때는 '리턴'이라는 출구를 이용해야 합니다. 전역 변수를 쓰면 벽을 뚫고 물건을 던지는 것과 같아서 사고가 납니다!"

### 세션 075: 절차적 vs 구조적 코드 나란히 비교 분석
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.11 코드 비교), [Source B] NotebookLM (§6), [Source C] Deep Research (§5.1)
* **정의**: 리팩토링 전의 뭉쳐있는 코드와 리팩토링 후의 함수로 분리된 코드를 대조하여 개선점을 확인하는 과정 [Source B].
* **핵심 개념**:
  - Before: 파편화된 변수, 거대한 while 루프.
  - After: 딕셔너리 리스트, 역할 단위 함수 분리, 명시적 데이터 흐름.
* **실습 예시**: IDE 분할 화면에 두 코드를 띄워두고 가독성, 재사용성, 에러 처리 가능성 비교 [Source C].
* **🗣️ 강사 스크립트 포인트**: "왼쪽과 오른쪽 코드를 비교해보세요. 왼쪽은 위에서부터 한 줄씩 다 읽어야 흐름이 보이지만, 오른쪽은 함수 이름들(create, read)만 봐도 이 프로그램이 무슨 일을 하는지 한눈에 보이지 않나요?"

### 세션 076: 요구사항 추가를 통한 구조적 확장성 체험
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.10), [Source C] Deep Research (§5.1)
* **정의**: 리팩토링된 구조적 코드에 새로운 기능을 추가해보며, 왜 구조화가 유지보수와 확장에 유리한지 직접 체감하는 실습.
* **핵심 개념**:
  - 요구사항 변경 시 수정 범위의 최소화.
  - 기존 함수 재사용을 통한 생산성 향상.
* **실습 예시**: "고객 정보에 '등급' 필드 추가" 요구사항 대응. 절차적 코드에서는 모든 출력/입력 부분을 고쳐야 했으나, 구조적 코드에서는 해당 함수만 수정.
* **🗣️ 강사 스크립트 포인트**: "만약 지금 'VIP 고객 여부'를 추가해 달라는 요청이 오면 어떻게 될까요? 절차적 코드였다면 야근 확정이지만, 구조적으로 잘 나뉜 코드에서는 담당 함수 딱 하나만 고치면 퇴근할 수 있습니다."

### 세션 077: 테스트는 시승이다: 테스트 시나리오 3분류 이해
* **📚 참고자료 매핑**: [Source A] 9 디 버깅, 테스트, 배포.pdf (§9.3.1), [Source B] NotebookLM (§7), [Source C] Deep Research (§3.1, 3.2)
* **정의**: 코드가 의도대로 작동하는지 검증하기 위한 정상, 경계값, 예외 3가지 기준의 시나리오 작성법 [Source B].
* **핵심 개념**:
  - 정상(Normal): 일반적인 입력 [Source B].
  - 경계값(Boundary): 조건의 끝값 (>= 에서 == 에 해당하는 값) [Source C].
  - 예외(Exception): 잘못된 타입, 유효하지 않은 값 입력 시 방어 확인 [Source A, B].
* **실습 예시**: 자동차 시승 비유 - 정상 주행, 급커브(경계), 타이어 펑크(예외) [Source C].
* **🗣️ 강사 스크립트 포인트**: "개발을 다 했다고 끝이 아닙니다. 자동차를 만들었으면 시승을 해봐야죠! 평범하게도 달려보고(정상), 아슬아슬하게 브레이크도 밟아보고(경계값), 연료통도 비워봐야(예외) 진짜 튼튼한 코드인지 알 수 있습니다."

### 세션 078: 고객 관리 프로그램 테스트 시나리오 작성 실습
* **📚 참고자료 매핑**: [Source A] 9 디 버깅, 테스트, 배포.pdf (§9.3.1), [Source C] Deep Research (§3.2, 3.3)
* **정의**: 구현한 고객 관리 프로그램(CRUD)에 대해 구체적인 테스트 케이스를 표로 작성해보는 과정.
* **핵심 개념**:
  - Test-Think-Fix 사이클 적용 [Source C].
* **실습 예시**:
  - 정상: 이름 '홍길동', 폰 '010-1234' 입력 시 리스트 추가.
  - 경계: 이름 1글자 '김' 입력.
  - 예외: 나이에 '문자열' 입력 시 시스템 크래시 대신 안내 메시지 출력 방어.
* **🗣️ 강사 스크립트 포인트**: "직접 고객 관리 앱을 부숴봅시다. 사용자가 나이를 입력하는 칸에 '스무살'이라고 한글로 치면 어떻게 될까요? 우리 프로그램이 에러를 뿜으며 죽지 않고, '숫자로 입력해주세요'라고 우아하게 대처하는지 확인하는 게 목표입니다."

### 세션 079: 품질 검사관: 코드 리뷰 5대 체크포인트
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.12), 9 디 버깅, 테스트, 배포.pdf (§9.3.2), [Source B] NotebookLM (§8), [Source C] Deep Research (§4.1)
* **정의**: 생성된 코드를 무비판적으로 수용하지 않고 체계적 기준으로 평가하는 방법 [Source B].
* **핵심 개념**:
  - 5대 기준: 가독성, 유지보수성, 에러 처리(입력 검증), 성능, 보안 [Source C].
  - AI 생성 코드는 종종 예외 처리가 부실할 수 있음을 인지.
* **실습 예시**: AI 코드를 리뷰하며 예외 처리(try-except 누락 등)와 자료구조의 적절성 결함 찾아내기.
* **🗣️ 강사 스크립트 포인트**: "AI가 코드를 1초 만에 짜주지만, 그 코드가 100점짜리라고 믿으면 안 됩니다. 우리는 품질 검사관이 되어서 가독성, 유지보수성, 예외 처리 등을 꼼꼼히 따져야 합니다."

### 세션 080: 완벽한 리뷰 코멘트 작성 및 AI 피드백 실습
* **📚 참고자료 매핑**: [Source A] 9 디 버깅, 테스트, 배포.pdf (§9.3.2 PR), [Source C] Deep Research (§4.2, 4.3)
* **정의**: 찾아낸 결함을 바탕으로 명확한 수정 요구(리뷰 코멘트)를 작성하고, AI 코드 리뷰어의 역할도 체험해보는 과정.
* **핵심 개념**:
  - 코멘트 규칙: 문제 + 이유 + 제안 3요소 [Source C].
  - AI에게 시니어 개발자 페르소나를 부여하여 내 코드를 리뷰하게 만들기.
* **실습 예시**:
  - 나쁜 예: "이 코드 이상해요."
  - 좋은 예: "[에러처리] int() 형변환 시 문자열이 들어오면 ValueError가 납니다. try-except로 감싸주세요."
* **🗣️ 강사 스크립트 포인트**: "'이 코드 별로네요'라고 하면 사람도 AI도 못 알아듣습니다. '여기에 문자가 들어오면 에러가 나니까, try-except로 방어 코드를 넣어주세요'라고 구체적으로 이유와 대안을 제시해야 합니다."

### 세션 081: Day 4 종합: 절차에서 구조로, 그리고 테스트까지
* **📚 참고자료 매핑**: [Source A] 전체 8장, 9장 요약, [Source C] Deep Research (§1, 3, 4)
* **정의**: 오늘 배운 절차적/구조적 프로그래밍의 차이와 테스트, 코드 리뷰의 의미를 종합적으로 복습.
* **핵심 개념**:
  - "작동하는 나쁜 코드"의 고통과 "함수 기반 모듈화"의 해방감 요약.
  - 코드 작성만큼이나 테스트와 리뷰가 중요하다는 개발 문화를 내재화.
* **실습 예시**: Q&A 및 핵심 3문장 요약 공유.
* **🗣️ 강사 스크립트 포인트**: "오늘 우리는 긴 여정을 거쳤습니다. 위에서 아래로 무식하게 흘러가던 코드를 함수로 잘게 쪼갰고, 튼튼한지 시승도 해보았으며, 검사관이 되어 꼼꼼히 리뷰도 했습니다. 이제 여러분은 어엿한 개발자의 시야를 갖추었습니다."

### 세션 082: 나만의 미니 프로젝트: 기획 및 절차적 코드 생성
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.13), [Source C] Deep Research (§6.1, 6.2)
* **정의**: Day 4 내용 전체를 복습하는 3시간짜리 미니 프로젝트 플로우의 첫 단계. 스스로 아이디어를 기획하고 1차 구현을 진행함 [Source C].
* **핵심 개념**:
  - 기획(요구사항) → 절차적 1차 생성 → 문제점 확인.
* **실습 예시**: 도서 관리, 영화 예매, 재고 관리 등 자유 주제의 CRUD 앱 기획 및 AI 프롬프트 작성.
* **🗣️ 강사 스크립트 포인트**: "이제 여러분만의 프로그램을 만들 시간입니다. 도서 관리도 좋고, 카페 재고 관리도 좋습니다. 먼저 기획을 하고, 우리가 아까 했던 것처럼 일부러 '절차적인 1차 코드'를 AI에게 뽑아달라고 해보세요."

### 세션 083: 미니 프로젝트: 구조적 리팩토링 및 퀄리티 체크
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.10, 8.13), [Source C] Deep Research (§6.1)
* **정의**: 자신이 생성한 절차적 코드를 구조적 프로그래밍 기반으로 리팩토링하고, 함수 간의 매개변수 연결이 올바른지 체크.
* **핵심 개념**:
  - AI를 활용한 리팩토링 및 결과물 비교 검증.
* **실습 예시**: 전역 변수를 파라미터로 바꾸고 리턴값을 활용하도록 수정 지시.
* **🗣️ 강사 스크립트 포인트**: "1차로 나온 코드가 마음에 안 드시죠? 당연합니다. 이제 배운 대로 AI에게 '이걸 함수 단위로 구조적으로 쪼개줘!'라고 멋지게 명령을 내려보세요."

### 세션 084: 미니 프로젝트: 극한의 테스트 시나리오 도출
* **📚 참고자료 매핑**: [Source A] 9 디 버깅, 테스트, 배포.pdf (§9.3.1), [Source C] Deep Research (§6.1)
* **정의**: 완성된 기능에 대해 정상/경계/예외 케이스를 도출하고 직접 실행해보며 버그를 잡는 과정.
* **핵심 개념**:
  - 엣지 케이스를 찾아내는 논리적 사고력 배양.
* **실습 예시**: 도서 대출 프로그램에서 대출 권수가 0권, -1권, 문자열일 때의 버그를 찾아내어 수정 지시.
* **🗣️ 강사 스크립트 포인트**: "여러분의 프로그램을 집요하게 괴롭힐 시간입니다! 생각할 수 있는 가장 엉뚱한 값들을 마구 입력해보세요. 에러가 나면서 뻗는다면 오히려 좋은 기회입니다."

### 세션 085: 미니 프로젝트: 코드 리뷰 기반 최종 완성 및 회고
* **📚 참고자료 매핑**: [Source A] 8 코딩.pdf (§8.12, 8.13), 9 디 버깅, 테스트, 배포.pdf (§9.4), [Source C] Deep Research (§6.1, 6.2)
* **정의**: AI에게 시니어 개발자 역할로 코드 리뷰를 요청하여 최종 보완하고, 프로젝트 경험을 회고함.
* **핵심 개념**:
  - 5대 체크포인트 기반 AI 코드 리뷰 프롬프팅.
  - 리팩토링-테스트-리뷰의 완성 사이클 경험.
* **실습 예시**: AI의 리뷰 코멘트를 반영하여 마지막으로 코드를 수정하고, README.md에 배운 점(회고) 작성.
* **🗣️ 강사 스크립트 포인트**: "마지막으로 깐깐한 AI 시니어 개발자에게 코드를 보여줍시다. 지적받은 부분을 고치고 나면, 정말 어디 내놔도 부끄럽지 않은 단단한 구조의 프로그램이 완성될 것입니다. 고생 많으셨습니다!"