# 세션 075 — 절차적 vs 구조적 코드 나란히 비교 분석

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-075 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ |
| **청크 타입** | narrative |
| **선행 세션** | 세션-074 (필수) |
| **학습 목표** | v1과 v2 코드를 비교 분석하여, 메인 루프의 간결화와 함수 호출의 장점을 2가지 이상 설명할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.11 · [B] NotebookLM §6 · [C] Deep Research §5.1 |

---

## ① 도입 — "두 개의 거울을 마주 보다"

🗣️ 강사 대본 (Instructor Script):

여러분, 방금 전 세션에서 우리는 데이터가 마치 택배 상자처럼 문지기를 통해 들어가고 나오는 매개변수와 리턴의 원리를 완벽하게 숙지했습니다. 이제 그 강력한 무기를 장착한 상태로, 우리가 처음 만들었던 길고 복잡한 버전 1(v1) 코드와 새롭게 다듬어낸 구조적인 버전 2(v2) 코드를 나란히 펼쳐놓고 비교해 볼 시간입니다. 마치 성형 수술의 비포 앤 애프터 사진을 나란히 놓고 분석하는 것처럼 말이죠. 이렇게 두 개의 코드를 동시에 띄워놓고 관찰하면, 우리가 함수라는 개념을 도입함으로써 도대체 무엇을 얻어냈는지, 그리고 왜 AI 네이티브 시대에 이러한 구조화가 생존을 위한 필수 조건인지 두 눈으로 똑똑히 확인하실 수 있을 것입니다. 지금부터 화면을 반으로 나누어 왼쪽에는 절차적 방식의 v1 코드를, 오른쪽에는 구조적 방식의 v2 코드를 띄워두고 아주 흥미진진한 틀린 그림 찾기를 시작해 보겠습니다.

---

## ② 비유 — 사장님과 팀장님의 일하는 방식

🗣️ 강사 대본 (Instructor Script):

왼쪽에 있는 v1 코드의 모습을 현실 세계의 회사에 비유해 보겠습니다. v1 코드는 마치 회사의 모든 일을 혼자서 다 처리하려고 드는 워커홀릭 사장님과 같습니다. 이 사장님은 출근하자마자 직접 바닥 청소를 하고, 전화를 직접 당겨 받고, 고객에게 보낼 견적서를 혼자 엑셀로 타이핑하고, 심지어 택배 상자까지 직접 포장합니다. 모든 과정이 사장님의 머릿속에서 한 줄 한 줄 순서대로 이어져 있죠. 처음에는 일이 빨리빨리 진행되는 것 같지만, 회사가 조금만 성장해도 사장님은 과로로 쓰러지고 말 것입니다. 메인 루프 안에 수백 줄의 코드가 폭포수처럼 쏟아져 내리는 절차적 프로그래밍의 한계가 바로 이것입니다. 코드가 조금만 길어져도 개발자의 머릿속 용량을 초과해 버리고 마는 것이죠.

반면 오른쪽에 있는 v2 코드는 아주 유능하고 스마트한 팀장님의 모습과 완벽하게 일치합니다. 이 팀장님은 출근하면 본인이 직접 걸레를 들거나 엑셀을 켜지 않습니다. 대신 각 분야의 전문가들을 불러 모읍니다. "청소팀장님, 바닥 청소 부탁합니다." "영업팀장님, 고객 견적서 처리해 주세요." "물류팀장님, 어제 들어온 주문 포장 바랍니다." 팀장님의 하루 일과는 이렇게 각 담당자에게 정확한 지시를 내리는 것으로 끝납니다. 우리가 새롭게 작성한 구조적 코드의 메인 루프가 바로 이 팀장님의 역할을 수행하고 있습니다. 세부적인 복잡한 작업은 모두 각자의 이름표를 단 함수라는 전문가들에게 위임하고, 메인 루프는 그저 적절한 순서대로 전문가들을 호출하기만 하는 것입니다. 이렇게 하면 회사가 아무리 커져도, 즉 프로그램이 아무리 거대해져도 전체적인 흐름을 한눈에 우아하게 파악할 수 있게 됩니다.

---

## ③ 개념 — 추상화의 마법과 메인 루프의 혁신

🗣️ 강사 대본 (Instructor Script):

이러한 유능한 팀장님의 방식을 컴퓨터 공학에서는 '추상화'라는 아주 멋진 단어로 부릅니다. 복잡하고 지저분한 내부의 구현 세부 사항은 함수의 이름 뒤로 싹 감춰버리고, 오직 '무엇을 할 것인가'라는 핵심 의도만을 남겨두는 기법입니다. [Source A] 8 코딩.pdf의 8.11절을 살펴보면, 이 추상화 덕분에 수백 줄에 달하던 거대한 while True 루프가 단 몇 줄의 함수 호출문으로 드라마틱하게 압축되는 것을 볼 수 있습니다. 메인 루프 안에는 이제 `show_menu()`, `add_customer()`, `calculate_total()`과 같은 사람의 언어에 가까운 직관적인 단어들만이 깔끔하게 자리 잡고 있습니다. 누군가 이 코드를 처음 보더라도 프로그램이 어떤 순서로 동작하는지 단 10초면 파악할 수 있게 된 것입니다.

이러한 구조적 변화가 가져오는 장점은 단순히 코드가 짧아져서 예뻐 보인다는 것에 그치지 않습니다. [Source B] NotebookLM과 [Source C] Deep Research의 분석에 따르면, 구조적 코드는 두 가지 결정적인 강점을 제공합니다. 첫째는 엄청난 재사용성입니다. 영수증을 출력하는 `print_receipt()`라는 함수를 잘 만들어두면, 결제 메뉴뿐만 아니라 환불 메뉴나 과거 결제 내역 조회 메뉴 등 프로그램의 어디에서든 그저 이름을 부르는 것만으로 완벽하게 똑같은 영수증을 출력할 수 있습니다. 둘째는 기적에 가까운 유지보수성입니다. 만약 부가세 계산 로직이 법률 개정으로 인해 바뀌었다고 가정해 봅시다. 옛날 v1 방식이었다면 수천 줄의 코드 사이를 헤매며 부가세 계산 공식을 일일이 찾아 고쳐야 했겠지만, 이제는 `calculate_tax()`라는 함수의 내부만 살짝 수정해주면 프로그램 전체에 일제히 새로운 계산법이 적용됩니다. 이것이 바로 우리가 굳이 시간을 들여 코드를 함수로 쪼개고 구조화한 진짜 이유입니다.

---

## ④ 코드 데모 — 두 세계의 정면 충돌

🗣️ 강사 대본 (Instructor Script):

자, 이제 화면을 통해 실제로 코드가 어떻게 변했는지 감상해 보시죠. 왼쪽의 v1을 보면 메인 루프 역할을 하는 while 문 아래로 무려 150줄의 코드가 아무런 장벽 없이 줄줄이 이어져 있습니다. if 문과 for 문이 복잡하게 얽히고설켜 있어서, 만약 78번째 줄에서 에러가 났을 때 그것이 고객 등록 중에 발생한 것인지, 결제 중에 발생한 것인지 파악조차 쉽지 않습니다. 코드를 읽는 내내 숨이 막히는 기분이 들지 않으신가요?

이번에는 시선을 오른쪽으로 돌려 v2 코드를 보겠습니다. 메인 루프가 어떻게 변했나요? 놀랍게도 단 10줄로 모든 것이 끝납니다. 사용자가 1번을 선택하면 `register_user()`를 호출하고, 2번을 선택하면 `process_payment()`를 호출합니다. 그 안에서 정확히 어떤 복잡한 데이터베이스 작업이 일어나는지 메인 루프는 전혀 알 필요가 없습니다. 그저 문지기에게 매개변수라는 택배를 넘겨주고, 결과가 리턴되어 돌아오기를 느긋하게 기다리기만 하면 됩니다. 이렇게 큰 숲의 윤곽을 먼저 그려놓고 필요할 때만 개별 나무를 들여다보는 하향식 접근법이야말로, 향후 여러분이 AI에게 코딩을 지시할 때 반드시 유지해야 하는 설계자의 시야입니다.

---

## ⑤ 정리 — 완벽한 뼈대의 완성

🗣️ 강사 대본 (Instructor Script):

우리는 오늘 아주 거칠고 복잡했던 절차적 코드 덩어리가, 유능한 팀장님의 지휘 아래 일사불란하게 움직이는 구조적인 예술 작품으로 변모하는 과정을 생생하게 목격했습니다. 메인 루프는 가벼워졌고, 각 기능은 함수라는 단단한 캡슐 안에 안전하게 보호받고 있죠. 하지만 세상에 완벽한 이론은 없습니다.

> **체크포인트**: "표를 보니 구조적 방식이 훨씬 좋다는 건 알겠는데... 진짜 그럴까요? 검색 기능 추가 요청이 들어왔다고 가정해봅시다." — 다음 세션에서 이 완벽해 보이는 구조에 새로운 요구사항이라는 강력한 충격을 가해 보겠습니다!