# 세션 094: 상속의 개념과 필요성

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-094 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | narrative |
| **선행 세션** | 093 (필수) |
| **학습 목표** | 상속의 개념과 필요성을 '유산 상속' 비유를 통해 설명하고, 코드 중복 제거의 이점을 이해할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 상속과 코드 재사용 · [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입 — "VIP 고객이 등장했습니다"

🗣️ 강사 대본 (Instructor Script):

여러분, 캡슐화까지 적용한 튼튼한 v3 고객관리 프로그램을 완성했습니다. 그런데 사장님이 갑자기 새로운 요구사항을 던집니다. "우리 가게에 VIP 고객 등급을 만들자. VIP 고객은 일반 고객과 똑같이 이름, 전화번호, 이메일을 가지지만, 추가로 할인율과 적립 포인트를 관리해야 해." 어떻게 하시겠습니까? 가장 단순한 방법은 `Customer` 클래스를 통째로 복사해서 `VIPCustomer`라는 새 클래스를 만들고, 거기에 할인율과 포인트 속성을 추가하는 겁니다. 하지만 잠깐 — 이름, 전화번호, 이메일 관련 코드가 두 곳에 똑같이 존재하게 됩니다. 나중에 전화번호 검증 로직을 수정해야 하면? 두 곳을 다 고쳐야 합니다. 세 번째 등급이 생기면? 세 곳을 다 고쳐야 합니다. 이것이 바로 코드 중복의 악몽입니다.

---

## ② 비유 — 유산 상속

🗣️ 강사 대본 (Instructor Script):

현실 세계의 "유산 상속"을 떠올려 봅시다 [Source A][Source B]. 부모님이 집, 자동차, 예금 통장을 가지고 계십니다. 자녀인 여러분은 이 재산을 물려받습니다. 물려받았다고 해서 부모님의 재산이 사라지는 게 아니에요 — 부모님은 여전히 원래 재산을 가지고 계시고, 여러분은 그 위에 자신만의 재산(예: 주식 계좌)을 추가로 쌓아갑니다.

프로그래밍에서의 상속(Inheritance)도 정확히 같은 원리입니다 [Source C]. 부모 클래스(`Customer`)가 가진 모든 속성과 메서드를 자식 클래스(`VIPCustomer`)가 그대로 물려받습니다. 자식은 물려받은 것 위에 자기만의 새로운 속성(할인율, 포인트)과 메서드를 추가할 수 있습니다. 부모 클래스의 코드를 한 글자도 복사하지 않아도 됩니다 — 상속 한 줄이면 부모의 모든 기능이 자동으로 넘어옵니다.

이것이 왜 혁명적일까요? 코드 중복이 완전히 사라지기 때문입니다. 전화번호 검증 로직을 수정해야 하면 `Customer` 클래스 한 곳만 고치면 됩니다. `VIPCustomer`는 부모로부터 물려받은 것이니 자동으로 반영됩니다. 10개의 고객 등급이 생겨도 검증 로직은 단 한 곳에만 존재합니다. 이것을 DRY 원칙(Don't Repeat Yourself)이라고 부릅니다 — "같은 코드를 두 번 쓰지 마라."

AI 시대에도 이 원칙은 핵심입니다. AI에게 "VIP 고객 클래스를 만들어줘"라고 요청할 때, "Customer를 상속받아서 만들어줘"라고 한마디 추가하면 AI가 중복 없는 깔끔한 코드를 생성합니다. 반면 상속을 모르면 AI가 코드를 통째로 복사해서 만들어줄 수도 있고, 여러분은 그것이 나쁜 코드인지 판단할 수 없게 됩니다. 설계 원칙을 아는 것이 곧 AI를 제대로 활용하는 힘입니다.

---

## ③ 개념 설명 — 부모 클래스와 자식 클래스

🗣️ 강사 대본 (Instructor Script):

용어를 정리하겠습니다 [Source A][Source C]. 상속에서 기능을 물려주는 쪽을 부모 클래스(Parent Class) 또는 기반 클래스(Base Class)라고 부릅니다. 물려받는 쪽을 자식 클래스(Child Class) 또는 파생 클래스(Derived Class)라고 부릅니다. 파이썬에서 상속을 선언하는 문법은 매우 간단합니다 — 자식 클래스 이름 뒤 괄호 안에 부모 클래스 이름을 적으면 됩니다. `class VIPCustomer(Customer):`처럼요.

이 한 줄만으로 `VIPCustomer`는 `Customer`의 모든 속성(`name`, `phone`, `email`)과 모든 메서드(`display()`, 검증 로직 등)를 자동으로 물려받습니다 [Source B]. 자식 클래스에서는 부모에게 없는 새로운 속성(예: `discount_rate`)만 추가하면 됩니다. 부모의 코드를 한 줄도 복사하지 않았는데, 부모의 모든 기능이 작동합니다. 이것이 상속의 마법입니다.

상속은 "is-a" 관계를 표현합니다. "VIPCustomer는 Customer이다(VIPCustomer is a Customer)" — 이 문장이 자연스러우면 상속이 적절한 겁니다. 반면 "자동차는 엔진이다"는 어색하죠? 이런 경우는 상속이 아니라 "has-a(포함)" 관계로 설계해야 합니다.

---

## ④ 코드 미리보기 — 상속의 첫 모습

🗣️ 강사 대본 (Instructor Script):

코드로 맛보기를 해 봅시다.

```python
class Customer:
    def __init__(self, name: str, phone: str, email: str):
        self.name = name
        self.phone = phone
        self.email = email

    def display(self) -> None:
        print(f"[고객] {self.name} | {self.phone} | {self.email}")

# 상속: Customer의 모든 것을 물려받음
class VIPCustomer(Customer):
    pass  # 아직 추가 기능 없음 — 그래도 Customer의 모든 기능 사용 가능!

vip = VIPCustomer("김VIP", "010-9999-8888", "vip@mail.com")
vip.display()  # [고객] 김VIP | 010-9999-8888 | vip@mail.com
```

`VIPCustomer` 안에는 `pass` 한 줄밖에 없는데, `Customer`의 `__init__`과 `display()`가 그대로 작동합니다. 부모의 유산을 물려받았기 때문이죠. 다음 세션에서는 이 빈 `VIPCustomer`에 할인율이라는 자기만의 재산을 추가하고, `super()`라는 특별한 주문을 배워 보겠습니다.

---

## ⑤ 정리 — "물려받고, 확장하라"

🗣️ 강사 대본 (Instructor Script):

오늘의 핵심을 한 문장으로 정리합니다. 상속은 부모 클래스의 속성과 메서드를 자식 클래스가 그대로 물려받아 코드 중복을 제거하는 기술입니다. "물려받고, 그 위에 확장하라" — 이것이 상속의 철학입니다. 일반 고객 말고 VIP 고객을 만들어야 할 때, 똑같은 코드를 복붙할 필요 없이 상속으로 재산을 물려받으면 됩니다. 다음 세션에서는 `super()`를 사용해 부모의 초기화를 호출하고, VIP만의 특별한 할인율을 추가하는 실전 코드를 작성해 보겠습니다!
