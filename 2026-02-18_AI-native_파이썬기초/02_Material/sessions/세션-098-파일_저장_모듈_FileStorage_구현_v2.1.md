# 마이크로 세션: 098 — 파일 저장 모듈(FileStorage) 구현

> **세션 ID**: MS-PY101-098  
> **일차**: Day 5 | PM | 두 번째 세션  
> **소요 시간**: 25분  
> **난이도**: medium  
> **청크 타입**: lab  
> **버전**: v2.1 (7섹션 구조)

---

## §1. 개요

> **Day 5 | PM | 세션 098/106**

### 🎯 학습 목표

이 세션이 끝나면, 수강생은 다음을 할 수 있습니다:

- 메모리의 휘발성 한계를 이해하고 영구 저장소의 필요성을 설명할 수 있다
- `json` 모듈을 활용하여 고객 데이터를 JSON 파일로 직렬화(저장)하고 역직렬화(복원)할 수 있다
- Storage 인터페이스를 상속받는 `JsonFileStorage` 클래스를 구현할 수 있다

### 선행 세션 환기

바로 직전 세션(세션-097)에서 우리는 의존성 주입(DI) 개념을 배웠어요. 외부에서 저장소를 통째로 주입받아 사용하는 유연한 아키텍처를 설계했죠. 하지만 지금까지 우리가 만든 고객 데이터는 전부 메모리에만 존재했습니다. 프로그램을 껐다 켜면 기껏 등록한 VIP 고객 정보가 전부 증발해 버리는 끔찍한 상황이었죠. 오늘은 이 문제를 해결하기 위해, 데이터를 물리적인 파일로 영구 보존하는 첫 번째 저장소인 `JsonFileStorage`를 직접 만들어 봅니다.

---

## §2. 핵심 개념 (+ 🗣️ 강사 대본 + Mermaid)

### 서류함 전담 직원과 번역기

지금까지 우리 회사의 고객 데이터는 회의실 화이트보드(메모리)에 적혀 있었습니다. 전원이 꺼진다는 것은 퇴근할 때 청소부가 화이트보드를 싹 지워버리는 것과 같아요. 그래서 우리는 "서류함 전담 직원"을 새로 고용할 겁니다. 이 직원의 이름이 바로 `JsonFileStorage`입니다.

이 직원은 딱 두 가지 일만 합니다:
1. 퇴근 전, 화이트보드의 내용을 종이 서류에 옮겨 적어 서류함(하드디스크)에 보관하기 (`save`)
2. 출근 직후, 서류함에서 종이를 꺼내 다시 화이트보드에 똑같이 그려놓기 (`load`)

그런데 화이트보드에 있는 내용(파이썬 객체)을 종이에 적으려면 만국 공통어인 JSON 텍스트로 번역해야 해요. 파이썬 객체를 파일에 쓸 수 있는 텍스트로 바꾸는 과정을 **직렬화(Serialization)**, 반대로 텍스트를 다시 객체로 살려내는 과정을 **역직렬화(Deserialization)**라고 부릅니다.

🗣️ **강사 대본 (Instructor Script)**:

> 여러분, 지금까지 열심히 코딩해서 고객을 등록하고 수정했는데, 껐다 켜면 다 날아가서 허무하셨죠? 메모리, 즉 RAM은 휘발성입니다. 전원이 끊기면 데이터가 모두 지워져요. 실제 서비스에서 이런 일이 벌어지면 바로 뉴스에 나옵니다.
>
> 그래서 오늘은 데이터를 영원히 살려두는 마법을 부릴 겁니다. 메모리에 떠다니는 데이터를 하드디스크에 딱 붙여놓을 거예요. 파이썬 객체를 JSON이라는 표준 텍스트로 바꿔서 파일로 저장하는 거죠. 이것을 직렬화라고 부릅니다. 아까 배운 `@dataclass` 기억나시죠? 그걸 쓰면 딕셔너리로 아주 쉽게 변환할 수 있고, 그걸 다시 `json.dump`로 파일에 쓸 수 있어요. 객체에서 딕셔너리로, 딕셔너리에서 JSON 파일로 이어지는 변환 체인을 직접 경험해 봅시다.

### Mermaid 다이어그램

```mermaid
flowchart TD
    subgraph 메모리 (휘발성)
        A[Customer 객체 리스트]
        B[딕셔너리 리스트<br/>asdict]
    end
    subgraph 하드디스크 (영구 보존)
        C[(customers.json 파일)]
    end

    A -- "직렬화 준비" --> B
    B -- "json.dump()<br/>(저장/save)" --> C
    C -- "json.load()<br/>(복원/load)" --> B
    B -- "**kwargs<br/>객체화" --> A
```

---

## §3. 상세 내용

### Why — 왜 JSON 파일인가?

데이터를 저장하는 방법은 엑셀, CSV, 텍스트 파일 등 다양해요. 그중에서도 JSON(JavaScript Object Notation)을 사용하는 이유는 명확합니다. 사람도 읽기 편하고 컴퓨터도 파싱하기 쉬운 국제 표준 포맷이기 때문입니다. 사실상 현대 웹 환경에서 데이터를 주고받는 99%의 경우가 JSON을 사용한다고 봐도 무방해요. 파이썬에는 이 JSON을 다루는 `json` 모듈이 기본으로 내장되어 있어서, 외부 패키지 설치 없이도 바로 강력한 파일 입출력을 구현할 수 있습니다.

### What — 직렬화와 역직렬화의 구조

파이썬의 `Customer` 객체는 파이썬 세상에서만 의미가 있어요. 이걸 파일에 그대로 복사해서 붙여넣을 수는 없습니다. 그래서 두 단계를 거쳐 텍스트로 바꿉니다.

1. **객체 → 딕셔너리**: `@dataclass`를 쓰면 `dataclasses.asdict()` 함수 하나로 객체가 파이썬 딕셔너리로 변합니다.
2. **딕셔너리 → JSON 텍스트**: `json.dump()` 함수가 딕셔너리 리스트를 `[{"name": "홍길동", ...}]` 형태의 문자열로 바꿔 파일에 써줍니다.

데이터를 읽어올 때는 이 과정을 정확히 거꾸로 밟습니다. `json.load()`로 파일을 읽어 딕셔너리 리스트를 만들고, `Customer(**item)` 문법을 통해 딕셔너리의 키-값 쌍을 언패킹하여 다시 완전한 `Customer` 객체로 살려냅니다.

### How — JsonFileStorage의 작동 원리

우리가 만들 `JsonFileStorage` 클래스는 지난 세션에서 구상한 `Storage` 인터페이스의 첫 번째 실제 구현체입니다. `save(customers)` 메서드와 `load()` 메서드를 반드시 구현해야 해요. 내부적으로 파일 경로를 속성으로 가지며, `with open(...)` 구문을 사용해 파일을 안전하게 열고 닫습니다. 만약 처음 실행해서 아직 파일이 없다면 `FileNotFoundError`가 발생하는데, 이때는 예외 처리(`try-except`)를 통해 빈 리스트를 반환하도록 안전망을 깔아줍니다.

> ✅ **체크포인트**: 직렬화(Serialization)와 역직렬화(Deserialization)의 차이를 설명할 수 있나요?
> - "메모리 속 객체를 파일로 저장하기 위해 텍스트로 바꾸는 것이 직렬화, 반대로 파일 텍스트를 읽어 다시 메모리 객체로 살려내는 것이 역직렬화입니다."

---

## §4. 실습 가이드 (+ 🎙️ 실습 대본)

### 실습 목표

이 실습을 통해 수강생은 파이썬 객체를 JSON 파일로 저장하고 불러오는 `JsonFileStorage` 클래스를 AI의 도움을 받아 직접 작성하고, 실제 파일이 생성되는지 확인합니다.

🎙️ **실습 가이드 대본 (Lab Guide)**:

> 자, 이제 여러분의 코드에 영생을 부여할 시간입니다. 오른쪽 Agent Manager에 프롬프트를 입력해서 `JsonFileStorage` 클래스를 만들어 달라고 할 거예요. AI에게 `json` 모듈과 `dataclasses.asdict`를 꼭 써달라고 명시해야 합니다.
>
> 코드가 완성되면, 고객을 3명 정도 임의로 등록한 뒤에 `save()` 메서드를 호출해 보세요. 그런 다음 VS Code 왼쪽 탐색기를 보세요. `customers.json`이라는 파일이 새로 생겼을 겁니다. 그걸 열어보면 우리가 등록한 고객 정보가 예쁜 텍스트 형태로 적혀 있어요. 가장 짜릿한 순간은 다음입니다. 실행 중인 파이썬 터미널을 과감하게 끄세요. 그리고 다시 실행해서 `load()`를 호출해 보세요. 데이터가 그대로 살아 돌아오는 것을 두 눈으로 확인하시기 바랍니다.

### 단계별 지시

| 단계 | 소요 시간 | 강사 지시사항 | 학습자 액션 | 예상 결과 |
|------|----------|--------------|------------|----------|
| 1 | 3분 | "AI에게 JsonFileStorage 구현을 요청하세요" | 아래 제공된 프롬프트를 Agent Manager에 입력 | `JsonFileStorage` 클래스 코드 생성 |
| 2 | 2분 | "생성된 코드를 프로젝트에 복사하고 리뷰하세요" | 코드를 복사하여 파일에 붙여넣고 `import` 문 확인 | 문법 오류 없이 클래스 추가 완료 |
| 3 | 2분 | "고객 객체를 생성하고 파일로 저장해 보세요" | Customer 객체 3개 생성 후 `save()` 호출 | 프로젝트 폴더에 `customers.json` 파일 생성 |
| 4 | 2분 | "json 파일을 직접 열어서 구조를 확인하세요" | VS Code에서 `customers.json` 열기 | 포맷팅된 JSON 텍스트 확인 |
| 5 | 3분 | "터미널을 재시작하고 load()로 데이터를 복원하세요" | 파이썬 재시작 후 `load()` 호출 | 파일에서 읽어온 데이터로 객체 리스트 출력 |

**[단계 1] AI에게 코드 구현 요청하기**

Agent Manager 채팅창에 다음 프롬프트를 입력하세요:

```text
우리가 만든 Storage 클래스를 상속받는 JsonFileStorage 클래스를 구현해줘.
다음 조건을 반드시 지켜야 해:
1. json 모듈과 dataclasses의 asdict를 사용할 것.
2. __init__에서 저장할 파일 경로(filepath)를 받을 것 (기본값: "customers.json").
3. save(customers) 메서드는 Customer 객체 리스트를 JSON 파일로 저장할 것.
   (한글이 깨지지 않게 ensure_ascii=False 옵션을 주고, indent=2로 예쁘게 정렬해줘)
4. load() 메서드는 JSON 파일을 읽어 다시 Customer 객체 리스트로 반환할 것.
   (파일이 없을 경우 FileNotFoundError를 잡아서 빈 리스트를 반환할 것)
```

**[단계 2] 코드 적용 및 모듈 확인**

AI가 생성한 코드를 여러분의 파이썬 파일에 붙여넣으세요. 이때 맨 위에 `import json`과 `from dataclasses import asdict`가 잘 들어갔는지 반드시 확인해야 합니다. 재료가 없으면 요리를 할 수 없으니까요.

**[단계 3~4] 파일 저장 및 JSON 포맷 확인**

코드를 실행하여 객체를 파일로 저장해 봅니다. 파일 탐색기에 `customers.json`이 생겼나요? 클릭해서 열어보세요. 리스트 대괄호 `[` 안에 중괄호 `{}`로 묶인 고객 정보들이 한글도 깨지지 않고 예쁘게 정렬되어 있는 것을 볼 수 있습니다.

**[단계 5] 영속성(Persistence) 테스트**

이 부분이 핵심입니다. 파이썬 프로그램을 완전히 종료하세요(터미널에서 `exit()` 또는 프로세스 중지). 화이트보드가 깨끗하게 지워진 상태입니다. 다시 프로그램을 실행하고, 이번에는 객체를 새로 만들지 말고 곧바로 `storage.load()`만 실행해서 출력해 보세요. 서류함 전담 직원이 성공적으로 데이터를 복원해 냈나요? 성공했다면 환호하셔도 좋습니다!

---


### 🎓 강사 노트 (Instructor Support)

- ⏱️ **타이밍**: 14:30 (25분, code)
- 🎯 **핵심 활동**: JSON 파일 저장/읽기
- ⚠️ **강사 주의사항**: json 모듈 소개

## §5. 코드 및 명령어 모음

### JsonFileStorage 핵심 구현 코드

```python
import json
from dataclasses import asdict

class JsonFileStorage(Storage):
    def __init__(self, filepath: str = "customers.json"):
        self._filepath = filepath

    def save(self, customers: list[Customer]) -> None:
        # 객체 리스트를 딕셔너리 리스트로 변환
        data = [asdict(c) for c in customers]
        
        # JSON 파일로 쓰기 (한글 깨짐 방지, 들여쓰기 2칸)
        with open(self._filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
            
        print(f"✅ {len(customers)}명의 고객 데이터를 {self._filepath}에 저장했습니다.")

    def load(self) -> list[Customer]:
        try:
            # JSON 파일에서 읽어오기
            with open(self._filepath, "r", encoding="utf-8") as f:
                data = json.load(f)
                
            # 딕셔너리 리스트를 다시 객체 리스트로 복원
            return [Customer(**item) for item in data]
            
        except FileNotFoundError:
            # 파일이 없으면 빈 리스트 반환
            print("⚠️ 저장된 파일이 없어 새로운 데이터를 시작합니다.")
            return []
```

### 테스트 실행 코드

```python
# 1. 저장 테스트
storage = JsonFileStorage("test_data.json")
customers = [
    Customer("홍길동", "010-1111-2222", 30),
    Customer("김철수", "010-3333-4444", 25)
]
storage.save(customers)

# --- 프로그램 종료 후 재시작 했다고 가정 ---

# 2. 로드 테스트
new_storage = JsonFileStorage("test_data.json")
loaded_customers = new_storage.load()

for c in loaded_customers:
    print(c.name, c.phone, c.age)
```

> 🤖 **AI 프롬프트 예시**: "`**item` 문법이 무엇인지 초보자에게 알기 쉽게 설명해줘"

---

## §6. 요약

### 핵심 학습 포인트

이번 세션에서는 메모리의 한계를 벗어나 물리적 파일에 데이터를 보존하는 방법을 배웠습니다. 기억해야 할 핵심은 세 가지입니다. 첫째, 파이썬 객체를 파일에 쓰기 위한 형태로 바꾸는 과정을 **직렬화**, 반대로 살려내는 과정을 **역직렬화**라고 부릅니다. 둘째, 데이터 구조를 저장하고 통신할 때는 국제 표준 텍스트 포맷인 **JSON**을 주로 사용하며 파이썬의 `json` 모듈로 쉽게 다룰 수 있습니다. 셋째, `@dataclass`의 `asdict()`와 `**kwargs` 언패킹 문법을 결합하면 객체와 딕셔너리 사이를 자유롭게 넘나들 수 있습니다.

### 다음 세션 예고

JSON 파일 저장은 아주 훌륭한 방법이지만, 치명적인 단점이 하나 있습니다. 고객이 10명일 때는 괜찮지만, 100만 명이 된다면 어떨까요? 특정 이름의 고객 한 명을 찾기 위해 매번 100만 명치 텍스트 파일을 통째로 읽어와야 합니다. 검색도 느리고 여러 명이 동시에 수정하기도 어렵죠. 다음 세션에서는 이 한계를 돌파하기 위해, 파이썬에 기본 내장된 진짜 데이터베이스 `SQLiteStorage`를 만들어 보겠습니다.

### 브릿지 노트

> "여러분, 이제 퇴근할 때 프로그램 전원을 마음 놓고 끄셔도 됩니다. 서류함 직원이 꼼꼼하게 기록을 남기고 있으니까요. 그런데 우리 회사가 대기업이 되어서 고객이 천만 명이 넘어가면, 텍스트 파일 종이더미로는 도저히 관리가 안 되겠죠? 누군가 '김철수 고객 찾아와' 하면 종이를 처음부터 끝까지 다 뒤져야 하니까요. 다음 시간에는 서류함을 넘어서, 체계적인 '데이터베이스(DB) 시스템'을 우리 프로그램에 붙여보겠습니다."

---

## §7. 참고 자료

### 3-Source 출처

- **Source A (로컬 참고자료)**: `8 코딩.pdf` §8.14 데이터 영속화 — 메모리와 하드디스크의 차이, 직렬화/역직렬화 기초
- **Source B (NotebookLM)**: `day5_notebooklm.md` — 파일/DB 저장 모듈 구축 워크플로우, 서류함 전담 직원 메타포
- **Source C (Deep Research)**: `day5_deep_research.md` — JSON 파일 저장 아키텍처, `dataclasses`를 활용한 효과적인 직렬화 체인

### 추가 학습 자료

- [Python 공식 문서: json 모듈](https://docs.python.org/ko/3/library/json.html): JSON 인코더 및 디코더 사용법
- [Python 공식 문서: dataclasses](https://docs.python.org/ko/3/library/dataclasses.html#dataclasses.asdict): `asdict` 함수의 작동 원리

### 강사 노트

> 💡 **강사 노트**: `load()` 메서드에서 쓰이는 `Customer(**item)` 언패킹 문법에서 많은 수강생이 어려움을 겪습니다. 딕셔너리의 키워드를 함수의 인자로 흩뿌려주는 마법이라고 설명해 주시고, 잘 이해하지 못하는 분들에게는 AI에게 직접 물어보도록 유도하세요. 예외 처리(`FileNotFoundError`)를 다룰 때는 "처음 프로그램을 실행하면 당연히 읽을 파일이 없기 때문에 에러가 나는 것이 정상이고, 우리는 그것을 우아하게 처리하는 것"이라고 맥락을 짚어 주시면 좋습니다.

---

## ✅ 세션 완료 체크리스트 (강사용)

- [ ] §1~§7 모든 섹션이 충실하게 작성되었는가?
- [ ] 서류함 전담 직원 비유가 §2에서 충분히 확장되었는가?
- [ ] 객체 ↔ 딕셔너리 ↔ JSON 직렬화/역직렬화 흐름이 명확히 설명되었는가?
- [ ] 단계별 AI 실습 프롬프트가 §4에 구체적으로 제시되었는가?
- [ ] `json.dump`, `json.load`, `asdict`, `**item` 언패킹 등 핵심 문법이 코드에 포함되었는가?
- [ ] 체크포인트 질문이 §3에 배치되었는가?
- [ ] 3-Source 팩트 패킷 내용이 §7에 반영되었는가?
- [ ] 다음 세션(SQLiteStorage)의 브릿지 노트가 매끄럽게 연결되는가?

---

**🔗 선행 세션**: [세션-097] 의존성 주입(DI) 개념 (필수)  
**🔗 후행 세션**: [세션-099] DB 저장 모듈(SQLiteStorage) 구현

---

*작성 일시: 2026-02-25*  
*작성 에이전트: A4B_Session_Writer*  
*교안 구조: 7섹션 (A0 팀 공통 표준)*