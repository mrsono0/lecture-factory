# 세션 090: 객체지향 리팩토링과 캡슐화 개념

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-090 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | narrative |
| **선행 세션** | 085 (권장), 089 (필수) |
| **학습 목표** | 객체지향 리팩토링의 목적과 '캡슐화'의 개념을 '부서 조직 재편'과 '자동차 운전' 비유를 통해 설명할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 캡슐화와 접근 제어 · [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입 — "데이터와 기능이 아직도 따로 놀고 있습니다"

🗣️ 강사 대본 (Instructor Script):

여러분, Day 4에서 만들었던 `customer_manager_v2.py` 기억나시나요? 함수로 깔끔하게 나눠서 뿌듯했었죠. `add_customer()`, `find_customer()`, `update_customer()`, `delete_customer()` — 기능별로 함수를 분리했으니 절차적 코드보다 훨씬 나아졌습니다. 그런데 한 가지 찜찜한 점이 남아 있었어요. 파일 맨 위에 떡하니 자리 잡고 있는 `customers = []`라는 전역 변수, 보이시나요? 이 리스트 하나를 여러 함수가 돌려가며 쓰고 있습니다. 비유하자면, 회사에 "자료 보관실"과 "업무 실행팀"이 물리적으로 다른 건물에 있어서, 직원들이 종일 서류 뭉치를 들고 왔다 갔다 뛰어다니는 꼴입니다. 오늘은 이 비효율적인 구조에 대대적인 조직 개편을 선언할 시간입니다.

---

## ② 비유 — 부서 조직 재편과 자동차 운전

🗣️ 강사 대본 (Instructor Script):

비유를 두 가지 드리겠습니다. 첫 번째는 "부서 조직 재편"입니다 [Source A]. 지금까지 우리 회사(프로그램)에는 "자료 보관실(전역 변수 `customers`)"이 1층에 있고, "업무 실행팀(함수들)"이 3층에 있었습니다. 고객을 등록하려면 3층 직원이 1층까지 내려가서 서류함을 열고, 새 서류를 넣고, 다시 3층으로 올라와야 합니다. 조회할 때도, 수정할 때도, 삭제할 때도 매번 1층과 3층을 왕복합니다. 직원들이 지칠 수밖에 없죠.

객체지향 리팩토링은 이 구조를 완전히 뒤엎습니다 [Source B]. "고객 관리팀(CustomerManager 클래스)"이라는 새 부서를 만들고, 이 부서 안에 자료 보관함(데이터)과 업무 담당자(메서드)를 모두 배치하는 겁니다. 이제 고객 등록이 필요하면 고객 관리팀 안에서 바로 처리됩니다. 서류를 들고 건물 사이를 뛰어다닐 필요가 없어요. 데이터와 기능이 한 지붕 아래 모이는 것, 이것이 객체지향의 핵심입니다.

두 번째 비유는 "자동차 운전"입니다 [Source A][Source C]. 여러분이 자동차를 운전할 때, 엔진이 몇 기통인지, 연료 분사 타이밍이 어떻게 되는지, 변속기 기어비가 얼마인지 알아야 하나요? 전혀 몰라도 됩니다. 가속 페달을 밟으면 차가 앞으로 가고, 브레이크를 밟으면 멈추고, 핸들을 돌리면 방향이 바뀝니다. 복잡한 내부 구조는 철저히 숨겨져 있고, 운전자에게는 페달과 핸들이라는 단순한 인터페이스만 제공됩니다.

이것이 바로 캡슐화(Encapsulation)입니다 [Source C]. 객체 내부의 데이터를 외부에서 직접 만지지 못하게 숨기고, 오직 정해진 메서드(페달, 핸들)를 통해서만 조작할 수 있게 만드는 기술이에요. 왜 이렇게 할까요? 안전 때문입니다. 운전 중에 누군가 엔진 뚜껑을 열고 부품을 만지면 사고가 나듯이, 프로그램에서도 외부 코드가 객체의 내부 데이터를 마음대로 바꾸면 예상치 못한 버그가 발생합니다. 캡슐화는 이런 "휴먼 에러"를 구조적으로 차단하는 안전장치입니다.

재미있는 점은, 우리가 매일 쓰는 AI도 캡슐화의 혜택을 받고 있다는 사실입니다. 여러분이 ChatGPT나 Claude에게 질문할 때, 트랜스포머 아키텍처의 어텐션 메커니즘이 어떻게 작동하는지 알 필요가 없잖아요? "프롬프트"라는 아주 직관적인 인터페이스만으로 거대한 AI 엔진을 굴리고 있는 겁니다. 캡슐화는 프로그래밍만의 개념이 아니라, 복잡한 세상을 단순하게 다루기 위한 보편적인 설계 철학입니다.

---

## ③ 개념 설명 — 리팩토링과 캡슐화의 정의

🗣️ 강사 대본 (Instructor Script):

용어를 정확히 정리하겠습니다. 리팩토링(Refactoring)이란 프로그램의 외부 동작은 그대로 유지하면서, 내부 구조만 개선하는 작업입니다 [Source A]. 고객 등록, 조회, 수정, 삭제 — 사용자가 보는 기능은 하나도 바뀌지 않지만, 코드의 뼈대가 더 튼튼하고 읽기 쉽게 바뀌는 거예요. 집의 외관은 그대로인데 내부 배관과 전기 배선을 새로 깔아서 더 안전하고 효율적으로 만드는 리모델링과 같습니다.

캡슐화(Encapsulation)는 객체의 내부 데이터를 외부로부터 보호하고, 정해진 메서드를 통해서만 접근하도록 제한하는 원칙입니다 [Source B][Source C]. 파이썬에서는 속성 이름 앞에 밑줄 두 개(`__`)를 붙이면 외부에서 직접 접근하기 어려운 비공개(private) 속성이 됩니다. 예를 들어 `self.__balance`라고 선언하면, 객체 바깥에서 `account.__balance`로 직접 값을 바꿀 수 없습니다. 반드시 `account.deposit(10000)` 같은 메서드를 통해야만 잔액을 변경할 수 있죠.

따라서 객체지향 리팩토링의 핵심 공식은 이렇습니다 — "데이터와 그 데이터를 다루는 로직을 하나의 클래스에 묶고, 외부의 무분별한 접근을 막는다." 이 한 문장이 오늘 세션의 전부입니다.

---

## ④ 코드로 보는 캡슐화 맛보기

🗣️ 강사 대본 (Instructor Script):

간단한 예시 하나만 보고 가겠습니다.

```python
class BankAccount:
    def __init__(self, owner: str, balance: int):
        self.owner = owner
        self.__balance = balance  # 비공개 속성 (밑줄 두 개)

    def deposit(self, amount: int) -> None:
        if amount > 0:
            self.__balance += amount

    def get_balance(self) -> int:
        return self.__balance
```

`self.__balance`는 밑줄 두 개로 시작하기 때문에 외부에서 `account.__balance = -9999` 같은 위험한 조작이 차단됩니다 [Source A]. 잔액을 바꾸려면 반드시 `deposit()` 메서드를 거쳐야 하고, 이 메서드 안에는 `amount > 0`이라는 검증 로직이 들어 있어서 음수 입금 같은 말도 안 되는 상황을 원천 봉쇄합니다. 이것이 캡슐화의 실전적 가치입니다 — 데이터를 안전하게 지키면서도, 사용하는 쪽에서는 편리한 메서드만 호출하면 됩니다.

---

## ⑤ 정리 — "조직 개편의 명분은 충분합니다"

🗣️ 강사 대본 (Instructor Script):

오늘 배운 두 가지를 정리합니다. 첫째, 객체지향 리팩토링은 흩어진 데이터와 기능을 하나의 클래스로 모아서 코드를 튼튼하게 만드는 "부서 조직 재편"입니다. 둘째, 캡슐화는 내부 데이터를 숨기고 메서드라는 안전한 통로만 열어두는 "자동차 페달" 설계입니다. 이 두 무기가 우리 코드를 얼마나 강력하게 만드는지, 다음 세션에서 직접 체험하실 겁니다. 어제의 낡은 v2 코드를 최첨단 v3 코드로 멋지게 리팩토링하러 가봅시다!
