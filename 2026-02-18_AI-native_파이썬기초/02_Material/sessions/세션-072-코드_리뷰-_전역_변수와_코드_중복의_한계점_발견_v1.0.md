# 세션 072 — 코드 리뷰: 전역 변수와 코드 중복의 한계점 발견

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-072 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ |
| **청크 타입** | narrative |
| **선행 세션** | 세션-071 (필수) |
| **학습 목표** | 완성된 절차적 코드를 리뷰하며 전역 변수의 위험성과 코드 중복(DRY 원칙 위배) 문제를 식별할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.12 · [B] NotebookLM §4 · [C] Deep Research §1.2 |

---

## ① 도입 — "잘 돌아가는데 무엇이 문제일까?"

🗣️ 강사 대본 (Instructor Script):

우리는 지난 시간까지 네 가지 핵심 기능이 모두 들어간 고객 관리 프로그램을 완성했습니다. 입력하면 들어가고, 지우면 사라지는 아주 훌륭하고 완벽하게 작동하는 프로그램입니다. 그런데 여러분, 현업에서 활동하는 숙련된 개발자에게 이 코드를 보여준다면 아마 당장 뜯어고치자고 말할 것입니다. 도대체 무엇이 문제일까요? 겉으로는 아무런 문제 없이 잘 달리는 자동차처럼 보이지만, 사실 그 자동차의 보닛을 열어보면 엔진과 각종 부품들이 테이프로 얼기설기 붙어있는 것과 같은 상태입니다. 코드가 작동한다고 해서 그것이 곧 좋은 코드라는 의미는 아닙니다. 오늘은 우리가 직접 짠 코드를 스스로 비판적인 시각에서 뜯어보는 시간을 갖겠습니다. 내가 짠 코드의 문제점을 발견하는 눈을 가지는 것이야말로 진정한 시니어 개발자로 성장하는 가장 중요한 첫걸음입니다.

---

## ② 비유 — 공용 금고와 복붙 안내문

🗣️ 강사 대본 (Instructor Script):

우리 코드의 문제점을 쉽게 이해하기 위해 두 가지 상황을 상상해 봅시다. 첫 번째는 길거리에 덩그러니 놓인 공용 금고입니다. 우리 코드의 가장 꼭대기에 선언된 고객 리스트가 바로 이 공용 금고와 같습니다. 비밀번호도 없고 뚜껑이 활짝 열려 있어서 누구나 지나가다가 돈을 넣을 수도 있고 마음대로 빼갈 수도 있습니다. 만약 프로그램의 엉뚱한 곳에서 실수로 이 금고를 엎어버린다면 모든 데이터가 한순간에 날아가 버릴 것입니다. 프로그래밍에서는 이를 전역 변수의 오염이라고 부릅니다. 누구든지 언제든 접근해서 바꿀 수 있는 상태는 매우 편리해 보이지만, 조금만 복잡해져도 어디서 데이터가 꼬였는지 도저히 추적할 수 없는 재앙의 씨앗이 됩니다.

두 번째 상황은 건물 1층부터 10층까지 화장실 문 앞에 똑같이 붙어있는 복붙 안내문입니다. 만약 화장실 비밀번호가 바뀌어서 안내문을 수정해야 한다면 어떻게 될까요? 경비원은 1층부터 10층까지 땀을 뻘뻘 흘리며 계단을 오르내리고 안내문을 열 번이나 새로 고쳐 적어야 합니다. 단 한 군데라도 빼먹으면 누군가는 화장실에 들어가지 못하고 발을 동동 구르게 되겠죠. 우리 코드에서 검색을 위해 반복적으로 작성했던 조건문 로직이 바로 이 복붙 안내문과 같습니다. 이름으로 고객을 찾는 기능에 오류가 발견되거나 검색 기준을 전화번호로 바꿔야 한다면, 우리는 조회 메뉴에서도 고치고 수정 메뉴에서도 고치고 삭제 메뉴에서도 똑같이 고쳐야만 합니다. 이처럼 똑같은 코드가 여러 곳에 흩어져 있는 상황은 프로그래머들이 가장 경계하는 최악의 패턴입니다.

---

## ③ 개념 — 절차적 코드의 3대 문제점과 DRY 원칙

🗣️ 강사 대본 (Instructor Script):

우리가 작성한 모놀리식 절차적 코드는 크게 세 가지 치명적인 한계를 가집니다. 첫째는 앞서 비유로 설명한 전역 상태의 오염 위험입니다. 모든 기능이 하나의 거대한 리스트를 공유하고 있기 때문에, 예기치 못한 버그가 발생했을 때 그 원인을 찾기가 모래사장에서 바늘 찾기만큼 어려워집니다[A 8 코딩.pdf §8.12]. 둘째는 심각한 코드의 중복입니다. 똑같은 일을 하는 코드가 여기저기 흩어져 있어서 무언가 하나를 바꿀 때마다 여러 곳을 동시에 건드려야 합니다. 개발의 세계에는 '똑같은 것을 두 번 반복하지 말라'는 뜻의 DRY, 즉 Don't Repeat Yourself 라는 아주 유명한 황금 원칙이 있습니다[B NotebookLM §4]. 우리의 코드는 이 원칙을 정면으로 위반하고 있습니다. 

마지막 셋째는 테스트가 불가능하다는 점입니다. 등록 기능만 따로 떼어내서 정말 이름이 잘 들어가는지 확인하고 싶어도, 우리는 무조건 무한 루프를 돌리고 메뉴 1번을 선택하는 번거로운 과정을 거쳐야만 합니다[C Deep Research §1.2]. 프로그램의 각 부품이 독립적으로 분리되어 있지 않아서 부분적인 점검이 아예 불가능한 구조인 것입니다. 예를 들어 출력 형식을 조금만 바꾼다고 가정해 봅시다. 지금은 조회, 수정, 삭제 곳곳에서 프린트 함수를 호출하고 있습니다. 만약 고객 이름 앞에 하트 기호를 붙이고 싶다면 도대체 코드를 몇 군데나 찾아다니며 수정해야 할까요? 이런 구조로는 앞으로 더 많은 기능을 덧붙일수록 코드는 점점 괴물이 되어갈 뿐입니다.

---

## ④ 코드 데모 — 중복과 얽힘의 실체 확인

🗣️ 강사 대본 (Instructor Script):

이 문제점들을 머리로만 이해할 것이 아니라, 코드를 보며 직접 그 심각성을 체감해 봅시다. 여러분이 작성한 파일에서 for 반복문이 시작되는 부분을 한 번 찾아보세요. 수정 기능을 담당하는 메뉴 3번 안에도 for c in customers 라는 반복문이 길게 자리 잡고 있고, 바로 그 밑의 삭제 기능을 담당하는 메뉴 4번 안에도 글자 하나 다르지 않은 for c in customers 반복문이 떡하니 버티고 있습니다. 

심지어 고객의 정보를 화면에 보여주는 프린트 함수조차도 각 메뉴 안에 단단하게 갇혀있습니다. 만약 누군가 "등록을 완료할 때 방금 등록한 사람의 이름도 같이 보여주세요"라고 요구한다면, 우리는 등록 기능 안에 출력 코드를 또다시 복사해서 붙여넣어야 합니다. 기능들이 서로의 꼬리를 물고 하나의 거대한 실타래처럼 엉켜 있어서, 한 곳을 잡아당기면 프로그램 전체가 흔들거리는 불안한 상태입니다. 우리는 이것을 가리켜 구조가 없는 스파게티 코드라고 부릅니다. 이 스파게티의 면발을 가위로 싹둑싹둑 잘라서 용도별로 예쁘게 그릇에 나누어 담는 작업이 우리에게 아주 절실히 필요합니다.

---

## ⑤ 정리 — 진단을 마친 코드를 수술대로

🗣️ 강사 대본 (Instructor Script):

여러분은 오늘 작동하는 코드를 넘어서, 그 이면에 숨겨진 구조적인 결함들을 매의 눈으로 찾아내셨습니다. 전역 변수로 인한 데이터의 불안정성, 똑같은 로직이 복사되어 늘어나는 코드 중복, 그리고 개별적인 테스트가 불가능한 단단한 결합까지. 문제점을 이렇게 정확히 진단했으니, 이제 우리 손으로 직접 수술대에 올릴 차례입니다. 다음 시간에는 이 엉킨 코드들을 어떻게 우아하고 깔끔하게 풀어낼 수 있는지, AI의 힘을 빌려 구조를 개편해 보겠습니다.

> **체크포인트**: "개발의 세계에서 똑같은 코드를 두 번 이상 반복해서 작성하지 말라는 의미를 담고 있는 유명한 원칙의 영문 약자는 무엇일까요?" — 정답은 DRY 원칙입니다!