# 세션 055: 예외 처리와 안전망 구축 (try-except)

> **세션 ID**: MS-PY101-055 | **소요 시간**: 20min | **난이도**: ★★☆
> **청크 타입**: narrative | **선행 세션**: 054(필수) | **후행 세션**: 056
> **출처**: [Source A: 8 코딩.pdf, 9 디버깅.pdf] [Source B: NotebookLM day3] [Source C: Deep Research day3]

---

## ① 도입 (Hook)

🗣️ 강사 대본 (Instructor Script):

여러분, 우리가 지난 시간에 반복문을 통해 꽤 그럴듯하게 돌아가는 프로그램을 만들었습니다. 그런데 완벽해 보이는 이 프로그램에 치명적인 약점이 하나 있습니다. 사용자가 화면에 "나이를 숫자로 입력하세요"라는 안내문을 보고, 숫자 대신 장난삼아 "안녕"이라고 한글을 치면 어떻게 될까요? 네, 화면에 시뻘건 에러 메시지가 쏟아지면서 프로그램이 그 즉시 심장마비에 걸린 것처럼 픽 죽어버리고 맙니다. 이것을 우리는 '런타임 에러(Runtime Error)'라고 부릅니다. 개발자가 아무리 코드를 논리적으로 잘 짰다고 하더라도, 현실의 사용자는 항상 우리의 예상을 뛰어넘는 기상천외한 행동을 합니다. 만약 여러분이 만든 인공지능 주식 자동매매 프로그램이 서버와 통신하다가 아주 잠깐 인터넷이 끊겼다고 해서, 에러를 내뿜으며 아예 종료되어 버린다면 어떨까요? 엄청난 금전적 손실로 이어질 것입니다. 프로그램이 중간에 죽어버리는 것보다는, "잘못된 입력입니다. 다시 입력해 주세요"라거나 "네트워크가 불안정합니다. 잠시 후 다시 시도합니다"라고 안내해 주는 것이 훨씬 훌륭한 사용자 경험(UX)을 제공합니다. 그래서 오늘은 외부의 충격이나 잘못된 상황 속에서도 우리 프로그램이 절대로 죽지 않게 꽉 잡아주는 강력한 맷집, 바로 예외 처리 기법에 대해 배워보겠습니다.

---

## ② 비유 풀이 (Analogy)

🗣️ 강사 대본 (Instructor Script):

예외 처리를 이해하기 위해 서커스 공연장에 왔다고 상상해 봅시다. 공중그네를 타는 곡예사가 허공을 가르며 멋지게 묘기를 부립니다. 이 곡예사의 완벽한 동작은 오류가 나지 않는 정상적인 코드 실행과 같습니다. 하지만 곡예사도 인간인지라 손이 미끄러져서 그네를 놓칠 때가 있습니다. 만약 바닥에 아무것도 없다면 곡예사는 치명상을 입고 서커스 공연 자체가 그 자리에서 비극적으로 끝나버리겠죠. 프로그램이 에러를 뿜고 강제 종료되는 상황이 바로 이것입니다. 그래서 서커스단은 항상 바닥에 커다랗고 튼튼한 '안전그물'을 설치해 둡니다. 이 안전그물이 바로 오늘 우리가 배울 트라이-익셉트(try-except) 구문입니다. 곡예사가 떨어지더라도 안전그물이 튕겨내어 받아주면, 관객들은 잠시 놀라겠지만 서커스 공연은 멈추지 않고 계속될 수 있습니다. [Source A: 8 코딩.pdf, 9 디버깅.pdf]에서 강조하는 방어적 프로그래밍도 이와 같은 맥락입니다. 또한 최신 인공지능 트렌드를 다룬 [Source B: NotebookLM day3]를 보면, AI가 복잡한 문서를 읽다가 해독할 수 없는 문자를 만나도 전체 프로세스를 멈추지 않고 해당 부분만 예외 처리하여 넘어가는 것을 볼 수 있습니다. 나아가 [Source C: Deep Research day3]에서 설명하는 대규모 데이터 수집 파이프라인 역시, 수만 개의 웹페이지 중 몇 개가 접속되지 않더라도 전체 크롤링이 중단되지 않도록 촘촘한 예외 처리 대피 계획을 세워두고 있습니다. 프로그램이라는 거대한 건물에 화재 경보기와 비상 대피로를 설계하는 마음으로 오늘 내용을 살펴봅시다.

---

## ③ 개념 설명 (What)

🗣️ 강사 대본 (Instructor Script):

파이썬에서 안전망을 치는 방법은 네 가지 키워드로 구성됩니다. 바로 트라이(try), 익셉트(except), 엘스(else), 파이널리(finally)입니다. 먼저 트라이 블록에는 우리가 원래 실행하고 싶었던 메인 코드, 즉 '에러가 발생할지도 모르는 위험한 코드'를 집어넣습니다. 만약 트라이 안에서 코드가 정상적으로 실행되면 익셉트 블록은 완전히 무시됩니다. 하지만 트라이 안에서 무언가 터졌다, 에러가 발생했다면 파이썬은 즉시 트라이 블록 실행을 멈추고 익셉트 블록으로 피신합니다. 익셉트는 여러 개를 겹쳐서 사용할 수 있습니다. 예를 들어 밸류에러(ValueError)는 사용자가 숫자를 넣어야 할 곳에 문자를 넣었을 때 잡아내는 그물이고, 제로디비전에러(ZeroDivisionError)는 숫자를 영으로 나누려고 할 때 발생하는 수학적 모순을 잡아내는 그물입니다. 이렇게 에러의 종류별로 다르게 대응할 수 있습니다. 다음으로 엘스(else) 블록은 트라이 블록에서 단 한 개의 에러도 발생하지 않고 완벽하게 성공했을 때만 실행되는 축하 파티 같은 공간입니다. 마지막으로 파이널리(finally) 블록은 에러가 났든 안 났든, 심지어 중간에 반복문을 탈출하는 브레이크(break)나 리턴(return)을 만났더라도 무조건 마지막에 실행되는 정리정돈 블록입니다. 열어두었던 파일을 닫거나 네트워크 연결을 끊는 등 반드시 마무리해야 하는 작업을 파이널리 안에 작성합니다.

---

## ④ 코드/실제 활용 (How)

🗣️ 강사 대본 (Instructor Script):

자, 그럼 이 네 가지 키워드가 실제 코드에서 어떻게 하나의 튼튼한 요새를 구축하는지 살펴보겠습니다. 백이라는 숫자를 사용자가 입력한 숫자로 나누는 간단한 계산기 프로그램입니다. 다양한 형태의 공격으로부터 이 프로그램이 어떻게 살아남는지 코드의 구조를 눈여겨보세요.

```python
try:
    num = int(input("숫자 입력: "))
    result = 100 / num
except ValueError:
    print("숫자만 입력해야 합니다!")
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다!")
else:
    print(f"결과는 {result}입니다.")
finally:
    print("계산 종료.")
```

🎙️ 실습 가이드 (Lab Guide):

여러분, 편집기에 위 코드를 그대로 타이핑해 보세요. 그리고 코드를 실행한 뒤 의도적으로 프로그램이 싫어할 만한 행동을 해보겠습니다. 첫 번째 실행에서는 숫자 20을 입력해 봅니다. 그러면 결과는 5.0이 나오고 계산 종료가 출력될 것입니다. 에러가 없었으므로 엘스 블록과 파이널리 블록이 실행된 것이죠. 두 번째로 다시 실행하고 이번에는 '파이썬'이라고 한글을 입력해 보세요. 트라이 블록 안의 int() 변환 과정에서 에러가 터지면서 밸류에러 그물에 걸려 "숫자만 입력해야 합니다!"가 출력되고 파이널리로 넘어갑니다. 세 번째로는 숫자 0을 입력해 보세요. 이번에는 100을 0으로 나누려다가 제로디비전에러 그물에 걸려 "0으로 나눌 수 없습니다!"라는 메시지를 보여줍니다. 어떤 짓을 해도 프로그램이 에러를 뿜으며 비정상적으로 뻗어버리지 않는다는 것을 직접 눈으로 확인하시기 바랍니다.

---

## ⑤ 정리 및 다음 세션 예고 (Closing)

🗣️ 강사 대본 (Instructor Script):

오늘 우리는 트라이, 익셉트, 엘스, 파이널리라는 네 가지 도구를 조합하여 웬만한 외부 충격에는 끄떡도 하지 않는 튼튼한 프로그램을 만드는 법을 배웠습니다. 예외 처리는 서커스의 안전그물이자, 프로그램이 추락하는 것을 막고 사용자에게 친절하게 상황을 안내하는 최고의 사용자 경험 도구입니다. 이제 여러분의 프로그램은 무한히 반복할 수 있는 체력(반복문)도 가졌고, 외부의 공격을 버텨내는 맷집(예외 처리)도 갖추었습니다. 하지만 코드가 점점 길어지다 보니, 계산기 기능을 만들기 위해 매번 십여 줄의 코드를 복사해서 붙여넣기 해야 하는 번거로움이 생기기 시작했습니다. 코드가 천 줄, 만 줄로 길어지면 똑같은 코드를 계속 복사해서 쓸 수는 없겠지요. 그래서 다음 세션에서는 우리가 지금까지 짠 유용한 코드들을 마치 '레시피 카드'처럼 예쁘게 포장해서, 필요할 때마다 이름만 불러서 꺼내 쓰는 마법 같은 도구, 바로 '함수(Function)'에 대해 배워보도록 하겠습니다.
