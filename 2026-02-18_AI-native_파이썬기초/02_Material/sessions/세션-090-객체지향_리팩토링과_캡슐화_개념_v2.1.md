# 마이크로 세션: 090, 객체지향 리팩토링과 캡슐화 개념

> **세션 ID**: MS-PY101-090  
> **소요 시간**: 20분  
> **난이도**: medium  
> **청크 타입**: narrative  
> **버전**: v2.1 (7섹션 구조)

---

## §1. 개요

> **Day 5 | AM | 세션 090/096**

이 세션은 Day 4에서 작성했던 절차적 방식의 고객 관리 프로그램(v2)을 객체지향 아키텍처(v3)로 전환하기 위한 첫걸음입니다. 코드를 타이핑하는 스킬보다, 코드를 어떻게 설계하고 배치할 것인지 구조적인 통찰력을 키우는 시간이에요. 단순한 문법 학습을 넘어, 왜 전역 변수가 위험한지, 왜 데이터와 함수를 하나의 클래스로 묶어야 하는지 '조직 개편'이라는 직관적인 비유로 이해하게 됩니다.

### 🎯 학습 목표

이 세션이 끝나면 수강생은 다음을 할 수 있어요.

- 절차적 코드(v2)에 남아있는 전역 변수 구조의 문제점을 설명할 수 있습니다.
- '부서 조직 재편'과 '자동차 운전' 비유를 통해 객체지향 리팩토링과 캡슐화의 목적을 이해할 수 있습니다.
- 파이썬에서 `__`(더블 언더스코어)를 사용하여 비공개 속성을 만들고 외부 접근을 차단하는 기본 원리를 적용할 수 있습니다.

### 선행 세션 환기

수강생들은 세션 085를 통해 데이터 딕셔너리의 한계를, 세션 089를 통해 `@dataclass`를 사용한 데이터 모델링을 학습했습니다. 이제 데이터(속성)와 기능(메서드)을 결합해, 스스로 데이터를 보호하고 조작하는 능동적인 객체를 설계하는 단계로 넘어갑니다.

---

## §2. 핵심 개념 (+ 🗣️ 강사 대본 + Mermaid)

### 부서 조직 재편과 자동차 운전 비유

데이터와 그것을 처리하는 로직을 하나로 묶는 것(클래스), 그리고 외부에서 내부 데이터를 함부로 건드리지 못하게 보호하는 것(캡슐화). 이 두 가지는 객체지향의 가장 중요한 기둥입니다. 수강생들이 이 추상적인 개념을 단번에 이해할 수 있도록 두 가지 강력한 메타포를 사용합니다.

🗣️ **강사 대본 (Instructor Script)**:

> 여러분, Day 4에서 만들었던 `customer_manager_v2.py` 기억나시나요? 기능별로 함수를 깔끔하게 분리해서 "이제 좀 프로그램 같네!" 하고 뿌듯하셨을 거예요. `add_customer()`, `find_customer()`, `delete_customer()` 등 여러 함수로 나눴으니 과거의 절차적 코드보다는 훨씬 나아졌죠.
> 
> 그런데 한 가지 찜찜한 점이 남아있었습니다. 파일 맨 위에 떡하니 자리 잡고 있는 `customers = []`라는 전역 변수, 보이시나요? 이 리스트 하나를 여러 함수가 돌려가며 쓰고 있습니다. 
> 
> 비유하자면 이렇습니다. 우리 회사에 "자료 보관실(customers 전역 변수)"은 1층에 있고, "업무 실행팀(함수들)"은 3층에 있는 꼴이에요. 고객을 등록하려면 3층 직원이 1층까지 내려가서 서류함을 열고, 새 서류를 넣고 다시 3층으로 헉헉대며 올라와야 합니다. 조회할 때도, 수정할 때도 매번 1층과 3층을 왕복하죠. 얼마나 비효율적인가요?
> 
> 객체지향 리팩토링은 이 구조를 완전히 뒤엎는 **"대대적인 부서 조직 재편"**입니다. 우리는 이제 "고객 관리팀(CustomerManager 클래스)"이라는 독립적인 새 부서를 하나 만들 겁니다. 그리고 이 부서 안에 자료 보관함(데이터)과 업무 담당자(메서드)를 모두 모아둘 거예요. 그러면 어떻게 될까요? 고객 등록 업무가 들어오면, 부서 안에서 바로 처리됩니다! 서류를 들고 1층과 3층을 뛰어다닐 필요가 없어요. 
> 
> 이처럼 **데이터와 기능이 한 지붕 아래 모이는 것, 이것이 객체지향의 첫 번째 핵심**입니다.
> 
> 두 번째 비유는 **"자동차 운전"**입니다. 여러분이 자동차를 몰 때, 엔진이 몇 기통인지, 연료 분사가 어떻게 일어나는지, 밸브가 언제 열리는지 다 알고 타시나요? 전혀 몰라도 됩니다. 우리는 가속 페달을 밟으면 차가 앞으로 가고, 브레이크를 밟으면 멈춘다는 것만 알면 되죠. 복잡한 내부 구조는 철저히 숨겨져 있고, 운전자에게는 "페달"과 "핸들"이라는 아주 단순한 인터페이스만 제공됩니다.
> 
> 이것이 바로 오늘 배울 **캡슐화(Encapsulation)**입니다. 자동차 제조사가 엔진룸을 함부로 못 열게 막아둔 것처럼, 객체 내부의 데이터를 외부에서 마음대로 만지지 못하게 꼭꼭 숨기고 오직 정해진 메서드(페달과 핸들)를 통해서만 조작하게 만드는 기술입니다. 왜 그럴까요? 안전 때문입니다. 주행 중에 누군가 엔진 부품을 마음대로 건드리면 대형 사고가 나듯, 외부 코드가 내부 데이터를 마음대로 바꾸면 치명적인 버그가 발생하니까요.

### Mermaid 다이어그램: 절차적 vs 객체지향

```mermaid
flowchart LR
    subgraph 절차적 구조 "절차적 프로그래밍 (v2)"
        direction TB
        D1[(1층 자료실\ncustomers 리스트)]
        F1[3층 직원 A\nadd_customer]
        F2[3층 직원 B\nfind_customer]
        F1 -. "직접 접근\n(왕복)" .-> D1
        F2 -. "직접 접근\n(왕복)" .-> D1
    end

    subgraph 객체지향 구조 "객체지향 프로그래밍 (v3)"
        direction TB
        subgraph CustomerManager "고객 관리팀 (CustomerManager)"
            D2[("부서 내 캐비닛\n_customers (숨김)")]
            M1["담당자 (add 메서드)"]
            M2["담당자 (find 메서드)"]
            M1 --> D2
            M2 --> D2
        end
    end
```

이 다이어그램은 전역 변수 기반의 취약한 구조(왼쪽)가 어떻게 캡슐화된 클래스 구조(오른쪽)로 진화하는지 시각적으로 보여줍니다. 흩어진 데이터와 로직을 묶고 숨기는 것이 핵심입니다.

---

## §3. 상세 내용

### Why: 왜 리팩토링과 캡슐화가 필요한가?

절차적 프로그래밍에서 프로그램 규모가 커지면 전역 변수는 시한폭탄과 같습니다. 수십 개의 함수가 하나의 전역 리스트를 동시에 건드리기 시작하면, 언제 어디서 데이터가 오염되었는지 추적하는 것이 거의 불가능해집니다. "의도치 않은 데이터 변경(Side Effect)"을 막기 위해 우리는 데이터를 클래스라는 울타리 안에 가두고, 검증된 통로(메서드)만 열어두는 캡슐화 전략이 반드시 필요합니다.

### What: 리팩토링과 캡슐화의 정확한 의미

- **리팩토링(Refactoring)**: 프로그램의 외부 동작(기능)은 그대로 유지하면서, 내부 코드의 구조만 개선하는 작업입니다. 사용자는 변화를 느끼지 못하지만, 코드를 유지보수하는 개발자 입장에서는 건물의 낡은 배관을 전부 새 것으로 교체하는 것과 같은 극적인 개선을 얻습니다.
- **캡슐화(Encapsulation)**: 객체의 내부 데이터를 보호하고 은닉하는 원칙입니다. 외부에서 `account.balance = 10000000`처럼 마음대로 값을 조작하지 못하게 막고, 오직 `account.deposit(amount)` 같은 통제된 메서드만 허용합니다.

### How: 파이썬에서 어떻게 구현하는가?

파이썬은 다른 언어(Java의 private 등)처럼 엄격한 접근 제어 키워드가 없는 대신, 변수명 앞에 밑줄 두 개(`__`)를 붙이는 방식을 사용합니다.

🗣️ **강사 대본 (Instructor Script)**:

> 코드로 어떻게 구현하는지 볼까요? 파이썬은 참 솔직한 언어라서, "이 데이터는 건드리지 마!"라고 표시하려면 이름 앞에 언더스코어 두 개, 즉 밑줄 두 개(`__`)를 쫙 그어버립니다. 
> 
> 클래스 안에서 `self.__balance = balance` 라고 선언하면, 이 변수는 외부에서 직접 부를 수 없는 '비공개(Private)' 속성이 됩니다. 객체 밖에서 `account.__balance`라고 접근하면 파이썬은 "그런 변수 없는데요?" 라며 시치미를 뚝 떼고 에러를 냅니다. 철저하게 엔진룸을 잠가버리는 거죠.
> 
> 그렇다면 잔액을 바꾸고 싶을 땐 어떻게 할까요? 바로 `deposit()`이나 `withdraw()` 같은 전용 메서드를 사용해야 합니다. 

---

## §4. 코드로 보는 캡슐화 맛보기 (+ 🎙️ 실습 대본)

### 실습 목표

간단한 은행 계좌(BankAccount) 예시를 통해 캡슐화가 적용된 클래스와 그렇지 않은 변수의 차이를 명확히 확인합니다.

🎙️ **실습 가이드 대본 (Lab Guide)**:

> 자, 화면에 띄운 코드를 같이 보겠습니다. 아주 간단한 은행 계좌 클래스예요.
> 
> ```python
> class BankAccount:
>     def __init__(self, owner: str, balance: int):
>         self.owner = owner
>         self.__balance = balance  # 비공개 속성!
> ```
> 
> 여기서 `owner`는 언더스코어가 없죠? 누구나 "이 계좌 주인이 누구야?" 하고 `account.owner`로 볼 수 있습니다. 하지만 `__balance`는 꽁꽁 숨겨져 있어요. 누군가 악의적으로 `account.__balance = 99999999`라고 해서 벼락부자가 되려고 해도 통하지 않습니다. 
> 
> 대신 돈을 입금할 수 있는 합법적인 창구를 만들어 두었죠. 
> 
> ```python
>     def deposit(self, amount: int) -> None:
>         if amount > 0:
>             self.__balance += amount
>             print(f"{amount}원이 입금되었습니다.")
>         else:
>             print("장난치지 마세요. 0원 이하는 입금할 수 없습니다.")
> ```
> 
> 보세요! `deposit` 메서드 안에 `if amount > 0:` 이라는 아주 든든한 경비원(검증 로직)이 서 있습니다. 마이너스 금액을 입금해서 잔고를 빼돌리려는 시도를 여기서 원천 차단하는 거예요. 만약 캡슐화를 안 하고 변수를 그냥 열어두었다면 이런 경비원을 세울 수도 없었을 겁니다. 이것이 바로 캡슐화의 실전 가치입니다!

### 단계별 지시사항

| 단계 | 소요 시간 | 강사 지시사항 | 학습자 액션 |
|------|----------|--------------|------------|
| 1 | 5분 | BankAccount 예시 코드 타이핑 및 실행 | 코드 에디터에서 작성 |
| 2 | 2분 | `account.__balance = 100` 실행해보기 | AttributeError 발생 확인 |
| 3 | 3분 | `account.deposit(-500)` 실행해보기 | 에러 메시지 검증 |

---


### 🎓 강사 노트 (Instructor Support)

- ⏱️ **타이밍**: 10:30 (20분, narrative)
- 🎯 **핵심 활동**: "부서 조직 재편" 비유
- ⚠️ **강사 주의사항**: v2→v3 전환 동기 부여

## §5. 코드 및 명령어 모음

강의 중 사용되는 BankAccount 캡슐화 예제 코드 전체입니다. 수강생이 직접 타이핑하거나 복사하여 실행해볼 수 있도록 배포합니다.

```python
class BankAccount:
    def __init__(self, owner: str, balance: int):
        self.owner = owner
        self.__balance = balance  # 비공개 속성 (밑줄 두 개)

    def deposit(self, amount: int) -> None:
        if amount > 0:
            self.__balance += amount
            print(f"정상 처리: {amount}원 입금 완료. 현재 잔액: {self.__balance}원")
        else:
            print("오류: 입금액은 0원보다 커야 합니다.")

    def get_balance(self) -> int:
        return self.__balance

# 실행 및 테스트
my_account = BankAccount("홍길동", 10000)

# 1. 정상적인 입금
my_account.deposit(5000)

# 2. 잘못된 금액 입금 시도 (캡슐화된 메서드의 검증)
my_account.deposit(-2000)

# 3. 외부에서 직접 접근 시도 (실패함)
# print(my_account.__balance)  # AttributeError 발생!
print(f"조회된 잔액: {my_account.get_balance()}원")
```

---

## §6. 요약

### 핵심 학습 포인트

이번 세션의 핵심은 "통합과 보호"입니다. 
1. **부서 조직 재편 (리팩토링)**: 흩어져 있던 데이터와 함수를 하나의 클래스 안으로 모아 결합도를 높입니다.
2. **자동차 페달 (캡슐화)**: 모아둔 데이터 중 보호해야 할 것은 `__`를 통해 숨기고, 안전한 통로(메서드)만 외부에 열어줍니다.

### 다음 세션 예고

> "조직 개편의 명분과 이론은 이제 충분히 갖춰졌습니다. 머리로 이해한 캡슐화와 클래스 개념을 우리의 실제 프로젝트에 투입할 시간이에요. 다음 세션에서는 절차적으로 짜여 있던 v2 버전의 고객 관리 프로그램을, 오늘 배운 원리를 총동원해 세련된 객체지향 아키텍처 v3로 탈바꿈시켜 보겠습니다. 기대하셔도 좋습니다!"

---

### 교안 원문

> **[시스템 요구사항 반영]** 아래는 본 세션 설계의 바탕이 된 원본 v1.0 마크다운 교안의 전문입니다. 슬라이드 프롬프트 생성 파이프라인(P06) 처리 시 전체 컨텍스트 확보용으로 사용됩니다.

````markdown
# 세션 090: 객체지향 리팩토링과 캡슐화 개념

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-090 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | narrative |
| **선행 세션** | 085 (권장), 089 (필수) |
| **학습 목표** | 객체지향 리팩토링의 목적과 '캡슐화'의 개념을 '부서 조직 재편'과 '자동차 운전' 비유를 통해 설명할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 캡슐화와 접근 제어 · [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입: "데이터와 기능이 아직도 따로 놀고 있습니다"

🗣️ 강사 대본 (Instructor Script):

여러분, Day 4에서 만들었던 `customer_manager_v2.py` 기억나시나요? 함수로 깔끔하게 나눠서 뿌듯했었죠. `add_customer()`, `find_customer()`, `update_customer()`, `delete_customer()`. 기능별로 함수를 분리했으니 절차적 코드보다 훨씬 나아졌습니다. 그런데 한 가지 찜찜한 점이 남아 있었어요. 파일 맨 위에 떡하니 자리 잡고 있는 `customers = []`라는 전역 변수, 보이시나요? 이 리스트 하나를 여러 함수가 돌려가며 쓰고 있습니다. 비유하자면, 회사에 "자료 보관실"과 "업무 실행팀"이 물리적으로 다른 건물에 있어서, 직원들이 종일 서류 뭉치를 들고 왔다 갔다 뛰어다니는 꼴입니다. 오늘은 이 비효율적인 구조에 대대적인 조직 개편을 선언할 시간입니다.

---

## ② 비유: 부서 조직 재편과 자동차 운전

🗣️ 강사 대본 (Instructor Script):

비유를 두 가지 드리겠습니다. 첫 번째는 "부서 조직 재편"입니다 [Source A]. 지금까지 우리 회사(프로그램)에는 "자료 보관실(전역 변수 `customers`)"이 1층에 있고, "업무 실행팀(함수들)"이 3층에 있었습니다. 고객을 등록하려면 3층 직원이 1층까지 내려가서 서류함을 열고, 새 서류를 넣고, 다시 3층으로 올라와야 합니다. 조회할 때도, 수정할 때도, 삭제할 때도 매번 1층과 3층을 왕복합니다. 직원들이 지칠 수밖에 없죠.

객체지향 리팩토링은 이 구조를 완전히 뒤엎습니다 [Source B]. "고객 관리팀(CustomerManager 클래스)"이라는 새 부서를 만들고, 이 부서 안에 자료 보관함(데이터)과 업무 담당자(메서드)를 모두 배치하는 겁니다. 이제 고객 등록이 필요하면 고객 관리팀 안에서 바로 처리됩니다. 서류를 들고 건물 사이를 뛰어다닐 필요가 없어요. 데이터와 기능이 한 지붕 아래 모이는 것, 이것이 객체지향의 핵심입니다.

두 번째 비유는 "자동차 운전"입니다 [Source A][Source C]. 여러분이 자동차를 운전할 때, 엔진이 몇 기통인지, 연료 분사 타이밍이 어떻게 되는지, 변속기 기어비가 얼마인지 알아야 하나요? 전혀 몰라도 됩니다. 가속 페달을 밟으면 차가 앞으로 가고, 브레이크를 밟으면 멈추고, 핸들을 돌리면 방향이 바뀝니다. 복잡한 내부 구조는 철저히 숨겨져 있고, 운전자에게는 페달과 핸들이라는 단순한 인터페이스만 제공됩니다.

이것이 바로 캡슐화(Encapsulation)입니다 [Source C]. 객체 내부의 데이터를 외부에서 직접 만지지 못하게 숨기고, 오직 정해진 메서드(페달, 핸들)를 통해서만 조작할 수 있게 만드는 기술이에요. 왜 이렇게 할까요? 안전 때문입니다. 운전 중에 누군가 엔진 뚜껑을 열고 부품을 만지면 사고가 나듯이, 프로그램에서도 외부 코드가 객체의 내부 데이터를 마음대로 바꾸면 예상치 못한 버그가 발생합니다. 캡슐화는 이런 "휴먼 에러"를 구조적으로 차단하는 안전장치입니다.

재미있는 점은, 우리가 매일 쓰는 AI도 캡슐화의 혜택을 받고 있다는 사실입니다. 여러분이 ChatGPT나 Claude에게 질문할 때, 트랜스포머 아키텍처의 어텐션 메커니즘이 어떻게 작동하는지 알 필요가 없잖아요? "프롬프트"라는 아주 직관적인 인터페이스만으로 거대한 AI 엔진을 굴리고 있는 겁니다. 캡슐화는 프로그래밍만의 개념이 아니라, 복잡한 세상을 단순하게 다루기 위한 보편적인 설계 철학입니다.

---

## ③ 개념 설명: 리팩토링과 캡슐화의 정의

🗣️ 강사 대본 (Instructor Script):

용어를 정확히 정리하겠습니다. 리팩토링(Refactoring)이란 프로그램의 외부 동작은 그대로 유지하면서, 내부 구조만 개선하는 작업입니다 [Source A]. 고객 등록, 조회, 수정, 삭제. 사용자가 보는 기능은 하나도 바뀌지 않지만, 코드의 뼈대가 더 튼튼하고 읽기 쉽게 바뀌는 거예요. 집의 외관은 그대로인데 내부 배관과 전기 배선을 새로 깔아서 더 안전하고 효율적으로 만드는 리모델링과 같습니다.

캡슐화(Encapsulation)는 객체의 내부 데이터를 외부로부터 보호하고, 정해진 메서드를 통해서만 접근하도록 제한하는 원칙입니다 [Source B][Source C]. 파이썬에서는 속성 이름 앞에 밑줄 두 개(`__`)를 붙이면 외부에서 직접 접근하기 어려운 비공개(private) 속성이 됩니다. 예를 들어 `self.__balance`라고 선언하면, 객체 바깥에서 `account.__balance`로 직접 값을 바꿀 수 없습니다. 반드시 `account.deposit(10000)` 같은 메서드를 통해야만 잔액을 변경할 수 있죠.

따라서 객체지향 리팩토링의 핵심 공식은 이렇습니다. "데이터와 그 데이터를 다루는 로직을 하나의 클래스에 묶고, 외부의 무분별한 접근을 막는다." 이 한 문장이 오늘 세션의 전부입니다.

---

## ④ 코드로 보는 캡슐화 맛보기

🗣️ 강사 대본 (Instructor Script):

간단한 예시 하나만 보고 가겠습니다.

```python
class BankAccount:
    def __init__(self, owner: str, balance: int):
        self.owner = owner
        self.__balance = balance  # 비공개 속성 (밑줄 두 개)

    def deposit(self, amount: int) -> None:
        if amount > 0:
            self.__balance += amount

    def get_balance(self) -> int:
        return self.__balance
```

`self.__balance`는 밑줄 두 개로 시작하기 때문에 외부에서 `account.__balance = -9999` 같은 위험한 조작이 차단됩니다 [Source A]. 잔액을 바꾸려면 반드시 `deposit()` 메서드를 거쳐야 하고, 이 메서드 안에는 `amount > 0`이라는 검증 로직이 들어 있어서 음수 입금 같은 말도 안 되는 상황을 원천 봉쇄합니다. 이것이 캡슐화의 실전적 가치입니다. 데이터를 안전하게 지키면서도, 사용하는 쪽에서는 편리한 메서드만 호출하면 됩니다.

---

## ⑤ 정리: "조직 개편의 명분은 충분합니다"

🗣️ 강사 대본 (Instructor Script):

오늘 배운 두 가지를 정리합니다. 첫째, 객체지향 리팩토링은 흩어진 데이터와 기능을 하나의 클래스로 모아서 코드를 튼튼하게 만드는 "부서 조직 재편"입니다. 둘째, 캡슐화는 내부 데이터를 숨기고 메서드라는 안전한 통로만 열어두는 "자동차 페달" 설계입니다. 이 두 무기가 우리 코드를 얼마나 강력하게 만드는지, 다음 세션에서 직접 체험하실 겁니다. 어제의 낡은 v2 코드를 최첨단 v3 코드로 멋지게 리팩토링하러 가봅시다!
````

---

## §7. 참고 자료

### 3-Source 출처

- **Source A (로컬 참고자료)**: `8 코딩.pdf` §8.14 캡슐화와 접근 제어. 부서 조직 재편 및 자동차 운전 비유의 원형, 데이터 영속화 전반의 이론적 배경 제공.
- **Source B (NotebookLM)**: `day5_notebooklm.md`. 전역 변수의 위험성을 해결하기 위한 객체지향 리팩토링의 필요성 논리 전개.
- **Source C (Deep Research)**: `day5_deep_research.md`. 캡슐화와 OOP 리팩토링의 실전 예제, `BankAccount` 클래스를 통한 캡슐화 실습 코드 제공.

### 강사 노트

> 💡 **강사 노트**: 본 세션은 본격적인 `CustomerManager` v3 코드 작성 이전에 개념을 먼저 탄탄히 잡는 이론/비유 중심의 시간입니다. 특히 "전역 변수의 위험성"을 수강생들이 체감하게 만드는 것이 핵심입니다. 코딩 입문자는 종종 "기존 코드도 잘 도는데 왜 굳이 복잡하게 클래스를 쓰나요?"라고 묻기 때문입니다. 자동차 엔진과 페달 비유를 사용할 때, 핸들 모션을 직접 손으로 취하면서 설명하면 훨씬 생동감 있는 진행이 가능합니다.

---

## ✅ 세션 완료 체크리스트 (강사용)

- [x] §1~§7 모든 섹션이 충실하게 작성되었는가?
- [x] 부서 조직 재편 및 자동차 운전 비유가 효과적으로 전달되었는가?
- [x] 전역 변수의 위험성과 캡슐화의 목적이 연결되었는가?
- [x] 파이썬의 비공개 속성(`__`)을 BankAccount 예제로 확인했는가?
- [x] 3-Source 팩트 패킷 내용이 충실히 반영되었는가?

---

*작성 일시: 2026-02-25*  
*작성 에이전트: Sisyphus-Junior*  
*교안 구조: 7섹션 (A0 팀 공통 표준)*