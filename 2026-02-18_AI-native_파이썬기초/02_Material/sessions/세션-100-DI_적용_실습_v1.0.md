# 세션 100: DI 적용 실습 (v4 저장소 교체 테스트)

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-100 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | lab |
| **선행 세션** | 099 (필수) |
| **학습 목표** | 비즈니스 로직 수정 없이 저장 방식을 JSON 파일에서 SQLite DB로 교체하는 DI 패턴을 실습할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 DI 패턴 · [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입 — "나사 구멍에 블록을 끼워 봅시다"

🗣️ 강사 대본 (Instructor Script):

여러분, 지난 두 세션에서 `JsonFileStorage`와 `SQLiteStorage`라는 두 개의 저장소 블록을 만들었습니다. 그리고 세션 097에서 `CustomerManager`에 "나사 구멍(storage 매개변수)"을 뚫어 놓았죠. 오늘은 드디어 이 나사 구멍에 블록을 끼워 보는 실습 시간입니다. 파일 저장 블록을 끼우면 파일에 저장되고, DB 블록을 끼우면 DB에 저장됩니다. `CustomerManager`의 코드는 단 한 줄도 바꾸지 않습니다. 이것이 DI의 진정한 위력입니다.

---

## ② 비유 — 나사 구멍 뚫어주기

🗣️ 강사 대본 (Instructor Script):

레고 블록을 떠올려 보세요 [Source A][Source B]. 레고의 핵심은 뭘까요? 모든 블록의 돌기와 구멍 크기가 표준화되어 있다는 겁니다. 빨간 블록이든 파란 블록이든, 돌기 크기가 같으니 어디든 끼울 수 있습니다. 우리의 `Storage` 기반 클래스가 바로 이 "표준 돌기 규격"입니다. `save()`와 `load()`라는 표준 인터페이스만 지키면, 어떤 저장소든 `CustomerManager`에 끼울 수 있습니다.

이것이 아키텍처의 힘입니다 [Source C]. 코드를 짤 때 "지금 당장 필요한 기능"만 생각하면 나중에 변경이 어렵습니다. 하지만 "나중에 바뀔 수 있는 부분"을 미리 분리해 두면, 변경이 필요할 때 블록만 갈아 끼우면 됩니다. AI에게 "저장소를 교체 가능하게 설계해줘"라고 한마디 추가하는 것만으로, 미래의 유지보수 비용을 획기적으로 줄일 수 있습니다.

---

## ③ 개념 확인 — v4 아키텍처 전체 그림

🗣️ 강사 대본 (Instructor Script):

우리가 만든 v4 아키텍처의 전체 그림을 정리하겠습니다 [Source A][Source C]. 맨 위에 `Storage` 기반 클래스가 있고, 이것을 상속받은 `JsonFileStorage`와 `SQLiteStorage`가 있습니다. `CustomerManager`는 `Storage` 타입만 알고 있으며, 생성 시 외부에서 구체적인 저장소를 주입받습니다. `Customer`와 `VIPCustomer`는 데이터 모델을 담당합니다. 각 클래스가 자기 역할에만 집중하고, 서로의 내부를 모르는 깔끔한 구조입니다.

---

## ④ 실습 — 저장소 교체 체험

🎙️ 실습 가이드 (Lab Guide):

총 4단계로 진행합니다.

**1단계 (5분) — JSON 저장소로 실행**: `CustomerManager`에 `JsonFileStorage`를 주입하고 고객 3명을 등록한 뒤 저장합니다.

```python
# JSON 파일 저장소 주입
file_storage = JsonFileStorage("customers.json")
manager = CustomerManager(file_storage)

manager.add(Customer("홍길동", "010-1111-2222", "hong@mail.com"))
manager.add(Customer("김영희", "010-3333-4444", "kim@mail.com"))
manager.add(Customer("박민수", "010-5555-6666", "park@mail.com"))
manager.save_all()  # JSON 파일에 저장
```

**2단계 (5분) — DB 저장소로 교체**: `CustomerManager` 코드는 한 글자도 수정하지 않고, 저장소만 `SQLiteStorage`로 바꿉니다.

```python
# DB 저장소로 교체 — CustomerManager 코드 변경 없음!
db_storage = SQLiteStorage("customers.db")
manager2 = CustomerManager(db_storage)

manager2.add(Customer("이순신", "010-7777-8888", "lee@mail.com"))
manager2.save_all()  # SQLite DB에 저장
```

**3단계 (5분) — 파일 확인**: 프로젝트 폴더에 `customers.json`과 `customers.db` 파일이 모두 생성되었는지 확인합니다. JSON 파일은 텍스트 에디터로 열어서 내용을 읽어 보세요.

**4단계 (5분) — 감탄 타임**: `CustomerManager`의 코드를 다시 열어 보세요. 저장소에 대한 코드가 단 한 줄도 없습니다. 오직 `self._storage.save()`와 `self._storage.load()`만 호출할 뿐이에요. 저장소가 파일인지 DB인지 클라우드인지 전혀 모릅니다. 이것이 DI의 마법입니다.

---

## ⑤ 정리 — "블록을 갈아 끼우는 아키텍처"

🗣️ 강사 대본 (Instructor Script):

놀랍지 않나요? `CustomerManager` 코드는 단 한 줄도 바꾸지 않았는데, 블록을 갈아 끼우듯 데이터베이스가 바뀌었습니다. 이것이 아키텍처의 힘이고, 의존성 주입(DI)의 진정한 가치입니다. 우리의 고객관리 프로그램은 이제 v1(절차적) → v2(구조적) → v3(OOP) → v4(DI + 아키텍처)까지 진화했습니다. 다음 세션에서는 이 5일간의 진화 과정을 한눈에 되돌아보는 총정리 시간을 갖겠습니다!
