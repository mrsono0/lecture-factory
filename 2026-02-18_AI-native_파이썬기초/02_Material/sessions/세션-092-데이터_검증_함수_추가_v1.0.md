# 세션 092: 데이터 검증 함수 추가

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-092 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | code |
| **선행 세션** | 091 (필수) |
| **학습 목표** | AI 프롬프트를 활용하여 올바르지 않은 이메일과 전화번호 형식을 걸러내는 '데이터 검증 함수'를 생성하고 CustomerManager 클래스에 통합할 수 있다 |
| **출처** | [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입 — "사용자를 너무 믿지 마세요"

🗣️ 강사 대본 (Instructor Script):

여러분, 방금 만든 v3 고객관리 프로그램에 고객을 등록해 봅시다. 이름에 빈칸을 넣어 보세요. 저장됩니다. 전화번호에 "가나다라마바사"를 넣어 보세요. 역시 저장됩니다. 이메일에 "골뱅이없는주소"를 넣어 보세요. 또 저장됩니다. 우리 프로그램은 지금 너무 착합니다. 뭘 넣어도 "네, 알겠습니다!" 하고 받아주는 거예요. 현실 세계에서 이런 시스템을 운영하면 어떻게 될까요? 나중에 고객에게 문자를 보내려는데 전화번호가 "가나다라"이니 시스템이 펑 하고 터져버립니다. 사용자는 상상을 초월하는 입력을 합니다. 그래서 우리에게는 "깐깐한 문지기"가 필요합니다.

---

## ② 비유 — 클럽의 깐깐한 문지기

🗣️ 강사 대본 (Instructor Script):

비유를 하나 들어 볼게요 [Source B]. 고급 클럽 입구에는 항상 깐깐한 문지기(Bouncer)가 서 있습니다. 이 문지기는 드레스 코드를 철저히 검사합니다. 운동화 신고 왔으면 "입장 불가!", 신분증 없으면 "입장 불가!", 나이가 미달이면 "입장 불가!" — 규칙에 맞지 않으면 가차 없이 돌려보냅니다. 덕분에 클럽 안은 항상 질서가 유지되죠.

우리 프로그램에도 이런 문지기를 세워야 합니다 [Source C]. "이메일에 골뱅이(@)가 없으면 입장 불가!", "전화번호가 010-XXXX-XXXX 형식이 아니면 입장 불가!", "이름이 빈칸이면 입장 불가!" — 이런 규칙을 코드로 만드는 것을 데이터 검증(Validation)이라고 합니다. 개발 세계에서는 이것을 방어적 프로그래밍(Defensive Programming)이라고도 부릅니다. "사용자가 올바른 데이터를 넣어줄 거야"라고 낙관하지 말고, "사용자는 반드시 이상한 데이터를 넣을 것이다"라고 비관적으로 가정하고 미리 방어하는 전략이에요.

옛날에는 이메일 형식을 검사하는 복잡한 정규표현식(Regular Expression)을 개발자가 직접 외워서 작성해야 했습니다. 하지만 AI 시대에는 다릅니다. AI에게 "이메일 형식 검사하는 함수 만들어줘"라고 한마디만 하면 끝입니다. 우리가 해야 할 일은 "어떤 규칙으로 검사할 것인지" — 즉 명세(Specification)를 명확하게 정의하는 것뿐입니다. 이것이 바로 명세 주도 개발(SDD)의 핵심이죠.

---

## ③ 개념 설명 — 데이터 검증과 @property

🗣️ 강사 대본 (Instructor Script):

데이터 검증을 구현하는 방법은 여러 가지가 있지만, 파이썬에서 가장 우아한 방법은 `@property` 데코레이터를 사용하는 것입니다 [Source B][Source C]. `@property`를 쓰면 외부에서는 마치 일반 변수처럼 `customer.age = 25`라고 쓸 수 있지만, 내부적으로는 검증 로직이 자동으로 실행됩니다. 변수처럼 보이지만 실제로는 함수가 돌아가는 거예요 — 마치 자동문처럼, 그냥 걸어가면 문이 알아서 열리지만 사실 센서가 작동하고 있는 것과 같습니다.

구체적으로 보면, `@property`는 getter(값을 읽는 함수)를 만들고, `@속성이름.setter`는 setter(값을 쓰는 함수)를 만듭니다. setter 안에 검증 로직을 넣으면, 누군가 값을 바꾸려 할 때마다 자동으로 검증이 실행됩니다. 나이에 -10을 넣으려 하면 `ValueError`가 발생해서 저장이 거부되는 식이죠.

---

## ④ 코드 — 검증 로직 구현

🗣️ 강사 대본 (Instructor Script):

코드로 확인해 봅시다.

```python
import re

class Customer:
    def __init__(self, name: str, phone: str, email: str):
        self.name = name      # setter를 통해 검증됨
        self.phone = phone    # setter를 통해 검증됨
        self.email = email    # setter를 통해 검증됨

    @property
    def phone(self) -> str:
        return self._phone

    @phone.setter
    def phone(self, value: str) -> None:
        pattern = r"^010-\d{4}-\d{4}$"
        if not re.match(pattern, value):
            raise ValueError(f"전화번호 형식 오류: {value} (010-XXXX-XXXX)")
        self._phone = value

    @property
    def email(self) -> str:
        return self._email

    @email.setter
    def email(self, value: str) -> None:
        if "@" not in value:
            raise ValueError(f"이메일 형식 오류: {value} (@가 필요합니다)")
        self._email = value
```

`@phone.setter` 안에 정규표현식 `r"^010-\d{4}-\d{4}$"`이 들어 있습니다. 이 패턴은 "010으로 시작하고, 하이픈 뒤에 숫자 4자리, 또 하이픈 뒤에 숫자 4자리"를 의미합니다. 이 형식에 맞지 않으면 `ValueError`를 발생시켜 저장을 거부합니다.

🎙️ 실습 가이드 (Lab Guide):

AI에게 이렇게 요청해 보세요. "전화번호 형식(010-0000-0000)과 이메일 형식(@포함)을 검사하는 `@property` setter를 Customer 클래스에 추가해줘." 생성된 코드를 v3 파일에 통합하고, 의도적으로 이메일에 "abc", 전화번호에 "0101234"를 입력해 보세요. 오류 메시지와 함께 저장이 거부되는 것을 확인하면 성공입니다.

---

## ⑤ 정리 — "문지기가 세워졌습니다"

🗣️ 강사 대본 (Instructor Script):

이제 우리 프로그램에 깐깐한 문지기가 배치되었습니다. 엉터리 전화번호도, 골뱅이 없는 이메일도 더 이상 통과할 수 없습니다. `@property`와 setter를 활용하면 밖에서는 변수처럼 편하게 쓰면서도, 안에서는 강력한 검증을 자동으로 수행할 수 있다는 것을 기억해 주세요. 그런데 한 가지 걱정이 남아 있습니다. 문지기가 정문을 지키고 있지만, 만약 코드를 짜는 개발자가 `customer._phone = "가나다"`처럼 뒷문으로 몰래 들어오면 어쩌죠? 다음 세션에서 캡슐화를 통해 뒷문까지 철저하게 잠가 보겠습니다!
