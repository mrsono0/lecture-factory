# 세션 096: 다형성 체험

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-096 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | lab |
| **선행 세션** | 095 (필수) |
| **학습 목표** | 메서드 오버라이딩을 통한 다형성을 체험하고, 같은 인터페이스로 다른 동작을 수행하는 코드를 작성할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 다형성 · [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입 — "같은 버튼, 다른 결과"

🗣️ 강사 대본 (Instructor Script):

여러분, 집에 리모컨이 몇 개 있으신가요? TV 리모컨, 에어컨 리모컨, 셋톱박스 리모컨... 리모컨마다 생김새는 다르지만, 공통적으로 "전원 버튼"이 있습니다. TV 리모컨의 전원 버튼을 누르면 TV가 켜지고, 에어컨 리모컨의 전원 버튼을 누르면 에어컨이 켜집니다. 같은 "전원 버튼"이라는 인터페이스인데, 누르는 대상에 따라 완전히 다른 결과가 나옵니다. 이것이 바로 다형성(Polymorphism)의 핵심입니다. 오늘은 이 "같은 명령, 다른 결과"를 코드로 직접 체험해 보겠습니다.

---

## ② 비유 — 리모컨의 전원 버튼

🗣️ 강사 대본 (Instructor Script):

비유를 좀 더 깊이 들어가 볼게요 [Source A][Source B]. 만능 리모컨이 하나 있다고 상상해 봅시다. 이 리모컨에는 "할인율 계산" 버튼이 딱 하나 있습니다. 이 버튼을 일반 고객에게 향해 누르면 "할인 없음(0%)"이 나오고, VIP 고객에게 향해 누르면 "10% 할인"이 나오고, VVIP 고객에게 향해 누르면 "20% 할인"이 나옵니다. 리모컨(호출하는 코드)은 하나인데, 대상(객체)에 따라 결과가 달라지는 거예요.

이것이 프로그래밍에서 엄청나게 강력한 이유가 있습니다 [Source C]. `CustomerManager`가 고객 목록을 순회하면서 `customer.get_discount()`를 호출할 때, 이 고객이 일반인지 VIP인지 VVIP인지 일일이 확인할 필요가 없습니다. 그냥 `get_discount()`만 호출하면 각 객체가 자기 타입에 맞는 할인율을 알아서 반환합니다. `if customer_type == "VIP": ...` 같은 조건문 지옥에서 해방되는 거예요.

파이썬에서는 이것을 Duck Typing이라고도 부릅니다. "오리처럼 걷고, 오리처럼 꽥꽥거리면, 그것은 오리다." 즉, 객체의 타입이 뭔지보다 "그 객체가 어떤 메서드를 가지고 있는지"가 더 중요합니다. `get_discount()` 메서드만 있으면, 그것이 일반 고객이든 VIP든 로봇이든 상관없이 동작합니다.

---

## ③ 개념 확인 — 다형성이란

🗣️ 강사 대본 (Instructor Script):

다형성(Polymorphism)을 한 문장으로 정의하면 이렇습니다 [Source A][Source C]. "같은 이름의 메서드를 호출했을 때, 객체의 실제 타입에 따라 다른 동작이 실행되는 것." 이것이 가능한 이유는 오버라이딩 때문입니다. 부모 클래스에 `get_discount()`를 정의해 두고, 각 자식 클래스에서 자기만의 방식으로 재정의하면, 호출하는 쪽에서는 타입을 신경 쓰지 않고 동일한 메서드 이름만 사용하면 됩니다.

다형성의 실전적 가치는 확장성입니다 [Source B]. 나중에 "기업 고객(CorporateCustomer)"이라는 새 등급이 추가되어도, `get_discount()`만 오버라이딩하면 기존 코드를 한 줄도 수정하지 않고 새 등급이 자연스럽게 동작합니다. 이것을 개방-폐쇄 원칙(OCP: Open-Closed Principle)이라고 부릅니다 — "확장에는 열려 있고, 수정에는 닫혀 있다."

---

## ④ 실습 — 다형성 체험

🎙️ 실습 가이드 (Lab Guide):

직접 체험해 봅시다. 총 3단계입니다.

**1단계 (5분) — 일반 고객에 get_discount 추가**: `Customer` 클래스에 `get_discount()` 메서드를 추가합니다. 일반 고객은 할인이 없으므로 `0.0`을 반환합니다.

```python
class Customer:
    # ... 기존 코드 ...
    def get_discount(self) -> float:
        return 0.0  # 일반 고객: 할인 없음

class VIPCustomer(Customer):
    # ... 기존 코드 ...
    def get_discount(self) -> float:
        return self.discount_rate  # VIP: 10% 할인
```

**2단계 (10분) — 다형성 확인**: 일반 고객과 VIP 고객을 섞어서 하나의 리스트에 넣고, 반복문으로 `get_discount()`를 호출합니다.

```python
def process_discount(customer: Customer) -> None:
    discount = customer.get_discount()
    print(f"{customer.name}: {discount:.0%} 할인")

customers = [
    Customer("홍길동", "hong@mail.com", 30),
    VIPCustomer("김VIP", "vip@mail.com", 40, 0.1),
    Customer("박일반", "park@mail.com", 25),
]

for c in customers:
    process_discount(c)  # 같은 함수, 다른 결과!
```

**3단계 (5분) — 새 등급 추가 도전**: AI에게 "VVIPCustomer 클래스를 만들어줘. VIPCustomer를 상속받고, 할인율 기본값을 20%로 설정해줘"라고 요청하세요. 만들어진 VVIP 객체를 위 리스트에 추가하고 다시 실행해 보세요. `process_discount()` 함수를 한 글자도 수정하지 않았는데 VVIP 할인율이 정상 출력되는 것을 확인합니다.

---

## ⑤ 정리 — "하나의 명령, 무한한 가능성"

🗣️ 강사 대본 (Instructor Script):

오늘의 핵심입니다. 다형성은 "같은 메서드 이름, 다른 동작"을 가능하게 하는 OOP의 꽃입니다. 리모컨 전원 버튼 하나로 TV도 켜고 에어컨도 켜듯이, `get_discount()` 하나로 일반 고객, VIP, VVIP 모두를 처리할 수 있습니다. 새로운 등급이 추가되어도 기존 코드를 수정할 필요가 없다는 것이 가장 강력한 장점이죠. 자, 이제 OOP의 3대 기둥 — 캡슐화, 상속, 다형성 — 을 모두 익혔습니다. 다음 세션에서는 한 단계 더 나아가, 프로그램의 "뼈대(아키텍처)"를 설계하는 의존성 주입(DI)이라는 고급 패턴을 만나 보겠습니다!
