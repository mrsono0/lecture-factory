# 세션 088: 나만의 클래스 만들기 실습

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-088 |
| **소요 시간** | 25분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | lab |
| **선행 세션** | 087 (필수) |
| **학습 목표** | 여러 인스턴스를 생성하고 독립 데이터 관리를 확인할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 OOP 기초 · [Source B] day5_notebooklm.md |

---

## ① 도입 — "공장 가동 시간입니다"

🗣️ 강사 대본 (Instructor Script):

여러분, 지금까지 붕어빵 틀(클래스)을 만들고, 그 안에 반죽과 앙금(`__init__`과 속성)까지 넣는 설계도를 완성했습니다. 설계도만 그려 놓고 공장을 안 돌리면 아무 소용이 없겠죠? 이번 시간은 본격적으로 공장을 가동해서 붕어빵(인스턴스)을 대량 생산하는 실습 시간입니다. 직접 손으로 여러 고객 객체를 만들어 보면서, 정말로 각 인스턴스의 데이터가 독립적인지 눈으로 확인해 보겠습니다. 더 나아가 고객(Customer)이 아닌 완전히 새로운 대상, 예를 들어 학생(Student) 클래스도 직접 설계부터 생성까지 도전해 볼 거예요.

---

## ② 비유 — 부하 직원 고용하기

🗣️ 강사 대본 (Instructor Script):

비유를 하나 더 드릴게요. 어제까지의 절차적 프로그래밍은 마치 사장님 혼자 모든 서류를 들고 뛰어다니는 1인 기업이었습니다 [Source A]. 고객 명단(딕셔너리)을 직접 들고, 등록 함수로 뛰어가고, 조회 함수로 뛰어가고, 수정 함수로 뛰어가야 했죠. 고객이 10명일 때는 괜찮지만, 100명이 되면 사장님은 과로사합니다.

객체지향 프로그래밍에서는 발상이 완전히 다릅니다. "부하 직원(인스턴스)"을 여러 명 고용하는 겁니다. 각 직원은 자기가 맡은 고객의 정보를 자기 안에 품고 있고, 사장님이 "네 고객 정보 내놔!"라고 명령(메서드 호출)만 하면 즉시 대답합니다. 사장님은 서류 뭉치를 들고 뛰어다닐 필요가 없어요 — 그냥 지시만 내리면 됩니다 [Source B].

이것은 AI 시대의 업무 방식과도 정확히 일치합니다. 우리가 AI에게 "이거 해줘, 저거 해줘"라고 지시를 내리듯, 코드 안에서도 객체들에게 "네가 알아서 처리해!"라고 위임하는 방식으로 프로그래밍 패러다임이 진화한 거예요. 지시하는 법을 아는 사람이 곧 유능한 관리자이자 유능한 프로그래머입니다.

오늘 실습에서는 이 "위임의 쾌감"을 직접 느껴 보시길 바랍니다. 복잡한 로직을 내가 짜는 게 아니라, 객체에게 시키고 결과만 받는 편안함 말이에요. 딕셔너리를 일일이 조작하던 어제의 피로가 확 풀리는 순간을 경험하실 겁니다.

---

## ③ 개념 확인 — 인스턴스 생성과 독립성

🗣️ 강사 대본 (Instructor Script):

실습에 들어가기 전에 핵심 원리를 한번 더 짚겠습니다. 인스턴스를 생성하려면 클래스 이름 뒤에 괄호를 붙이고, `__init__`이 요구하는 매개변수를 순서대로 넣어주면 됩니다 [Source A]. `customer1 = Customer("홍길동", "010-1234-5678", "hong@mail.com")`처럼요. 이 한 줄이 실행되는 순간, 파이썬은 메모리에 새로운 공간을 할당하고 `__init__`을 자동 호출해서 이름, 전화번호, 이메일을 세팅합니다.

가장 중요한 점은 독립성입니다. `customer1`과 `customer2`는 같은 클래스에서 태어났지만, 메모리상에서 완전히 별개의 존재입니다 [Source B]. `customer1.name = "이몽룡"`이라고 바꿔도 `customer2.name`은 여전히 "김철수"입니다. 딕셔너리 리스트에서 인덱스를 잘못 집어 다른 고객의 데이터를 덮어쓰는 악몽은 이제 과거의 일이 됩니다.

메서드 호출도 아주 직관적입니다. `customer1.display()`라고 적으면, 파이썬이 `customer1`을 `self`에 자동으로 넣어 주므로 `self.name`은 `customer1`의 이름이 됩니다. 호출할 때 `self`를 직접 넣지 않는다는 규칙, 기억하시죠? 그리고 메서드 뒤에 괄호 `()`를 빠뜨리면 메서드 자체가 실행되지 않고 메서드 객체만 반환되니까, 꼭 괄호를 붙여야 합니다.

---

## ④ 실습 — 고객 3명 + 학생 클래스 도전

🎙️ 실습 가이드 (Lab Guide):

자, 본격적으로 실습을 시작합니다. 총 4단계로 진행하겠습니다.

**1단계 (5분) — 고객 인스턴스 3명 생성**: 이전 세션에서 만든 Customer 클래스 아래에 `customer1`, `customer2`, `customer3` 변수를 만들고 3명의 고객 데이터를 넣어 보세요. 이름, 전화번호, 이메일을 각기 다르게 설정합니다.

```python
customer1 = Customer("홍길동", "010-1111-2222", "hong@mail.com")
customer2 = Customer("김영희", "010-3333-4444", "kim@mail.com")
customer3 = Customer("박민수", "010-5555-6666", "park@mail.com")
```

**2단계 (5분) — 메서드 호출과 독립성 확인**: 3명 각각에 대해 `.display()`를 호출하고 코드를 실행해 결과를 확인합니다. 각 고객의 정보가 섞이지 않고 제대로 출력되는지 확인하세요.

**3단계 (10분) — 새로운 Student 클래스 도전**: 이번엔 혼자 해볼 차례입니다. AI에게 이렇게 요청해 보세요. "학생(Student) 클래스를 만들어줘. 속성은 이름, 학번, 성적 목록이고, 평균 성적을 계산하는 메서드를 포함해줘." 출력된 코드를 복사해서 실행하고, 학생 2명의 인스턴스를 만들어 평균 점수가 제대로 나오는지 테스트합니다.

**4단계 (5분) — 딕셔너리 방식과 비교 토론**: 작성된 코드를 보면서 딕셔너리로 학생을 관리할 때와 비교해 어떤 점이 더 직관적인지 옆 사람과 짧게 이야기 나눠 보세요. 객체지향의 장점, 특히 데이터와 행위가 하나로 묶여 있다는 점을 체감하셨다면 성공입니다.

---

## ⑤ 정리 — "객체는 스스로 행동한다"

🗣️ 강사 대본 (Instructor Script):

실습 수고하셨습니다! 오늘 가장 중요한 깨달음은 이것입니다 — 객체는 자기 데이터를 자기 안에 품고, 스스로 행동할 수 있습니다. 딕셔너리처럼 수동으로 값을 꺼내서 함수에 넘기는 번거로움이 사라졌죠. 철수, 영희, 민수 각각이 자기 정보를 완벽하게 기억하고 있고, "자기소개 해봐!"라는 한마디에 스스로 대답합니다. 그런데 `__init__`에서 `self.name = name`, `self.phone = phone`을 계속 반복해서 치니까 좀 지루하지 않으셨나요? 파이썬에는 이 반복 타이핑을 마법처럼 없애주는 최신 문법이 있습니다. 다음 세션에서 `@dataclass`라는 강력한 도구를 만나 보겠습니다!
