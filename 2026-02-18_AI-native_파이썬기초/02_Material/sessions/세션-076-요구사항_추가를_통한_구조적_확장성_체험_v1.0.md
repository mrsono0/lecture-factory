# 세션 076 — 요구사항 추가를 통한 구조적 확장성 체험

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-076 |
| **소요 시간** | 25분 |
| **난이도** | ★★☆ |
| **청크 타입** | lab |
| **선행 세션** | 세션-075 (필수) |
| **학습 목표** | 구조적으로 분리된 v2 코드에 '검색 기능'을 추가하는 프롬프트를 실행하고, 기존 코드에 미치는 영향을 최소화하며 기능이 확장됨을 검증할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.10 · [C] Deep Research §5.1 |

---

## ① 도입 — "새로운 요구사항이라는 불청객"

🗣️ 강사 대본 (Instructor Script):

여러분, 우리가 만든 프로그램이 현장에 배포되었다고 상상해 봅시다. 고객들은 프로그램에 무척 만족하며 잘 사용하고 있습니다. 그런데 배포 후 일주일이 지나자 한 가지 강력한 요청이 들어오기 시작합니다. 매번 전체 고객 목록을 눈으로 훑어보는 것이 너무 힘드니, 이름을 입력하면 그 사람의 정보만 쏙 뽑아서 보여주는 검색 기능을 추가해 달라는 내용입니다. 과거 절차적 프로그래밍으로 만들어진 v1 버전이었다면, 우리는 수백 줄의 코드를 처음부터 끝까지 다시 훑어보며 어느 중간 즈음에 이 검색 로직을 끼워 넣어야 할지 며칠 밤을 새워 고민해야 했을 것입니다. 잘못 끼워 넣었다가는 기존의 결제 시스템이 엉뚱하게 동작하는 재앙이 발생할 수도 있기 때문이죠. 하지만 우리는 이제 구조적인 v2 코드를 가지고 있습니다. 이 견고한 구조가 어떻게 새로운 기능을 부드럽게 품어내는지, 오늘은 AI와 함께 직접 검색 기능을 추가해 보며 구조적 프로그래밍이 제공하는 마법 같은 확장성을 두 손으로 직접 체험해 보겠습니다.

---

## ② 비유 — 멀티탭에 새로운 플러그 꽂기

🗣️ 강사 대본 (Instructor Script):

이 확장성의 원리를 일상생활에서 매일 사용하는 멀티탭과 레고 블록에 비유해 보겠습니다. 집에서 사용 중인 멀티탭을 떠올려 보십시오. 현재 텔레비전, 에어컨, 그리고 컴퓨터가 각각의 구멍에 꽂혀 평화롭게 작동하고 있습니다. 이때 여러분이 새로 산 스마트폰 충전기를 연결하고 싶다면 어떻게 하시나요? 텔레비전의 전선을 자르고 복잡하게 구리선을 꼬아서 충전기를 연결하는 사람은 아무도 없을 것입니다. 그저 멀티탭의 남는 빈 구멍에 충전기 플러그를 톡 하고 꽂아 넣기만 하면 끝납니다. 새로운 기기를 추가했다고 해서 멀티탭에 꽂혀 있던 텔레비전 화면이 꺼지거나 에어컨이 갑자기 멈추는 일은 발생하지 않죠. 각각의 기기가 완벽하게 독립적으로 설계되어 있고, 멀티탭이라는 공통된 인터페이스, 즉 메인 루프를 통해서만 전력을 공급받기 때문입니다.

우리가 작성한 v2 코드도 이 멀티탭과 완벽하게 똑같은 원리로 작동합니다. 기존에 만들어둔 고객 등록, 정보 수정, 결제 기능은 이미 꽂혀 있는 텔레비전이나 에어컨과 같습니다. 이번에 새롭게 추가할 '검색 기능'은 새로운 스마트폰 충전기입니다. 우리는 이 충전기를 작동시키기 위해 기존 가전제품들을 분해할 필요가 전혀 없습니다. 그저 레고 블록을 조립하듯이 `search_customer()`라는 새로운 함수 블록을 하나 예쁘게 깎아서 만들어둔 뒤, 메인 메뉴라는 멀티탭의 4번 메뉴 구멍에 살짝 꽂아주기만 하면 됩니다. 이렇게 다른 부품들에 전혀 손상을 주지 않고 새로운 기능을 무한히 붙여나갈 수 있는 성질을 프로그래밍 세계에서는 확장성이라고 부릅니다. 이 구조적 확장성이야말로 AI가 짜주는 코드들이 점점 더 거대해지는 현대 소프트웨어 산업에서 시스템이 붕괴하지 않고 버틸 수 있게 해주는 가장 강력한 기둥입니다.

---

## ③ 개념 — 격리된 기능과 메인 루프의 연결

🗣️ 강사 대본 (Instructor Script):

방금 비유한 레고 블록의 원리를 조금 더 기술적인 관점에서 분석해 보겠습니다. [Source A] 8 코딩.pdf의 8.10절과 [Source C] Deep Research의 5.1절을 종합해 보면, 기능을 추가할 때 가장 피해야 할 최악의 패턴은 기존의 뼈대를 뒤흔드는 것입니다. 우리가 v2 코드에서 기능을 추가할 때는 명확한 이단계의 공정을 거칩니다. 첫 번째 단계는 새로운 함수를 독립적인 공간에 정의하는 것입니다. 이 공간은 철저하게 격리되어 있기 때문에, 이 안에서 오타가 나거나 오류가 발생하더라도 기존의 다른 함수들에게는 전혀 영향을 미치지 않습니다. 두 번째 단계는 메인 루프의 메뉴 선택 부분에 `elif choice == '4': search_customer()`라는 단 한 줄의 연결고리를 만들어주는 것입니다. 

이것은 매우 경이로운 접근 방식입니다. 개발자는 더 이상 프로그램 전체의 복잡한 톱니바퀴를 모두 이해할 필요가 없습니다. 그저 이번에 추가할 검색 기능이라는 톱니바퀴 하나에만 온전히 집중해서 만들고, 완성된 후에 본체에 끼워 넣기만 하면 됩니다. 만약 기능이 마음에 들지 않으면, 그 부분만 쏙 빼서 버리면 그만입니다. AI 코딩 어시스턴트에게 지시를 내릴 때도 마찬가지입니다. "전체 코드를 다시 짜줘"라고 말하는 대신, "기존 구조는 그대로 유지하고 `search_customer()` 함수만 새로 작성해서 메뉴에 연결해 줘"라고 아주 정밀하고 부분적인 프롬프트를 내릴 수 있게 됩니다. 이렇게 할 때 AI는 훨씬 더 안정적이고 정확한 코드를 만들어냅니다.

---

## ④ 실습 — 검색 기능 추가 및 확장성 검증

🎙️ 실습 가이드 (Lab Guide):

이제 여러분의 화면을 켜고, AI 어시스턴트를 활용하여 우리의 v2 코드에 새로운 검색 기능을 직접 장착해 보겠습니다. 기존 코드가 망가지지 않는지 꼼꼼하게 관찰하며 다음 단계들을 순서대로 진행해 주시기 바랍니다.

| 단계 | 소요 시간 | 수행 작업 | 상세 가이드 |
|------|-----------|-----------|-------------|
| **1단계** | 5분 | 검색 기능 추가 프롬프트 실행 | AI에게 "현재 v2 코드에 이름으로 고객을 찾는 `search_customer()` 함수를 추가하고 메인 메뉴의 4번 항목으로 연결해 줘. 다른 함수는 절대 수정하지 마"라고 입력합니다. |
| **2단계** | 5분 | 변경 범위 확인 및 코드 리뷰 | AI가 생성한 코드를 복사하기 전에, 기존의 `register_user()`나 `process_payment()` 코드가 조금이라도 변경되었는지 두 눈으로 확인합니다. 변경되지 않아야 정상입니다. |
| **3단계** | 5분 | 실행 및 기존 기능 무결성 테스트 | 코드를 실행한 후, 새 기능인 4번 검색 기능을 테스트하기 전에 1번(고객 등록)과 2번(결제) 기능이 예전처럼 잘 작동하는지 먼저 확인합니다. |
| **4단계** | 10분 | 검색 기능 디테일 테스트 | 존재하지 않는 이름을 검색했을 때 프로그램이 멈추지 않고 "결과가 없습니다"라고 부드럽게 대처하는지 확인합니다. |

---

## ⑤ 정리 — 튼튼한 구조가 주는 자유

🗣️ 강사 대본 (Instructor Script):

성공적으로 새로운 기능을 추가하셨나요? 아마 여러분은 다른 기능을 망가뜨릴까 봐 두려워하던 과거와 달리, 아주 홀가분한 마음으로 새로운 기능을 이식하셨을 것입니다. 구조가 탄탄하게 잡혀 있다는 것은 이처럼 개발자에게 무한한 확장과 실험의 자유를 선사합니다.

> **체크포인트**: "프로그램이 구조적으로 탄탄해졌다고 확신하시나요? 자동차를 만들었으면 시승을 해봐야죠!" — 다음 세션에서는 이 멋진 프로그램이 극한의 상황에서도 잘 버티는지, 테스트라는 이름의 혹독한 시승 코스로 여러분을 안내합니다!