# 마이크로 세션: 095 — 기존 클래스 확장하기 (VIPCustomer와 super)

> **세션 ID**: MS-PY101-095
> **소요 시간**: 20분
> **난이도**: medium
> **청크 타입**: lab
> **버전**: v2.1 (7섹션 구조)

---

## §1. 개요

> **Day 5 | AM | 세션 095/106**

### 🎯 학습 목표

이 세션이 끝나면, 수강생은 다음을 할 수 있습니다:

- `super()` 함수를 사용해 부모 클래스의 초기화(`__init__`)를 호출할 수 있다
- 자식 클래스인 `VIPCustomer`에 새로운 속성(할인율 등)을 안전하게 추가할 수 있다
- 메서드 오버라이딩(Overriding)을 통해 부모의 기능을 재정의하여 사용할 수 있다

### 선행 세션 환기

지난 세션(세션-094)에서 우리는 상속의 개념을 처음 만났습니다. `class VIPCustomer(Customer):`라고 적고 그 안에 `pass`만 써넣었는데도, 마치 마법처럼 부모인 `Customer` 클래스의 모든 기능과 속성을 물려받는 것을 확인했죠. 코드 중복을 피할 수 있다는 놀라운 장점을 경험했습니다. 
하지만 생각해보면, 아무 기능도 추가하지 않은 `VIPCustomer`는 이름만 거창할 뿐 일반 `Customer`와 다를 게 하나도 없습니다. VIP라면 할인율도 있어야 하고, 출력을 할 때도 "[VIP]"라는 멋진 딱지가 붙어야 하잖아요? 오늘은 드디어 부모에게 물려받은 재산에 우리만의 새로운 기능을 덧붙이고 수정하는 "클래스 확장"의 마법을 배워보겠습니다.

---

## §2. 핵심 개념 (+ 🗣️ 강사 대본 + Mermaid)

### 부모님 찬스와 가업 리브랜딩

상속받은 클래스에 새로운 속성을 추가하는 과정을 "가업 리브랜딩"에 비유해 볼 수 있어요. 부모님이 30년간 운영해 온 빵집을 물려받아 "프리미엄 베이커리"로 리브랜딩한다고 생각해 보세요. 
가장 먼저 해야 할 일은 무엇일까요? 바로 기존의 훌륭한 레시피, 단골 명단, 그리고 매장 인테리어 같은 부모님의 소중한 자산을 **안전하게 인수인계** 받는 것입니다. 그 기본기 없이 갑자기 트렌디한 마카롱만 만들겠다고 나서면 빵집이 제대로 돌아갈 리 없겠죠. 

파이썬 클래스에서도 마찬가지입니다. 자식 클래스에서 나만의 새로운 속성(할인율)을 추가하려면 새로운 `__init__`을 만들어야 합니다. 그런데 이렇게 새 `__init__`을 만들면 부모의 `__init__`이 덮어씌워져서 사라져 버립니다. 이름이나 이메일 같은 기본 정보 초기화가 통째로 날아가는 대참사가 벌어지는 거죠.
이때 우리를 구원해 줄 아주 든든한 함수가 바로 `super()`입니다. 말 그대로 "부모님 찬스"예요. "부모님이 해놓으신 초기 셋팅을 먼저 싹 불러오고, 그 위에 내 것만 살짝 얹겠다"는 선언입니다.

🗣️ **강사 대본 (Instructor Script)**:

> 여러분, 상속을 받을 때 가장 흔히 하는 실수가 바로 부모의 `__init__`을 무시하고 자식에서 처음부터 끝까지 다시 작성하는 거예요. 이러면 상속을 받는 의미가 절반으로 줄어듭니다. 부모가 수십 줄에 걸쳐 정성껏 짜놓은 초기화 로직을 자식에서 단 한 줄, `super().__init__()`으로 싹 가져올 수 있는데 말이죠. 
> 부모님 찬스는 부끄러운 게 아닙니다. 코딩에서는 코드를 재사용하는 가장 우아한 방법이에요! 부모의 초기화가 끝나고 나면, 그 아랫줄에 여러분이 원하는 VIP만의 특별한 속성, 즉 할인율이나 전용 포인트 같은 걸 추가하면 됩니다. 물려받고, 덧붙이는 것. 이것이 상속의 진정한 묘미입니다.

> 💡 **강사 노트**: 수강생들은 자식 클래스에서 `__init__`을 재정의하는 순간 부모의 `__init__`이 실행되지 않는다는 사실(파이썬의 오버라이딩 특성)을 직관적으로 이해하기 힘들어합니다. `super()`가 이 문제를 해결하는 열쇠임을 명확히 강조해 주세요.

### Mermaid 다이어그램

```mermaid
flowchart TD
    A["Customer (부모 클래스)"] -->|상속| B["VIPCustomer (자식 클래스)"]
    A_init["__init__(name, email, age)"] -.->|super() 로 호출| B_init["__init__(name, email, age, discount_rate)"]
    A_display["display()"] -->|오버라이딩 (재정의)| B_display["display()"]
    
    subgraph "가업 리브랜딩"
        B_init --> C["1. 부모의 속성 인수인계<br>(name, email, age)"]
        B_init --> D["2. 새로운 속성 추가<br>(discount_rate)"]
        B_display --> E["3. 간판 교체<br>[VIP] 홍길동 출력"]
    end
```

---

## §3. 상세 내용

### Why — 왜 super()가 필요한가?

"그냥 자식 클래스의 `__init__` 안에 `self.name = name`, `self.email = email`을 다시 쓰면 안 되나요?"라고 생각하실 수 있습니다. 물론 작동은 합니다. 하지만 만약 나중에 회사 정책이 바뀌어서, `Customer` 클래스에 가입일을 저장하는 `join_date` 속성을 추가해야 한다면 어떻게 될까요? 부모 클래스도 고치고, `VIPCustomer` 클래스도 고치고, 또 다른 자식 클래스인 `GoldCustomer` 클래스도 일일이 다 고쳐야 합니다. 결국 복사-붙여넣기의 지옥이 다시 시작되는 거예요.
하지만 `super()`를 사용해 부모의 `__init__`을 호출하도록 연결해 두면, 부모 클래스 딱 한 곳만 고치면 모든 자식 클래스에 자동으로 변경사항이 반영됩니다.

### What — 오버라이딩(Overriding)이란 무엇인가?

`super()`가 속성을 확장하는 방법이라면, 오버라이딩은 "기능(메서드)을 입맛에 맞게 바꾸는" 방법입니다. 오버라이딩은 단어 그대로 기존에 있던 것을 "덮어쓴다"는 뜻이에요. 
부모의 `display()` 메서드가 평범하게 "[고객] 홍길동"이라고 출력했다면, VIP 고객은 좀 더 특별한 대우를 받아야겠죠? 자식 클래스에서 똑같은 이름인 `display()` 메서드를 다시 만들고 내용물만 살짝 바꿔주면 됩니다. "[VIP] 홍길동 (할인율: 10%)"처럼요. 똑같은 이름의 메서드를 호출했을 때, 파이썬은 항상 부모보다 자식의 메서드를 우선해서 실행합니다. 부모의 옛날 간판을 떼어내고 반짝이는 새 간판을 다는 것과 같아요.

### How — 코드로 어떻게 표현할까?

코드는 아주 직관적입니다.

```python
class VIPCustomer(Customer):
    def __init__(self, name: str, email: str, age: int, discount_rate: float = 0.1):
        super().__init__(name, email, age)  # 부모의 __init__ 실행!
        self.discount_rate = discount_rate  # 자식만의 추가 속성 세팅
```

`super().__init__(name, email, age)`라는 단 한 줄이 마법의 주문입니다. 부모 클래스가 요구하는 기본 재료(이름, 이메일, 나이)를 부모에게 쏙 넘겨주고 처리를 부탁하는 거예요. 그리고 부모가 일을 마치면, 우리는 `discount_rate`라는 우리만의 일을 마저 처리하는 구조입니다.

> ✅ **체크포인트**: 여기까지 이해하셨는지 확인해 볼까요?
> - `VIPCustomer`의 `__init__` 안에서 `super().__init__()`을 부르지 않으면 어떤 일이 벌어질까요? ("부모의 이름, 이메일 같은 기본 정보가 하나도 세팅되지 않아 에러가 발생합니다.")
> - 메서드 오버라이딩은 비유하자면 어떤 행동인가요? ("부모의 낡은 간판을 내리고, 새 간판으로 갈아 끼우는 것!")

### 비교표 — 오버라이딩과 확장의 차이

| 개념 | 동작 방식 | 비유 | 주요 사용 키워드 |
|------|-----------|------|-----------------|
| **기능 상속 (Inheritance)** | 부모의 메서드를 그대로 사용 | 부모님 레시피 그대로 빵 굽기 | `pass` 또는 별도 정의 안 함 |
| **속성 확장 (Extension)** | 부모 초기화 후, 자식만의 속성 추가 | 레시피 물려받고, 마카롱 메뉴 추가 | `super().__init__()` |
| **오버라이딩 (Overriding)** | 자식에서 부모와 같은 이름의 메서드를 재정의 | 옛날 빵집 간판을 새 프리미엄 간판으로 교체 | 부모와 똑같은 메서드 이름 (예: `def display()`) |

---

## §4. 실습 가이드 (+ 🎙️ 실습 대본)

### 실습 목표

이 실습을 통해 수강생은 AI 에이전트의 도움을 받아 `Customer` 클래스를 상속하는 `VIPCustomer` 클래스를 작성하고, `super()`와 오버라이딩을 직접 구현하여 두 객체의 동작 차이를 눈으로 확인합니다.

🎙️ **실습 가이드 대본 (Lab Guide)**:

> 자, 이론으로 배운 내용을 직접 코드로 타이핑하면서 손끝으로 익혀볼 시간입니다. 화면 오른쪽의 Agent Manager를 열어주세요. 오늘은 여러분이 직접 코드를 치기 전에 AI 비서에게 먼저 VIP 고객 클래스의 초안을 만들어 달라고 요청해 볼 거예요. 
> "일반 고객 말고, 할인율이 적용되는 VIP 고객 클래스가 필요한데, super()를 써서 만들어 줄래?"라고 자연스럽게 물어보세요. AI가 짜준 코드를 보면서, 방금 배운 `super().__init__()`과 오버라이딩이 어디에 숨어 있는지 술래잡기하듯 찾아볼 겁니다. 자, 시작해 볼까요?

### 단계별 지시

| 단계 | 소요 시간 | 강사 지시사항 | 학습자 액션 | 예상 결과 |
|------|----------|--------------|------------|----------|
| 1 | 3분 | "AI에게 VIPCustomer 클래스 작성을 요청하세요" | 아래 실습 프롬프트를 Agent Manager에 입력 | `VIPCustomer` 클래스 코드 초안 생성 |
| 2 | 2분 | "IDE에 새 파이썬 파일을 만들고 코드를 붙여넣으세요" | `vip_test.py` 생성 및 복사-붙여넣기 | 코드 준비 완료 |
| 3 | 2분 | "부모와 자식 객체를 각각 하나씩 만드세요" | `c1 = Customer(...)`, `v1 = VIPCustomer(...)` 작성 | 객체 인스턴스 2개 생성 |
| 4 | 2분 | "각 객체의 display() 메서드를 호출하고 결과를 비교하세요" | `c1.display()`, `v1.display()` 실행 | 콘솔에 일반/VIP 출력이 다르게 나타남 |
| 5 | 1분 | "할인율을 바꿔서 출력해보세요" | VIP 객체 생성 시 할인율 0.2 등 인자 전달 | 출력 결과에 새 할인율 반영됨 |

**[단계 1] AI에게 클래스 확장 요청하기**

Agent Manager 채팅창에 다음 프롬프트를 입력하세요:

```text
기존의 Customer 클래스를 상속받아 VIPCustomer 클래스를 만들어줘. 
조건은 다음과 같아:
1. 부모의 __init__을 super()를 이용해 호출할 것
2. VIP만의 속성으로 discount_rate(할인율, 기본값 0.1)를 추가할 것
3. display() 메서드를 오버라이딩해서, 이름 앞에 '[VIP]' 딱지를 붙이고 할인율도 함께 출력할 것
```

AI가 빠르고 정확하게 코드를 뱉어낼 겁니다. 코드를 바로 복사하지 마시고, 우리가 앞서 배운 마법의 주문(`super().__init__`)이 정말 들어있는지 눈으로 꼭 확인하세요!

**[단계 2~3] 객체 생성 및 테스트 준비**

새 파이썬 파일(`vip_test.py` 등)을 만들고, AI가 준 코드(혹은 앞서 작성한 `Customer` 클래스가 포함된 전체 코드)를 붙여넣습니다. 그리고 맨 아래쪽에서 직접 두 명의 고객을 만들어 봅니다.

```python
# 일반 고객
c1 = Customer("홍길동", "hong@test.com", 25)

# VIP 고객 (할인율 0.2, 즉 20%로 설정)
v1 = VIPCustomer("김철수", "kim@test.com", 40, 0.2)
```

**[단계 4] 오버라이딩의 마법 확인하기**

이제 두 고객의 정보를 화면에 출력해 볼 차례입니다. 분명 우리는 두 객체 모두에게 똑같이 `display()`라는 명령을 내릴 거예요. 결과를 확인해 보세요!

```python
c1.display()
v1.display()
```

### 트러블슈팅 FAQ

| Q | A |
|---|---|
| `TypeError: super() takes at least 1 argument` 에러가 납니다. | 파이썬 2.x 방식의 문법을 시도하신 것 같아요. 파이썬 3.x에서는 괄호 안에 아무것도 안 적고 그냥 `super().__init__(...)`이라고만 적으면 됩니다! |
| `TypeError: __init__() missing 1 required positional argument` 에러가 납니다. | `super().__init__()` 괄호 안에 부모가 필요로 하는 인자(name, email, age)를 안 넘겨주셨네요. 빈손으로 부모님을 찾아뵈면 화내십니다! 꼭 재료를 챙겨서 호출해주세요. |
| 오버라이딩한 `display()`에서 자꾸 `self.age`를 못 찾는다고 해요. | 오버라이딩은 부모 메서드를 완전히 무시하고 내 방식대로 새로 짜는 겁니다. 자식 클래스의 `display()` 안에서 문자열 포맷팅에 오타가 났는지 점검해보세요. |
| AI가 `super(VIPCustomer, self).__init__()`처럼 이상하게 길게 써줬어요. | 과거 파이썬 2 버전의 잔재입니다. AI에게 "파이썬 3 최신 문법으로 더 깔끔하게 `super().__init__()`만 쓰게 리팩토링해줘"라고 따끔하게 말해주세요. |
| 할인율이 소수로(0.1) 나오는데 보기 안 좋아요. | 포맷팅 팁! f-string에서 `{self.discount_rate:.0%}`라고 쓰면 `10%`처럼 예쁘게 퍼센트로 변환되어 출력됩니다. |

> ✅ **체크포인트**: `c1`과 `v1` 모두 `display()`라는 똑같은 명령어를 실행했는데, 출력되는 모양새가 다르게 나왔나요? 성공하셨다면 여러분은 상속과 오버라이딩이라는 산을 훌륭하게 넘은 겁니다!

---


### 🎓 강사 노트 (Instructor Support)

- ⏱️ **타이밍**: 13:20 (20분, code)
- 🎯 **핵심 활동**: 부모 클래스 확장
- ⚠️ **강사 주의사항**: super() 호출 패턴

## §5. 코드 및 명령어 모음

### 코드 1: VIPCustomer 전체 구현 코드

```python
class Customer:
    def __init__(self, name: str, email: str, age: int):
        self.name = name
        self.email = email
        self.age = age

    def display(self) -> None:
        print(f"[일반] {self.name} | {self.email} | {self.age}세")

class VIPCustomer(Customer):
    def __init__(self, name: str, email: str, age: int, discount_rate: float = 0.1):
        # 1. 부모님 찬스: 기본 정보는 부모가 초기화하게 넘김
        super().__init__(name, email, age)  
        # 2. 내 것 추가: VIP만의 새로운 속성 초기화
        self.discount_rate = discount_rate  

    # 3. 간판 교체 (오버라이딩): 부모의 display를 덮어씀
    def display(self) -> None:  
        print(f"[VIP★] {self.name} | {self.email} | 할인율: {self.discount_rate:.0%}")
        
    def get_discount(self) -> float:
        return self.discount_rate
```

> 🤖 **AI 프롬프트 예시**: "위 파이썬 코드에서 부모의 display() 메서드와 자식의 display() 메서드가 어떻게 다르게 동작하는지 초보자에게 비유를 들어 설명해줘."

### 코드 2: 실행 및 확인 스크립트

```python
if __name__ == "__main__":
    normal_customer = Customer("김일반", "normal@google.com", 25)
    vip_customer = VIPCustomer("이특별", "vip@google.com", 35, 0.15)
    
    print("--- 고객 정보 출력 ---")
    normal_customer.display()
    vip_customer.display()
```

---


> ⚠️ **코드 검증 결과** (code_validation_report)
> VIPCustomer `__init__` 매개변수 들여쓰기: 17개 공백 사용 (PEP 8은 4의 배수 권장).
> 기능상 문제 없음 — 여는 괄호에 정렬하는 hanging indent 스타일(PEP 8 허용).
> 교육 시 들여쓰기 스타일 선택의 여지를 언급하면 좋습니다.

## §6. 요약

### 핵심 학습 포인트

오늘 배운 "클래스 확장"의 세 가지 핵심 규칙을 기억해 봅시다. 첫째, 부모의 것을 안전하게 물려받고 싶다면 `super().__init__()`으로 "부모님 찬스"를 먼저 씁니다. 둘째, 부모님 찬스가 끝난 바로 다음 줄에 자식만의 새로운 속성(확장)을 덧붙입니다. 셋째, 부모의 행동 방식이 마음에 들지 않으면 똑같은 이름의 메서드를 다시 정의해서 "간판을 교체"합니다(오버라이딩). 이것만 기억하면 객체지향 프로그래밍의 가장 큰 무기인 상속을 100% 활용할 수 있습니다.

### 다음 세션 예고

이제 우리에게는 `Customer`와 `VIPCustomer`라는 두 종류의 고객이 생겼습니다. 그런데 아주 재미있는 질문이 하나 남았습니다. 일반 고객 수십 명과 VIP 고객 수십 명을 한 번에 리스트에 우르르 집어넣고, 반복문으로 똑같이 `get_discount()`를 외치면 어떤 일이 벌어질까요? 다음 세션에서는 "같은 명령, 다른 결과"를 만들어내는 마법, 바로 객체지향의 꽃이라 불리는 "다형성(Polymorphism)"을 체험해 보겠습니다.

### 브릿지 노트

> "여러분, 방금 실습에서 `c1.display()`와 `v1.display()`를 호출하셨죠? 컴퓨터 입장에서 보면 똑같은 단어 `display`를 읽었는데 알아서 다른 행동을 한 거예요! 이것은 마치 리모컨의 '전원 버튼'과 같습니다. TV를 향해 누르면 TV가 켜지고, 에어컨을 향해 누르면 에어컨이 켜지죠. 똑같은 신호인데 대상이 누구냐에 따라 스스로 판단하는 놀라운 현상, 다음 시간에 그 비밀을 파헤쳐 봅시다!"

---

## §7. 참고 자료

### 3-Source 출처

- **Source A (로컬 참고자료)**: `8 코딩.pdf` §8.14 — 상속과 코드 재사용의 개념, 오버라이딩 문법 구조
- **Source B (NotebookLM)**: `day5_notebooklm.md` (SRC-B01) — 상속과 super의 연관 관계, 부모 초기화의 중요성
- **Source C (Deep Research)**: `day5_deep_research.md` (SRC-C01) — 객체지향 패러다임에서의 클래스 확장과 상속 아키텍처 원리

### 추가 학습 자료

- [Python 공식 문서: super()](https://docs.python.org/ko/3/library/functions.html#super): 파이썬 공식 레퍼런스에서의 super() 설명과 예제
- `dataclass` 상속 주의사항: 이전 세션에서 배운 `@dataclass`를 상속할 때 주의해야 할 인자 순서 규칙 (심화)

### 강사 노트

> 💡 **강사 노트**: 초보자들은 오버라이딩(`display`)과 오버로딩(파이썬에서는 기본 미지원)을 헷갈려 하는 경우가 있습니다. 파이썬은 오버라이딩만 직관적으로 지원한다는 점을 가볍게 짚어주셔도 좋습니다. 또한, 파이썬 3.x에서는 `super()` 안에 아무것도 쓰지 않아도 된다는 사실을 알려주시면 타이핑의 부담을 덜어줄 수 있습니다. 

---

## ✅ 세션 완료 체크리스트 (강사용)

- [ ] §1~§7 모든 섹션이 빠짐없이 작성되었는가?
- [ ] 가업 리브랜딩과 부모님 찬스 비유가 §2에서 충분히 설명되었는가?
- [ ] Mermaid 다이어그램이 추가되어 시각적 이해를 돕고 있는가?
- [ ] lab 세션 성격에 맞게 §4 실습 가이드가 상세한 스텝바이스텝으로 구성되었는가?
- [ ] 트러블슈팅 FAQ가 5개 이상 충실히 반영되었는가?
- [ ] 전체 톤앤매너가 자연스러운 한국어 구어체로 작성되었는가?

---

**🔗 선행 세션**: [세션-094] 상속의 개념과 필요성 (필수)  
**🔗 후행 세션**: [세션-096] 다형성 체험 (리모컨의 전원 버튼)

---

*작성 일시: 2026-02-25*  
*작성 에이전트: Antigravity*  
*교안 구조: 7섹션 (A0 팀 공통 표준)*
