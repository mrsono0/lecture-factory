# 세션 074 — 구조적 데이터 흐름(매개변수와 리턴)의 이해

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-074 |
| **소요 시간** | 20분 |
| **난이도** | ★★★ |
| **청크 타입** | code |
| **선행 세션** | 세션-073 (필수) |
| **학습 목표** | 구조적 코드(v2)에서 전역 변수 대신 함수 간 데이터를 주고받는 방식인 매개변수와 리턴의 역할을 설명할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.10 · [B] NotebookLM §5 · [C] Deep Research §1.1, 1.3 |

---

## ① 도입 — "데이터는 어떻게 이동하는가"

🗣️ 강사 대본 (Instructor Script):

여러분, 지난 세션에서 우리는 끝없이 이어지던 길고 긴 코드를 여러 개의 작은 조각으로 나누어 함수라는 이름표를 붙이는 작업을 함께 해보았습니다. 방대한 코드를 기능별로 쪼개어 정리하니 겉보기에는 무척 깔끔해졌죠. 하지만 코드를 나누기만 한다고 해서 모든 문제가 해결되는 것은 결코 아닙니다. 오히려 코드를 방으로 쪼개어 놓았기 때문에, 각 방에 있는 코드들이 서로 대화하는 방법, 즉 데이터를 주고받는 방식이라는 새로운 고민거리가 생겨나게 됩니다. 만약 함수들이 서로 데이터를 주고받지 못한다면, 그것은 마치 각자의 방에 갇혀서 혼잣말만 하는 사람들과 다를 바가 없을 것입니다. 그래서 이번 세션에서는 분리된 함수들이 어떻게 데이터를 안전하게 주고받고 결과를 반환하는지에 대한 아주 중요한 원리를 다루고자 합니다. 이 원리를 제대로 이해하는 순간, 여러분은 단순히 코드를 타이핑하는 사람에서 벗어나, 데이터의 흐름을 지휘하고 설계하는 진정한 소프트웨어 개발자의 시각을 갖추게 될 것입니다.

---

## ② 비유 — 택배 박스와 문지기

🗣️ 강사 대본 (Instructor Script):

이 데이터 흐름을 이해하기 위해 거대한 공장 건물과 그 안에 있는 여러 개의 보안 통제실을 상상해 보시기 바랍니다. 옛날 방식, 즉 우리가 이전에 작성했던 전역 변수에 의존하는 코드는 마치 거대한 공장 한가운데에 누구나 접근할 수 있는 거대한 칠판 하나를 덜렁 놓아둔 것과 같습니다. 생산팀이 칠판에 숫자를 적어놓고 가면, 영업팀이 와서 그 숫자를 지우고 새로운 숫자를 적기도 합니다. 처음에는 이 방식이 빠르고 편해 보일 수 있습니다. 하지만 직원이 수백 명으로 늘어나고 부서가 많아지면 어떻게 될까요? 누군가 칠판의 숫자를 잘못 건드리는 순간, 모든 부서의 업무가 마비되고 대체 누가 언제 숫자를 바꾸었는지 도무지 찾아낼 길이 없어집니다. 프로그래밍의 세계에서는 이것을 전역 변수의 암묵적 변경, 조금 더 전문적인 용어로는 사이드 이펙트라고 부릅니다. 예기치 않은 부작용이라는 뜻이죠.

이러한 끔찍한 대참사를 막기 위해 우리는 구조적 프로그래밍이라는 새로운 규칙을 도입하게 됩니다. 이제 각 부서는 벽으로 단단히 둘러싸인 완벽한 독립된 방을 가지게 됩니다. 그리고 각 방의 입구에는 아주 깐깐한 문지기가 서 있습니다. 다른 방에 있는 누군가에게 작업을 부탁하고 싶다면, 예전처럼 거실의 칠판에 낙서를 하는 것이 아니라, 정확하게 포장된 택배 박스에 데이터를 담아서 그 방의 문지기에게 직접 건네주어야만 합니다. 이때 우리가 문지기에게 건네는 이 택배 박스가 바로 오늘 우리가 배울 매개변수입니다. 문지기는 박스를 받아 방 안으로 전달하고, 방 안의 작업자는 전달받은 재료만으로 열심히 작업을 수행합니다. 작업이 모두 끝나고 완성품이 만들어지면, 작업자는 그 결과물을 다시 작은 상자에 담아 방 밖으로 던져주게 됩니다. 이렇게 방 안에서 밖으로 결과물을 내보내는 행위, 그것이 바로 리턴입니다. 이제 데이터는 오직 문지기를 통과해서 들어오고, 완성된 상자 형태로만 밖으로 나갑니다. 누가 어떤 데이터를 넣었는지, 어떤 결과가 나왔는지 명확하게 추적할 수 있는 안전한 시스템이 완성된 것입니다.

---

## ③ 개념 — 명확한 입출력과 부작용의 통제

🗣️ 강사 대본 (Instructor Script):

앞서 말씀드린 문지기와 택배 박스의 비유를 파이썬의 실제 코드 세계로 연결해 보겠습니다. 파이썬에서 함수를 정의할 때 괄호 안에 적어주는 변수의 이름을 우리는 파라미터라고 부릅니다. 한국어로는 매개변수라고 하죠. 이것은 방 안에서 대기하고 있는 문지기가 "저는 이런 종류의 데이터를 받을 준비가 되어 있습니다"라고 선언하는 것과 같습니다. 반면, 실제로 그 함수를 호출하면서 괄호 안에 구체적인 값을 넣어주는 것을 아규먼트, 즉 인자라고 부릅니다. 다시 말해 파라미터는 문지기의 이름표이고, 아규먼트는 실제로 건네주는 택배 박스의 내용물인 셈입니다. 이 두 가지를 명확히 구분하는 것은 [Source A] 8 코딩.pdf 자료에서도 강조하듯 구조적 프로그래밍의 핵심적인 첫걸음이 됩니다.

그리고 작업이 끝난 후 데이터를 밖으로 내보내는 리턴은 파이썬에서 return이라는 키워드로 구현됩니다. 함수는 이 return을 만나는 순간, 뒤에 적힌 값을 함수를 호출했던 원래의 장소로 툭 던져주고 그 즉시 자신의 생명을 다하며 종료됩니다. 만약 return을 명시하지 않으면 파이썬은 조용히 아무것도 없다는 뜻의 None을 반환하고 끝을 맺습니다. [Source B] NotebookLM과 [Source C] Deep Research의 분석에 따르면, 최근 AI가 생성하는 현대적인 코드들은 예외 없이 이러한 명시적인 매개변수와 리턴을 적극적으로 사용하고 있습니다. 과거처럼 전역 변수를 선언하고 여러 함수가 그 변수를 공유해서 마구잡이로 수정하게 내버려두면, 프로그램이 조금만 복잡해져도 걷잡을 수 없는 버그의 늪에 빠지기 때문입니다. 따라서 데이터가 함수라는 방으로 들어갈 때는 반드시 파라미터를 통과하게 만들고, 함수 밖으로 나올 때는 반드시 리턴을 통해 나오도록 강제하는 것이 우리가 지향해야 할 AI 네이티브 시대의 안전하고 견고한 코딩 원칙입니다.

---

## ④ 코드 데모 — 전역 변수 의존과 명시적 데이터 흐름

🗣️ 강사 대본 (Instructor Script):

자, 그럼 이 중요한 원리가 실제 코드에서는 어떻게 다르게 나타나는지 두 개의 예시를 통해 직접 두 눈으로 확인해 보겠습니다. 화면을 잘 살펴봐 주시기 바랍니다.

```python
# 전역 변수 의존 (Bad)
def calculate_discount():
    global price, rate
    print(price * rate)

# 명시적 데이터 흐름 (Good)
def calculate_discount(price, rate):
    return price * rate
```

먼저 위에 있는 '전역 변수 의존' 코드를 보겠습니다. 함수 정의부의 괄호 안이 텅 비어 있습니다. 문지기가 택배를 받을 준비를 전혀 하지 않고 있다는 뜻입니다. 대신 함수 내부에서 global이라는 위험천만한 키워드를 사용해서 바깥세상의 칠판에 적힌 price와 rate라는 변수를 마음대로 끌어다 쓰고 있습니다. 심지어 계산이 끝난 후에는 return을 하지 않고 그 자리에서 곧바로 print를 해버립니다. 이렇게 작성된 함수는 바깥세상의 상황에 100% 종속되어 버리기 때문에, 나중에 가격 변수의 이름이 바뀌거나 다른 곳에서 이 계산기를 재사용하고 싶을 때 엄청난 재앙을 초래하게 됩니다.

이제 아래쪽에 있는 '명시적 데이터 흐름' 코드를 봐주십시오. 괄호 안에 price와 rate라는 파라미터가 명확하게 자리 잡고 있습니다. 문지기가 "가격과 할인율을 택배로 보내주시면 제가 처리해 드립니다"라고 당당하게 외치고 있는 것이죠. 그리고 함수 내부에는 바깥세상과 연결된 끈이 전혀 존재하지 않습니다. 오로지 전달받은 두 개의 값만 가지고 곱셈을 수행한 뒤, 그 결과물을 return 키워드를 사용해 밖으로 던져줍니다. 이 함수는 그 어떤 환경에 가져다 놓아도 독립적으로 완벽하게 작동하는, 훌륭하게 모듈화된 부품으로 거듭난 것입니다. 여러분은 앞으로 AI와 협업할 때 반드시 아래와 같은 형태로 코드가 짜여 있는지 감시하고 통제하는 역할을 맡으셔야만 합니다.

---

## ⑤ 정리 — 데이터의 고속도로 설계하기

🗣️ 강사 대본 (Instructor Script):

지금까지 우리는 칠판에 마구잡이로 낙서하던 전역 변수 방식에서 벗어나, 문지기에게 택배를 건네고 결과물을 돌려받는 매개변수와 리턴의 위대한 마법을 살펴보았습니다. 이것은 단순히 코드를 예쁘게 꾸미는 일이 아니라, 프로그램 전체의 혈관을 튼튼하게 다시 연결하는 중대한 작업입니다. 데이터가 어디서 들어와서 어디로 나가는지가 투명해지면 오류를 잡는 시간도 획기적으로 줄어들게 됩니다.

> **체크포인트**: "택배 주고받는 법을 배웠으니, 이제 v1과 v2를 나란히 띄워놓고 '틀린 그림 찾기'를 해봅시다. 과연 무엇이 어떻게 달라졌을까요?" — 다음 세션에서 두 코드를 전격 비교해 봅니다!