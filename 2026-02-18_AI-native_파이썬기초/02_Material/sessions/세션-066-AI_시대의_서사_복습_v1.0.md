# 세션 066 — AI 시대의 서사 복습: 구조적 프로그래밍으로의 여정

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-066 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | narrative |
| **선행 세션** | 세션-065 (필수) |
| **학습 목표** | 절차적 프로그래밍의 한계인 '스파게티 코드' 문제를 설명하고 함수 도입의 필요성을 이해할 수 있다 |
| **출처** | [A] AI 시대의 서사 v3 §구조적 프로그래밍으로의 여정 · [B] NotebookLM §2 · [C] Deep Research §1.1 |

---

## ① 도입 — "도미노가 수천 개로 엉키면?"

🗣️ 강사 대본 (Instructor Script):

방금 전 세션에서 절차적 프로그래밍이 '일렬 도미노'라고 배웠죠? 도미노 10개는 멋지게 쓰러지지만, 수천 개가 되면 관리가 불가능해진다고 했습니다. 자, 그럼 실제로 과거의 프로그래머들에게 무슨 일이 벌어졌는지 이야기해볼게요. 이 이야기는 Day 1 오리엔테이션에서 살짝 엿본 'AI 시대의 서사'의 2부에 해당합니다. 프로그래밍의 역사에서 가장 치열했던 전쟁, 스파게티 코드와의 사투가 시작됩니다.

---

## ② 비유 — 엉킨 이어폰 줄과 스파게티

🗣️ 강사 대본 (Instructor Script):

옛날 프로그래머들의 세계를 한번 들여다봅시다. 1960~70년대, 프로그래머들은 코드가 복잡해지면 GOTO라는 명령어를 썼습니다. "이 줄을 실행한 다음, 47번 줄로 펄쩍 뛰어!"라고 지시하는 거예요. 그러면 코드가 위에서 아래로 흐르다가 갑자기 위로 점프하고, 다시 아래로 떨어지고, 또 옆으로 빠지고... 마치 주머니 속에서 1년 동안 방치한 이어폰 줄처럼, 어디서 시작해서 어디로 가는지 알 수 없는 코드가 탄생한 겁니다 [Source A: AI 시대의 서사 v3].

이탈리아 요리 이름을 빌려 이걸 '스파게티 코드(Spaghetti Code)'라고 부릅니다. 면발을 포크로 감아 올리면 뜻하지 않게 옆 면발도 따라오듯이, 코드 한 줄을 고치면 전혀 관계없어 보이는 다른 코드까지 꼬여버리는 거죠 [Source B: NotebookLM §2]. 특히 '전역 변수'라는 녀석이 재앙의 원인이었어요. 동네 광장에 놓인 확성기처럼 누구나 접근할 수 있으니, 누가 언제 값을 바꿨는지 추적이 불가능했습니다.

그래서 1968년, 에츠허르 데이크스트라(Edsger Dijkstra)라는 천재 과학자가 역사적인 논문을 발표합니다. 제목은 놀랍게도 "GOTO문은 해롭다(GOTO Statement Considered Harmful)"였어요. "GOTO문을 쓰지 말자! 대신 순차(Sequence), 선택(Selection), 반복(Iteration), 딱 이 3가지 구조만으로 모든 프로그램을 짤 수 있다!"고 선언한 겁니다. 이것이 바로 Böhm-Jacopini 정리(1966)에 기초한 구조적 프로그래밍의 시작입니다 [Source C: Deep Research §1.1].

---

## ③ 개념 — 구조적 프로그래밍의 탄생

🗣️ 강사 대본 (Instructor Script):

구조적 프로그래밍(Structured Programming)이란, GOTO문을 지양하고, 순차·선택·반복 세 가지 구조만 사용하여 프로그램의 흐름을 통제하는 패러다임입니다 [Source B: NotebookLM §2]. 여기서 핵심은 '함수(Function)'라는 도구예요. 코드를 의미 있는 덩어리로 쪼개서, 각 덩어리에 이름을 붙이는 겁니다. 잘 정리된 서랍장처럼 코드를 용도별로 분류하는 거죠 [Source B].

Day 3에서 우리가 배운 `def` 키워드, 기억나시죠? 그때는 문법만 배웠지만, 오늘부터 그 `def`가 왜 존재하는지, 왜 그토록 중요한지를 몸으로 느끼게 됩니다. 함수는 단순히 코드를 짧게 만들기 위한 도구가 아닙니다. 스파게티를 예방하고, 코드의 각 부분이 서로 독립적으로 작동하게 만드는 '벽'이자 '문'입니다.

그리고 AI 시대에 이 이야기가 더욱 중요한 이유가 있습니다. AI가 초안으로 짜주는 코드는 종종 이런 스파게티 형태를 띱니다. AI를 똑똑한 주니어 개발자로 부리려면, 여러분이 직접 구조를 잡아주는 '시니어' 역할을 해야 한다는 점을 기억하세요. 오늘부터 여러분이 그 시니어가 되는 연습을 합니다.

---

## ④ 코드/활용 — 전역 변수가 일으키는 사고

🗣️ 강사 대본 (Instructor Script):

전역 변수의 위험성을 간단한 가상 시나리오로 느껴봅시다. 프로그램 어딘가에 `discount_rate = 0.1`이라는 전역 변수가 있다고 해요. 계산 함수 A는 이 값을 읽어서 할인을 적용하고, 다른 곳의 함수 B는 이벤트 때문에 이 값을 `0.5`로 바꿔버립니다. 그런데 함수 A가 함수 B보다 늦게 실행되면? 모든 고객이 50% 할인을 받는 대참사가 벌어지죠. 누가 값을 바꿨는지 추적하려면 코드 전체를 뒤져야 합니다.

이게 바로 구조적 프로그래밍 이전의 세계입니다. 순차·선택·반복 세 가지만 쓰고, 데이터를 함수라는 상자 안에 가두면 이런 사고를 근본적으로 막을 수 있습니다. 그래서 우리가 이제부터 할 일은, 일부러 절차적인 '나쁜 코드'를 먼저 만들어보고, 그 고통을 느낀 다음, 함수로 쪼개는 리팩토링을 경험하는 것입니다.

---

## ⑤ 정리 — 스파게티에서 탈출하는 열쇠는 '함수'

🗣️ 강사 대본 (Instructor Script):

정리하면, 과거의 프로그래머들은 GOTO문과 전역 변수로 인한 스파게티 코드의 악몽을 겪었고, 그 해답으로 순차·선택·반복이라는 세 가지 구조와 '함수'를 활용한 구조적 프로그래밍을 탄생시켰습니다. 이것은 우리에게도 그대로 적용됩니다. AI가 만든 코드를 그대로 쓰면 스파게티가 되고, 여러분이 구조를 잡아주면 깔끔한 투룸이 됩니다. 자, 그럼 이 골치 아픈 스파게티를 직접 한 번 만들어볼까요? 그래야 나중에 이걸 어떻게 예쁘게 정리할지 알 수 있거든요. 우리가 Day 2에서 만들었던 기획서를 꺼내봅시다.

> **체크포인트**: "구조적 프로그래밍의 3가지 기본 구조는 무엇인가요?" — 순차, 선택, 반복!
