# 세션 093: 캡슐화 실습 및 v3 코드 리뷰

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-093 |
| **소요 시간** | 25분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | lab |
| **선행 세션** | 092 (필수) |
| **학습 목표** | 파이썬의 이름 장식(Name mangling, `__`)을 활용해 속성을 캡슐화하고, 5대 체크포인트에 맞춰 v3 코드를 최종 리뷰할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 캡슐화와 접근 제어 · [Source A] 9 디버깅,테스트,배포.pdf · [Source C] day5_deep_research.md |

---

## ① 도입 — "뒷문이 열려 있습니다"

🗣️ 강사 대본 (Instructor Script):

여러분, 지난 세션에서 깐깐한 문지기를 세워서 엉터리 전화번호와 이메일이 등록되는 것을 막았습니다. 정문은 완벽하게 지키고 있어요. 그런데 한 가지 실험을 해 봅시다. 코드 어딘가에 `customer._phone = "가나다라"`라고 직접 적어 보세요. 어떻게 될까요? 아무 에러 없이 값이 바뀌어 버립니다. 문지기가 정문을 지키고 있는데, 개발자가 뒷문으로 몰래 들어와서 데이터를 조작해 버린 겁니다. 이것은 마치 은행 창구에서는 본인 확인을 철저히 하는데, 금고 뒷문이 활짝 열려 있는 것과 같습니다. 오늘은 이 뒷문까지 완벽하게 잠그는 실습을 하겠습니다.

---

## ② 비유 — 은행 금고와 은행원

🗣️ 강사 대본 (Instructor Script):

은행을 떠올려 봅시다 [Source A]. 여러분의 예금(데이터)은 어디에 보관되나요? 창구 위에 현금 다발을 올려놓지는 않겠죠. 철저하게 잠긴 금고 안에 보관됩니다. 돈을 넣거나 빼려면 반드시 은행원(메서드)을 통해야 합니다. 은행원은 본인 확인도 하고, 잔액 확인도 하고, 한도 초과 여부도 검사한 뒤에야 비로소 거래를 처리해 줍니다.

파이썬에서 이 "금고"를 만드는 방법이 바로 이름 장식(Name Mangling)입니다 [Source C]. 변수 이름 앞에 밑줄 두 개(`__`)를 붙이면, 파이썬이 내부적으로 변수 이름을 살짝 바꿔버려서 외부에서 직접 접근하기 매우 어렵게 만듭니다. `self.__phone`이라고 선언하면, 밖에서 `customer.__phone`으로 접근하려 할 때 `AttributeError`가 발생합니다. 금고 문이 잠겨 있으니 열쇠(메서드) 없이는 열 수 없는 거예요.

중요한 점 하나 — 파이썬의 `__`는 완벽한 보안 장치가 아닙니다. 정말 마음먹으면 우회할 수 있어요. 하지만 그것은 "실수 방지용"으로 충분합니다. 해킹을 막기 위한 암호화가 아니라, 개발자의 부주의한 실수를 구조적으로 차단하는 안전벨트 같은 역할입니다. AI가 만든 코드라도 캡슐화 원칙이 위배되었다면 반려해야 합니다. "이 속성이 밖에서 직접 변경 가능한가?"를 항상 묻는 리뷰어가 되어야 합니다.

---

## ③ 개념 확인 — __ (더블 언더스코어)의 원리

🗣️ 강사 대본 (Instructor Script):

정리하겠습니다 [Source A][Source C]. 파이썬에서 속성 접근 수준은 세 단계입니다. 첫째, `self.name` — 공개(public) 속성으로, 어디서든 자유롭게 읽고 쓸 수 있습니다. 둘째, `self._name` — 관례적 비공개(protected)로, "건드리지 마세요"라는 개발자 간의 약속이지만 기술적으로는 접근 가능합니다. 셋째, `self.__name` — 이름 장식(name mangling)이 적용되어, 외부에서 `객체.__name`으로 직접 접근하면 `AttributeError`가 발생합니다.

우리가 할 일은 `Customer` 클래스의 핵심 속성들을 `__`로 바꾸고, 이전 세션에서 만든 `@property` setter를 통해서만 값을 변경할 수 있도록 만드는 것입니다. 이렇게 하면 검증 로직을 우회하는 뒷문이 완전히 차단됩니다.

---

## ④ 실습 — 캡슐화 적용 + v3 코드 리뷰

🎙️ 실습 가이드 (Lab Guide):

총 4단계로 진행합니다.

**1단계 (5분) — AI에게 캡슐화 요청**: AI에게 이렇게 요청하세요. "Customer 클래스의 속성들을 캡슐화(`__` 사용)하고, 데이터를 수정할 때 데이터 검증 로직을 거치도록 수정해줘."

```python
class Customer:
    def __init__(self, name: str, phone: str, email: str):
        self.__name = name
        self.phone = phone    # setter 경유 → 검증
        self.email = email    # setter 경유 → 검증

    @property
    def name(self) -> str:
        return self.__name

    @property
    def phone(self) -> str:
        return self.__phone

    @phone.setter
    def phone(self, value: str) -> None:
        import re
        if not re.match(r"^010-\d{4}-\d{4}$", value):
            raise ValueError(f"전화번호 형식 오류: {value}")
        self.__phone = value
```

**2단계 (5분) — 접근 차단 확인**: 코드를 실행한 뒤, 하단에 `print(customer1.__phone)`이라고 적어 보세요. `AttributeError`가 발생하면 금고가 제대로 잠긴 겁니다. 반면 `print(customer1.phone)`은 `@property` getter를 통해 정상적으로 값을 읽어옵니다.

**3단계 (10분) — 코드 리뷰 5대 체크포인트 적용**: Day 4에서 배운 코드 리뷰 5대 체크포인트를 AI에게 던져주고, 우리가 만든 `customer_manager_v3.py` 전체를 평가해 달라고 해보세요. AI가 가독성, 로직 분리, 예외 처리, 네이밍 컨벤션, 확장성을 기준으로 리뷰 리포트를 출력할 겁니다.

**4단계 (5분) — 동료 공유**: 리뷰 결과를 바탕으로, 절차적이었던 v2에 비해 v3가 구조적으로 얼마나 단단해졌는지 옆 사람과 짧게 공유해 보세요. 데이터 보호, 검증, 역할 분리 — 이 세 가지가 체감되셨다면 성공입니다.

---

## ⑤ 정리 — "난공불락의 성이 완성되었습니다"

🗣️ 강사 대본 (Instructor Script):

축하합니다! 캡슐화까지 적용하니 우리의 v3 코드가 정말 단단해졌습니다. 데이터는 금고(`__`) 안에 안전하게 보관되고, 모든 접근은 은행원(`@property` setter)을 통해서만 이루어지며, 은행원은 깐깐한 문지기(검증 로직)를 거친 후에만 거래를 승인합니다. 웬만한 공격에는 무너지지 않는 튼튼한 성을 지은 느낌이죠. 자, 이제 이 튼튼한 성을 더 크게 확장해 볼 시간입니다. 고객은 고객인데 특별 혜택을 받는 "VIP 고객"을 만들어야 한다면 어떻게 해야 할까요? 다음 세션에서 "상속"이라는 강력한 무기를 만나 보겠습니다!
