# 세션 049: 리스트 인덱싱과 슬라이싱

> **세션 ID**: MS-PY101-049 | **소요 시간**: 20분 | **난이도**: ★★☆ (Medium)
> **청크 타입**: code | **선행 세션**: 048(필수) | **후행 세션**: 050
> **출처**: [Source A: 8 코딩.pdf §8.3] [Source B: NotebookLM day3] [Source C: Deep Research day3]

---

## ① 도입 (Hook)

🗣️ 강사 대본 (Instructor Script):

지난 세션에서 우리는 번호표가 붙은 대형 사물함, 리스트를 만들었습니다. 과일도 넣고, 추가도 하고, 삭제도 하고, 정렬까지 해봤죠. 그런데 사물함을 만들어놓고 물건을 꺼내지 않으면 무슨 소용이 있을까요? 자, 이제 사물함에서 물건을 꺼내봅시다. "1번째 칸에 있는 물건 꺼내줘!"라고 파이썬에게 말해볼까요? 어라, 이상하게 내가 생각한 물건이 아니라 그 다음 칸에 있는 게 나옵니다. 왜 그럴까요? 파이썬에는 초보자를 당황하게 만드는 치명적인 비밀이 하나 숨어 있거든요 [Source A: 8 코딩.pdf §8.3].

---

## ② 비유 풀이 (Analogy)

🗣️ 강사 대본 (Instructor Script):

파이썬을 포함한 거의 모든 프로그래밍 언어에는 아주 독특한 규칙이 있습니다. 바로 숫자를 1이 아니라 '0'부터 센다는 거예요. 이걸 '제로 베이스(Zero-base)'라고 부릅니다. 유럽 여행을 가보신 분은 아실 텐데, 유럽식 건물의 엘리베이터는 1층이 아니라 0층(Ground Floor)부터 시작합니다 [Source B: NotebookLM day3]. 우리나라에서 1층이라고 부르는 곳이 유럽에서는 0층이고, 우리의 2층이 유럽의 1층인 거죠. 파이썬의 리스트도 정확히 이 유럽식 엘리베이터와 같습니다. 사물함의 첫 번째 칸은 0번이고, 두 번째 칸이 1번이에요. 그래서 첫 번째 과일을 꺼내려면 `과일[1]`이 아니라 `과일[0]`이라고 불러야 합니다. 처음에는 정말 어색하지만, 프로그래밍을 하다 보면 0부터 세는 게 오히려 자연스러워지는 날이 옵니다 [Source C: Deep Research day3].

AI 통역사에게 데이터의 범위를 지정할 때도 이 규칙을 정확히 알아야 합니다. 통역사가 이해하는 언어는 0부터 시작하는 언어이기 때문에, 우리가 "첫 번째 것 가져와"라고 말하면 통역사는 0번을 가져옵니다. 이 번역 규칙을 모르면 항상 한 칸씩 어긋나는 황당한 상황이 벌어지죠 [Source A: 8 코딩.pdf].

---

## ③ 개념 설명 (What)

🗣️ 강사 대본 (Instructor Script):

이렇게 번호(인덱스)를 사용해서 사물함의 특정 칸에서 물건 하나만 콕 집어 꺼내는 것을 '인덱싱(Indexing)'이라고 합니다. `fruits[0]`은 0번 칸의 물건, `fruits[2]`는 2번 칸의 물건을 꺼내는 거죠. 아주 간단합니다 [Source B: NotebookLM day3].

그런데 물건을 하나가 아니라 여러 개를 한 번에 뭉텅이로 꺼내고 싶을 때도 있잖아요? "0번부터 2번 앞까지만 잘라서 줘!" 이렇게 리스트의 일부분을 잘라내는 것을 '슬라이싱(Slicing)'이라고 합니다. 빵을 칼로 자르듯 리스트를 자르는 거예요. 문법은 `[시작:끝]` 형태인데, 여기서 아주 중요한 주의사항이 있습니다. '끝' 번호에 해당하는 칸은 포함되지 않는다는 겁니다. `fruits[0:2]`라고 하면 0번, 1번까지만 나오고 2번은 빠져요. 수학에서 "이상, 미만"이라고 할 때의 그 '미만'과 같은 원리입니다. 아까 배운 `range()` 함수도 끝 번호를 포함하지 않았던 것 기억나시죠? 파이썬은 이 규칙을 아주 일관되게 적용합니다 [Source C: Deep Research day3].

그리고 파이썬에는 한 가지 더 아주 편리한 기능이 있습니다. 바로 음수 인덱스예요. 뒤에서부터 셀 때는 `-1`부터 시작합니다. 데이터가 100만 개 들어있는 리스트에서 맨 마지막 것을 꺼내려면 일일이 99만 9999번을 세지 않아도 됩니다. 그냥 `[-1]`이라고만 쓰면 끝이에요. 뒤에서 두 번째는 `[-2]`, 세 번째는 `[-3]`. 정말 편하죠? [Source A: 8 코딩.pdf §8.3]

---

## ④ 코드/실제 활용 (How)

🗣️ 강사 대본 (Instructor Script):

자, AI와 함께 인덱싱과 슬라이싱을 직접 실습해 봅시다. AI에게 "월요일부터 일요일까지 요일이 들어있는 리스트를 만들어줘"라고 프롬프트를 입력해 보세요.

```python
# 요일 리스트 생성
days = ["월", "화", "수", "목", "금", "토", "일"]

# 인덱싱: 특정 칸의 물건 하나만 꺼내기
print(days[0])    # "월" (첫 번째 = 0번)
print(days[3])    # "목" (네 번째 = 3번)
print(days[-1])   # "일" (맨 마지막)
print(days[-2])   # "토" (뒤에서 두 번째)

# 슬라이싱: 여러 칸을 한 번에 잘라내기
print(days[0:5])  # ['월', '화', '수', '목', '금'] (평일만!)
print(days[5:])   # ['토', '일'] (주말만! 끝 생략 = 끝까지)
print(days[:3])   # ['월', '화', '수'] (시작 생략 = 처음부터)

# 스텝(step)을 활용한 슬라이싱
print(days[::2])  # ['월', '수', '금', '일'] (하나 건너 하나)
```

🎙️ 실습 가이드 (Lab Guide):

코드를 실행하기 전에 먼저 각 줄의 결과를 예측해 보세요. `days[0]`은 뭐가 나올까요? `days[0:5]`는 몇 개가 나올까요? 예측한 뒤에 실행 버튼을 눌러서 맞는지 확인해 봅시다. 특히 `days[0:5]`에서 5번 인덱스인 "토"가 빠지는 것을 직접 눈으로 확인하는 게 중요합니다. 끝 번호는 포함되지 않는다는 규칙, 이번 실습에서 몸으로 체득하세요. 그리고 한 가지 실험을 더 해볼게요. `days[10]`처럼 리스트 크기보다 큰 번호를 넣으면 어떻게 될까요? 파이썬이 "IndexError"라며 "그런 사물함 칸은 없는데요?"라고 에러를 냅니다. 없는 칸을 열려고 하면 당연히 안 되겠죠? 반면에 슬라이싱에서는 범위를 넘어가도 에러가 나지 않고 있는 데이터까지만 잘라줍니다. 이 차이도 기억해 두면 나중에 큰 도움이 됩니다.

---

## ⑤ 정리 및 다음 세션 예고 (Closing)

🗣️ 강사 대본 (Instructor Script):

정리해 볼까요? 오늘 배운 핵심 세 가지입니다. 첫째, 파이썬은 숫자를 0부터 센다. 둘째, 슬라이싱할 때 끝 번호는 포함되지 않는다. 셋째, 뒤에서부터 셀 때는 `-1`부터 시작한다. 이 세 가지만 기억하면 여러분은 아무리 긴 데이터에서도 원하는 부분을 자유자재로 꺼내고 잘라낼 수 있습니다. 그런데 번호표 사물함은 참 좋은데, 단점이 하나 있어요. "철수의 점수"가 몇 번 칸에 있는지 모르면 처음부터 끝까지 다 뒤져봐야 하거든요. 0번이 이름인지, 나이인지, 전화번호인지 번호만 보고는 알 수가 없잖아요. 만약 번호 대신 "이름", "나이"처럼 의미 있는 이름표를 붙여서 바로 찾을 수 있는 서랍장이 있다면 훨씬 편할 텐데 말이에요. 다음 세션에서 그 마법의 이름표 서랍장, '딕셔너리'를 만나봅시다!
