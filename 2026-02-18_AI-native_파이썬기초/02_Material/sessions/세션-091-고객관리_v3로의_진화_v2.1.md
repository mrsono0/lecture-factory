# 마이크로 세션: 091 — 고객관리 v3로의 진화 (OOP 적용)

> **세션 ID**: MS-PY101-091  
> **소요 시간**: 25분  
> **난이도**: medium  
> **청크 타입**: lab  
> **버전**: v2.1 (7섹션 구조)

---

## §1. 개요

> **Day 5 | AM | 세션 091/106**

### 🎯 학습 목표

이 세션이 끝나면, 수강생은 다음을 할 수 있습니다:

- 절차적 구조의 코드를 `Customer`와 `CustomerManager` 클래스로 분리된 객체지향 구조로 리팩토링할 수 있다.
- AI 프롬프트를 활용하여 데이터와 관리 기능을 분리하는 리팩토링을 수행할 수 있다.
- 기존 v2 코드(절차적)와 개선된 v3 코드(객체지향적)의 차이점을 분석하고 장점을 설명할 수 있다.

### 선행 세션 환기

바로 직전 세션(세션-090)에서 우리는 "부서 조직 재편"의 필요성과 "캡슐화"라는 안전장치의 개념을 배웠습니다. 자동차를 운전할 때 엔진 내부 구조를 몰라도 페달만 밟으면 되는 것처럼, 복잡한 내부를 숨겨서 객체를 안전하고 쉽게 쓰게 만드는 기술이었죠. 이론은 충분히 다졌으니, 이제 실전입니다. Day 4에서 만들었던 `customer_manager_v2.py`를 떠올려보세요. 파일 맨 위에 `customers = []`라는 전역 변수가 덩그러니 놓여 있고, 그 아래로 함수들이 쭉 나열되어 있었습니다. 전형적인 "시장통" 구조였죠. 오늘 이 시장통을 깔끔한 법인 기업으로 탈바꿈시켜 보겠습니다.

---

## §2. 핵심 개념 (+ 🗣️ 강사 대본 + Mermaid)

### 개인 사업자(v2)에서 법인 기업(v3)으로의 진화

우리의 기존 v2 코드는 마치 사장님 혼자서 모든 것을 다 처리하는 "개인 사업자"의 구멍가게와 같습니다. 메인 코드가 장부(`customers = []`)도 관리하고, 손님 응대(`add_customer`)도 하고, 클레임 처리(`delete_customer`)까지 전부 도맡아 하죠. 가게가 작을 때는 문제가 없지만, 손님이 늘어나고 VIP 고객 등 새로운 요구사항이 생기면 사장님은 금방 한계에 부딪히게 됩니다. 장부를 펴놓고 일하다가 누가 슬쩍 건드려도 알아채기 힘들죠.

법인 기업(v3)은 다릅니다. 회사 안에 전문 부서를 신설하는 거예요. 첫 번째 부서는 "고객 데이터 전담팀(`Customer` 클래스)"입니다. 고객 한 명 한 명의 이름, 전화번호, 이메일 같은 명함을 관리합니다. 두 번째 부서는 "경영 관리 총괄팀(`CustomerManager` 클래스)"입니다. 고객 객체들의 목록을 금고에 보관하고 등록, 조회, 수정, 삭제 등의 비즈니스 로직을 총괄합니다. 이렇게 분리하면 각 부서는 자기 역할에만 집중할 수 있게 되고, 다른 부서의 사정에 간섭할 필요가 없어집니다. 확장이 훨씬 쉬워지는 것이죠.

🗣️ **강사 대본 (Instructor Script)**:

> 여러분, 오늘 우리는 코드의 뼈대를 완전히 뜯어고치는 대수술을 할 겁니다. 개인 사업자에서 법인 기업으로 전환하는 과정, 즉 리팩토링(Refactoring)입니다.
> 
> "코드가 이미 잘 돌아가는데 왜 굳이 바꾸나요?"라고 생각하실 수 있어요. 맞습니다, 겉보기엔 똑같이 동작합니다. 하지만 내부 구조는 하늘과 땅 차이입니다. 나중에 VIP 고객 제도를 도입하거나 데이터베이스를 연동할 때, 구멍가게 구조에서는 코드를 전부 뒤엎어야 하지만, 법인 기업 구조에서는 필요한 부서만 확장하면 됩니다.
> 
> 우리는 AI에게 이 리팩토링을 맡길 거예요. 구조를 설계하고 지시하는 것은 아키텍트인 우리의 몫이고, 귀찮은 타이핑과 이전(Migration) 작업은 든든한 조수 AI의 몫입니다. 자, 코드가 어떻게 진화하는지 직접 눈으로 확인해 봅시다.

### Mermaid 다이어그램

```mermaid
flowchart TD
    subgraph v2_개인사업자 ["v2 (절차적 구조)"]
        A[전역 변수\ncustomers = []]
        B(add_customer)
        C(find_customer)
        D(delete_customer)
        A --- B
        A --- C
        A --- D
    end

    subgraph v3_법인기업 ["v3 (객체지향 구조)"]
        direction TB
        E["Customer 클래스\n(고객 데이터 전담)"]
        F["CustomerManager 클래스\n(경영 관리 총괄)"]
        
        F -- "리스트로 관리\nself._customers = []" --> E
        F -. "add()" .-> E
        F -. "find()" .-> E
    end

    v2_개인사업자 ==>|AI 리팩토링| v3_법인기업
    
    style v2_개인사업자 fill:#ffe6e6,stroke:#ff9999
    style v3_법인기업 fill:#e6ffe6,stroke:#99ff99
```

---

## §3. 상세 내용

### Why — 왜 구조를 분리해야 하는가?

프로그램이 커질수록 코드를 역할 단위로 나누는 것은 필수적입니다. v2에서는 `customers`라는 고객 목록 리스트가 프로그램 전역에 노출되어 있었습니다. 누군가 실수로 `customers.clear()`를 호출하면 모든 고객 데이터가 날아가 버릴 수 있었죠.

v3에서는 `CustomerManager`의 내부 속성(`self._customers`)으로 리스트를 쏙 숨겼습니다. 밖에서 떠돌던 데이터가 클래스라는 울타리 안으로 안전하게 들어온 거예요. 이제 데이터를 추가하거나 지우려면 반드시 Manager 부서의 정해진 절차(`add()`, `delete()` 등)를 거쳐야만 합니다. 책임과 권한이 명확해진 것이죠.

### What — Customer와 CustomerManager의 역할

**1. `Customer` 클래스 (데이터 그릇)**
고객 한 명의 데이터를 담는 그릇입니다. 우리가 Day 5 오전에 배운 `@dataclass`를 활용하면 이름, 전화번호, 이메일을 담는 구조를 아주 간결하게 만들 수 있습니다. 그리고 자기 자신의 정보를 예쁘게 출력하는 `display()` 메서드 하나 정도만 가집니다. 복잡한 로직은 가지지 않는 순수한 데이터 객체입니다.

**2. `CustomerManager` 클래스 (관리 총괄)**
이 `Customer` 객체들을 모아놓은 컬렉션(리스트)을 관리하는 매니저입니다. 객체를 생성할 때(`__init__`) 빈 리스트 `self._customers = []`를 준비하고, `add()`, `find()`, `update()`, `delete()` 메서드를 통해 CRUD(생성/조회/수정/삭제) 업무를 수행합니다. 

이러한 분리를 통해, 앞으로 고객 데이터에 나이 속성을 추가하려면 `Customer`만 고치면 되고, 중복 가입을 막는 로직을 추가하려면 `CustomerManager`만 고치면 됩니다. 서로의 영역을 침범하지 않으므로 코드 수정 시 부작용(Side Effect)을 최소화할 수 있습니다.

> ✅ **체크포인트**: 여기까지 이해했는지 스스로 점검해 보세요.
> - `Customer` 클래스와 `CustomerManager` 클래스는 각각 어떤 역할을 담당하나요? ("하나는 데이터를 담고, 하나는 그 데이터들의 목록을 관리한다")
> - 기존 v2의 전역 변수 `customers`는 v3에서 어디로 이동했나요? ("`CustomerManager` 클래스 내부의 `self._customers` 속성으로")

---

## §4. 실습 가이드 (+ 🎙️ 실습 대본)

### 실습 목표

수강생은 Day 4에서 작성한 v2 코드를 AI에게 제공하고, 객체지향적인 v3 코드로 리팩토링하도록 프롬프트를 작성하여 적용합니다. 이후 두 버전의 코드를 나란히 비교하며 구조적 차이를 체감합니다.

🎙️ **실습 가이드 대본 (Lab Guide)**:

> 자, 본격적으로 실습을 시작하겠습니다. 총 4단계로 진행합니다. 여러분의 Antigravity 에디터에 Day 4에서 완성했던 `customer_manager_v2.py` 파일을 열어주세요. 
> 
> 우리가 직접 코드를 전부 뜯어고칠 수도 있지만, 오늘은 AI를 부려먹어 볼 겁니다. AI에게 "내가 만든 이 절차적 코드를 2개의 클래스 구조로 쪼개줘"라고 명확한 설계도(Prompt)를 줄 거예요. AI가 어떻게 찰떡같이 알아듣고 코드를 진화시키는지 확인해 봅시다.
>
> 코드가 완성되면, v2와 v3를 나란히 띄워놓고 "숨은 그림 찾기"를 해볼 거예요. 내가 알던 함수들이 클래스 안으로 어떻게 이사를 갔는지 찾아보는 재미가 쏠쏠할 겁니다. 자, 준비되셨나요? 1단계 프롬프트 작성부터 시작합니다!

### 단계별 지시

| 단계 | 소요 시간 | 강사 지시사항 | 학습자 액션 | 예상 결과 |
|------|----------|--------------|------------|----------|
| 1 | 5분 | "AI에게 리팩토링 프롬프트 작성하기" | v2 코드를 복사하고 AI 프롬프트 실행 | `Customer` 및 `CustomerManager`로 분리된 v3 코드 생성 |
| 2 | 5분 | "새로운 v3 코드로 저장 및 실행 확인" | `customer_manager_v3.py` 저장 후 실행 | 고객 등록, 조회, 삭제 기능 정상 동작 확인 |
| 3 | 5분 | "v2 vs v3 코드 나란히 비교 분석" | 두 파일을 화면 분할하여 비교 | 전역 변수와 함수 위치 이동 확인 |
| 4 | 5분 | "가벼운 코드 리뷰 (5대 체크포인트)" | AI가 짠 코드 리뷰 | 누락된 기능이나 캡슐화 위반 검토 |

**[단계 1] AI에게 리팩토링 지시하기**

Agent Manager (또는 AI 챗) 창에 Day 4의 v2 코드를 복사해서 붙여넣고, 다음 프롬프트를 함께 입력하세요:

> "이 코드를 객체지향으로 리팩토링해줘. `@dataclass`를 사용한 `Customer` 클래스와, 전체 목록을 관리하는 `CustomerManager` 클래스로 나눠줘. 기존 v2의 모든 기능(등록, 조회, 수정, 삭제, 검색)을 빠짐없이 포함해줘. 전역 변수 없이 모두 클래스 내부 속성으로 만들어줘."

**[단계 2] 실행 및 동작 확인**

AI가 생성해준 코드를 복사하여 `customer_manager_v3.py`라는 새 파일로 저장하세요.
터미널에서 `python customer_manager_v3.py`를 실행하여 메뉴가 뜨는지 확인합니다.
기존 v2에서 테스트했던 것처럼, 고객을 한 명 등록해 보고 잘 조회되는지 똑같이 테스트해 보세요. 코드는 바뀌었지만 기능은 동일하게 동작해야 진정한 리팩토링입니다.

**[단계 3] v2 vs v3 나란히 비교 (숨은 그림 찾기)**

에디터 기능을 활용해 `customer_manager_v2.py`와 `customer_manager_v3.py`를 나란히 띄워보세요.
- v2 파일 상단에 있던 `customers = []` 리스트는 어디로 갔나요? (정답: `CustomerManager`의 `__init__` 안으로!)
- `add_customer(customers, ...)` 함수는 어디로 갔나요? (정답: `CustomerManager.add(self, customer)`로 이사했습니다!)

**[단계 4] 가벼운 코드 리뷰**

AI가 짠 코드라고 무조건 믿으면 안 됩니다. Day 4에서 배운 코드 리뷰 5대 체크포인트를 떠올려보세요. 
- 변수명은 명확한가요?
- 예외 처리가 빠진 곳은 없나요?
- 고객을 찾을 수 없을 때의 처리가 v2와 동일하게 잘 구현되어 있는지 확인해 보세요.

> ✅ **체크포인트**: AI가 짜준 코드를 실행해 봤을 때, 에러 없이 잘 돌아가나요? 전역 변수가 사라지고 클래스 구조로 잘 나뉘었나요? 완성되신 분들은 손을 들어주세요!

---


### 🎓 강사 노트 (Instructor Support)

- ⏱️ **타이밍**: 10:50 (25분, code)
- 🎯 **핵심 활동**: Customer + CustomerManager
- ⚠️ **강사 주의사항**: 🎉 관통 프로젝트 3번째 진화

## §5. 코드 및 명령어 모음

### 프롬프트 예시: v3 리팩토링 지시

```text
아래 코드는 절차적 프로그래밍 방식으로 작성된 고객관리 프로그램 v2입니다. 
이를 객체지향 방식(OOP)으로 리팩토링해주세요.

조건:
1. `dataclasses` 모듈의 `@dataclass`를 활용하여 `Customer` 클래스를 만드세요.
2. 고객 목록을 관리하는 `CustomerManager` 클래스를 만드세요.
3. 기존 전역 변수로 있던 `customers` 리스트는 `CustomerManager`의 비공개 속성(`_customers`)으로 넣으세요.
4. 등록, 조회, 수정, 삭제, 출력 기능을 모두 메서드로 이관하세요.
```

### 참고 코드: 완성된 v3 구조의 핵심 부분

```python
from dataclasses import dataclass

@dataclass
class Customer:
    name: str
    phone: str
    email: str

    def display(self) -> None:
        print(f"[고객] {self.name} | {self.phone} | {self.email}")

class CustomerManager:
    def __init__(self):
        # 캡슐화: 외부에서 리스트에 직접 접근하지 못하도록 _ 추가
        self._customers: list[Customer] = []

    def add(self, customer: Customer) -> None:
        self._customers.append(customer)
        print(f"'{customer.name}' 고객이 등록되었습니다.")

    def find(self, name: str) -> Customer | None:
        for c in self._customers:
            if c.name == name:
                return c
        return None

    def list_all(self) -> None:
        for c in self._customers:
            c.display()
```

---

## §6. 요약

### 핵심 학습 포인트

축하합니다! 여러분의 고객관리 프로그램이 개인 사업자(v2)에서 성공적으로 법인 기업(v3)으로 진화했습니다. 밖에서 무방비로 떠돌던 `customers` 리스트가 `CustomerManager`의 내부 금고로 안전하게 들어갔고, 파편화되어 있던 함수들이 관리 부서의 업무(메서드)로 깔끔하게 정리되었습니다. 

겉보기엔 코드가 조금 길어지고 복잡해진 것 같지만, 역할에 따라 데이터와 로직이 서랍 안에 잘 분류되어 있기 때문에 앞으로 프로그램을 확장하거나 버그를 고칠 때 훨씬 유지보수가 쉬워졌습니다. 우리는 코드를 치는 단순 작업은 AI에게 맡기고, '부서를 어떻게 나눌 것인가'라는 구조적 설계에 집중했습니다.

### 다음 세션 예고

하지만 지금의 법인 기업에는 아직 치명적인 허점이 하나 있습니다. 사용자가 나이를 입력해야 하는 곳에 "-10살"이라고 입력하거나, 전화번호에 "가나다라"를 입력해도 시스템이 아무 의심 없이 그대로 데이터를 저장해 버립니다. 다음 세션에서는 아무 데이터나 들어오지 못하도록 깐깐하게 막아주는 강력한 문지기, '검증 로직(Setter)'을 추가하여 프로그램을 더욱 견고하게 만들어 보겠습니다.

### 브릿지 노트

> "모두 코드가 잘 실행되나요? 흩어져 있던 변수와 함수들이 클래스라는 예쁜 상자 안에 쏙 들어간 모습을 보니 기분이 좋죠? 이게 바로 객체지향의 묘미입니다. 그런데 잠깐, 테스트로 이상한 데이터를 한번 넣어보세요. 전화번호에 'ㅋㅋㅋ'라고 치면 어떻게 되나요? 그냥 저장이 되어버리죠? 우리 회사의 데이터베이스가 쓰레기 데이터로 오염되고 있습니다! 다음 세션에서는 이 문젯거리를 완벽하게 막아내는 깐깐한 수문장을 세워보겠습니다."

---

## §7. 참고 자료

### 3-Source 출처

- **Source A (로컬 참고자료)**: 「8 코딩.pdf」 §8.14 — 절차적 코드에서 객체지향 코드로의 리팩토링 개념
- **Source C (Deep Research)**: `day5_deep_research.md` — 고객관리 프로그램 v2에서 v3로의 진화 과정 및 구조 분석

### 추가 학습 자료

- [Python 공식 문서: dataclasses](https://docs.python.org/3/library/dataclasses.html): `@dataclass` 데코레이터의 상세 기능 및 활용법
- [리팩토링(Refactoring)이란?]: 마틴 파울러의 리팩토링 개념과 코드 악취(Code Smell) 해결 전략 기초

### 강사 노트

> 💡 **강사 노트**: 수강생들이 리팩토링을 "어려운 문법을 굳이 써서 코드를 길게 만드는 것"으로 오해하지 않도록 주의해 주세요. 실습 3단계의 "코드 나란히 비교하기"가 가장 중요합니다. 전역 변수가 사라지고 `__init__` 안으로 들어간 점을 명확히 짚어주면 수강생들의 아하 모먼트(Aha moment)를 이끌어낼 수 있습니다. 또한, 다음 세션에서 `@property`를 다루기 위한 빌드업으로 데이터 검증의 필요성을 브릿지 노트에서 강하게 어필해 주세요.

---

## ✅ 세션 완료 체크리스트 (강사용)

- [ ] §1~§7 모든 섹션이 충실하게 작성되었는가?
- [ ] v2(개인 사업자)에서 v3(법인 기업)로의 비유가 잘 연결되었는가?
- [ ] 객체지향 구조의 장점을 설명하는 Mermaid 다이어그램이 적절한가?
- [ ] AI를 활용하는 4단계 실습 가이드가 구체적으로 제시되었는가?
- [ ] 🗣️ 강사 대본과 🎙️ 실습 대본이 분리되어 구어체로 작성되었는가?
- [ ] 3-Source 팩트 패킷의 세션 091 내용이 잘 반영되었는가?
- [ ] 다음 세션(092 검증 로직 추가)으로 이어지는 브릿지가 자연스러운가?

---

**🔗 선행 세션**: [세션-090] 객체지향 리팩토링과 캡슐화 개념 (필수)  
**🔗 후행 세션**: [세션-092] 데이터 검증 함수 추가 (`@property`)

---

*작성 일시: 2026-02-25*  
*작성 에이전트: A4B_Session_Writer*  
*교안 구조: 7섹션 (A0 팀 공통 표준)*