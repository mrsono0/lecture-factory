# 세션 083 — 미니 프로젝트: 구조적 리팩토링 및 퀄리티 체크

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-083 |
| **소요 시간** | 20분 |
| **난이도** | ★★★ |
| **청크 타입** | lab |
| **선행 세션** | 세션-082 (필수) |
| **학습 목표** | 자신의 미니 프로젝트 코드를 구조적으로 리팩토링하고, AI에게 두 버전의 품질 평가(점수 매기기)를 요구하여 개선을 정량적으로 확인할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.10, 8.13 · [C] Deep Research §6.1 |

---

## ① 도입 — "인테리어 공사의 시작"

🗣️ 강사 대본 (Instructor Script):

이전 세션에서 우리는 백지상태에서 출발하여 나만의 아이디어가 담긴 첫 번째 파이썬 프로그램을 성공적으로 탄생시켰습니다. 터미널 창에서 여러분의 지시대로 데이터가 추가되고 삭제되는 모습을 보며 묘한 성취감을 느끼셨을 겁니다. 하지만 개발자의 세계에서 코드가 '일단 돌아간다'는 것은 완성의 의미가 아니라, 이제 막 진짜 작업이 시작되었다는 출발 신호와 같습니다. 지금부터 우리는 모든 기능이 한곳에 엉켜있는 복잡한 코드를 깔끔하게 정돈하는 인테리어 공사에 돌입할 것입니다. 이 과정을 통해 겉으로 드러나는 기능은 그대로 유지하면서도, 내부의 골격을 훨씬 튼튼하고 아름답게 다듬어내는 마법 같은 기술을 배우게 될 것입니다.

---

## ② 비유 — 오디션 심사위원의 채점표

🗣️ 강사 대본 (Instructor Script):

코드를 다듬는 이 과정을 우리는 흔히 '리팩토링'이라고 부릅니다. 리팩토링을 이해하기 위해 거대한 벽도, 방문도 없는 넓은 원룸 창고를 떠올려보세요. 이곳에 냉장고, 침대, 책상, 세탁기를 마구잡이로 구겨 넣어두었습니다. 물론 이곳에서도 잠을 자고 요리를 할 수는 있습니다. 하지만 물건을 하나 찾으려면 창고 전체를 뒤집어엎어야 하고, 새로운 가구를 들여놓으려면 어디에 둬야 할지 막막해집니다. 리팩토링은 바로 이 원룸 창고에 가벽을 세우고, 주방, 침실, 세탁실이라는 명확한 공간표시를 달아주는 작업입니다. 기능은 똑같지만, 구조가 완벽하게 분리되는 것이죠.

그런데 우리가 가벽을 잘 세웠는지, 인테리어가 정말 효율적으로 개선되었는지는 어떻게 알 수 있을까요? 이럴 때 우리는 인공지능을 아주 까다로운 '오디션 심사위원'으로 활용할 수 있습니다. 경연 프로그램에서 심사위원들이 참가자의 춤과 노래를 기술 점수, 예술 점수로 나누어 100점 만점의 채점표를 공개하듯, 우리는 AI에게 우리의 옛날 코드와 새 코드를 던져주고 냉정한 평가를 요구할 수 있습니다. 

단순히 "어느 코드가 더 좋아?"라고 묻는 것은 좋은 프롬프트가 아닙니다. "가독성이라는 기준과 유지보수성이라는 두 가지 명확한 기준으로 100점 만점에 각각 몇 점인지 채점표를 그려줘"라고 구체적으로 지시해야 합니다. AI는 깐깐한 심사위원으로 빙의하여, 원룸 형태의 첫 번째 코드(v1)에는 낙제점을 줄 것이고, 기능별로 방이 나뉜 두 번째 코드(v2)에는 높은 점수와 함께 극찬을 쏟아낼 것입니다. 이 채점표를 두 눈으로 확인하는 순간, 여러분은 왜 수많은 개발자들이 밤을 새워가며 코드를 리팩토링하는지 그 본질적인 이유를 마음 깊이 깨닫게 될 것입니다.

---

## ③ 개념 — 함수 추출과 AI 품질 평가

🗣️ 강사 대본 (Instructor Script):

절차적 코드를 구조적 코드로 리팩토링하는 가장 핵심적인 기술은 바로 '함수 추출(Function Extraction)'입니다. 이전 버전의 코드에서는 무한 반복문 안에서 메뉴 1번을 누르면 추가하는 로직이 길게 이어지고, 2번을 누르면 조회하는 로직이 또 길게 늘어져 있었습니다. 구조적 리팩토링은 이 길쭉한 덩어리들을 뭉텅 잘라내어 `add_data()`, `read_data()`, `update_data()`, `delete_data()`라는 이름을 가진 독립적인 함수로 포장하는 과정입니다. 이렇게 함수로 묶어두면 메인 프로그램에서는 단순히 함수의 이름표만 불러오면 되기 때문에 코드가 마치 목차를 읽는 것처럼 한눈에 쏙 들어오게 됩니다.

[A] 8 코딩 자료의 8.10과 8.13 섹션을 살펴보면, 인공지능을 활용하여 이러한 리팩토링을 수행할 때의 놀라운 효율성이 강조되어 있습니다. 과거에는 개발자가 직접 코드를 오려내고, 변수의 유효 범위(Scope)를 맞추느라 머리를 쥐어뜯었습니다. 하지만 이제 우리는 AI에게 "이 코드를 기능별로 쪼개서 함수 기반으로 리팩토링해줘"라는 단 한 줄의 명령만 내리면 됩니다. [C] Deep Research 문서의 6.1 항목에서도 언급하듯, AI는 단순히 코드를 고치는 것을 넘어 두 코드의 품질을 정량적으로 비교 분석하는 강력한 능력을 지니고 있습니다. 

리팩토링이 끝난 후, 여러분은 반드시 AI에게 가독성(누가 봐도 이해하기 쉬운가?)과 유지보수성(나중에 기능을 추가하기 쉬운가?)이라는 두 잣대로 v1과 v2를 비교해달라고 요청해야 합니다. AI가 작성해준 정량적 채점표를 통해 코드가 얼마나 우아하게 변했는지 수치로 확인하는 경험은, 여러분이 논리적이고 체계적인 프로그래머로 성장하는 데 있어 잊지 못할 이정표가 될 것입니다.

---

## ④ 리팩토링과 채점표 받기 — 함수 기반의 v2 코드

🎙️ 실습 가이드 (Lab Guide):

이제 거대한 원룸 창고를 깔끔한 아파트로 개조해 보겠습니다. 앞서 만든 `my_project_v1.py` 코드를 AI를 통해 함수 기반으로 업그레이드하고, 오디션 심사위원의 냉혹한 평가를 받아봅시다.

| 단계 | 소요 시간 | 행동 지침 | 확인 사항 |
|---|---|---|---|
| **1. 리팩토링 지시** | 5분 | AI에게 기존 v1 코드를 전달하며, 기능별로 함수를 분리한 v2 코드를 만들어달라고 요청합니다. | 프롬프트 예시: "내가 만든 코드를 전달할게. 이 코드를 `add_item()`, `delete_item()` 등 각각의 독립된 함수를 사용하는 구조로 리팩토링해줘." |
| **2. v2 저장 및 테스트** | 5분 | AI가 준 코드를 `my_project_v2.py`로 저장하고, 이전과 똑같이 정상 작동하는지 터미널에서 실행해봅니다. | 코드는 함수들로 예쁘게 나뉘었지만, 사용자가 프로그램을 썼을 때의 겉모습과 기능은 v1과 100% 동일해야 합니다. |
| **3. AI에게 점수표 요청** | 5분 | AI에게 v1과 v2 코드를 비교하여, 구체적인 기준으로 점수를 매겨달라고 요청합니다. | 프롬프트 예시: "v1과 v2를 비교해줘. 가독성, 유지보수성이라는 두 가지 기준으로 각각 100점 만점에 몇 점을 줄 수 있는지 표로 정리하고 이유를 설명해줘." |
| **4. 채점표 확인 및 분석** | 5분 | AI가 만들어준 점수표를 읽고, 함수로 코드를 나누었을 때 구체적으로 어떤 점이 좋아졌는지 스스로 정리해봅니다. | 점수가 왜 50점에서 95점으로 올랐는지, '변수의 스코프가 분리되었다' 등의 피드백을 눈여겨봅니다. |

---

## ⑤ 정리 — 예쁘지만 완벽하진 않은 자동차

🗣️ 강사 대본 (Instructor Script):

수고하셨습니다. AI 심사위원에게 훨씬 높아진 점수를 받고 나니 마음이 아주 뿌듯하실 겁니다. 코드가 함수라는 예쁜 상자들에 나뉘어 담기면서, 이제 어디에 무슨 기능이 있는지 눈 감고도 찾을 수 있는 멋진 구조가 완성되었습니다. 하지만 명심해야 할 것이 있습니다. 자동차의 내부 배선을 아무리 깔끔하게 정리했다고 해서, 그 자동차가 사고가 나지 않는 것은 아닙니다. 구조가 예뻐졌다고 프로그램이 고장 나지 않는 건 아니라는 뜻입니다.

> **체크포인트**: "기존 코드의 외부 동작이나 기능은 전혀 바꾸지 않으면서, 내부의 구조만 깔끔하게 재정비하는 작업을 무엇이라고 하나요?" — 리팩토링(Refactoring)입니다!
