# 세션 069 — 데이터 저장 구조(전역 리스트, 딕셔너리) 이해

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-069 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | code |
| **선행 세션** | 세션-068 (필수) |
| **학습 목표** | AI가 생성한 코드에서 전역 리스트와 딕셔너리가 결합된 데이터 저장 구조를 식별하고 그 원리를 설명할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.9 · [B] NotebookLM §6 · [C] Deep Research §2.1 |

---

## ① 도입 — "데이터는 공중에 둥둥 떠다닐 수 없다"

🗣️ 강사 대본 (Instructor Script):

AI가 코드를 짜주긴 했는데, 실행하기 전에 한 가지 짚고 넘어갈 게 있습니다. 여러분이 고객의 이름, 전화번호, 이메일을 입력하면, 그 데이터는 도대체 어디로 가는 걸까요? 공중에 둥둥 떠다니진 않겠죠. 컴퓨터 메모리 어딘가에 차곡차곡 쌓여야 합니다. AI가 우리 데이터를 어떤 형태로 보관해뒀는지 코드를 열어서 확인해봅시다.

---

## ② 비유 — 서랍장과 라벨이 붙은 칸막이함

🗣️ 강사 대본 (Instructor Script):

데이터 저장 구조를 이해하기 위해 Day 3에서 배운 비유를 다시 꺼내볼게요. 리스트(List)는 '서랍장'입니다. 위에서부터 0번, 1번, 2번 서랍이 차례로 있죠. 딕셔너리(Dictionary)는 각 서랍 안에 들어가는 '라벨이 붙은 칸막이함'이에요. "이름"이라는 라벨이 붙은 칸에는 "홍길동", "전화번호" 칸에는 "010-1234-5678"이 들어가는 식입니다 [Source B: NotebookLM §6].

엑셀을 쓰셨던 분이라면 더 쉬울 거예요. 엑셀 시트의 한 행(Row)이 딕셔너리이고, 시트 전체가 리스트입니다. 그래서 우리의 고객 데이터는 "딕셔너리를 담은 리스트(List of Dictionaries)"라는 구조로 관리됩니다. 이건 파이썬에서 가장 흔하게 쓰이는 데이터 패턴이에요 [Source C: Deep Research §2.1].

한 가지 중요한 포인트가 있습니다. AI에게 '데이터를 어떤 형태로 저장해줘'라고 명확히 지정하지 않으면, AI가 때로는 이상한 형태(예: 문자열을 콤마로 분리해서 저장)를 쓸 수 있어요. 자료구조를 지정하는 것이 AI를 통제하는 시작입니다 [Source B].

---

## ③ 개념 — 파편화 vs 구조화

🗣️ 강사 대본 (Instructor Script):

코드를 열어봅시다. 맨 위에 `customers = []`라는 코드가 보일 거예요. 이게 바로 우리의 '전역 서랍장'입니다. 전역(global)이라는 건, 프로그램의 어느 곳에서든 이 서랍을 열어볼 수 있다는 뜻이에요 [Source A: 8 코딩.pdf §8.9].

이 빈 서랍장에 고객을 넣을 때는 그냥 막 넣지 않습니다. 딕셔너리라는 칸막이함에 깔끔하게 정리해서 넣어요. 만약 딕셔너리 없이 데이터를 관리하면 어떻게 될까요? 아래 두 방식을 비교해보세요.

```python
# ❌ 파편화된 데이터 (Bad) — 연결 고리가 없다!
names: list[str] = ["홍길동", "김철수"]
phones: list[str] = ["010-1111", "010-2222"]
emails: list[str] = ["hong@mail.com", "kim@mail.com"]
# names[0]과 phones[1]을 실수로 매칭하면? 대참사!

# ✅ 구조화된 데이터 (Good) — 한 묶음이 한 고객
customers: list[dict] = [
    {"id": 1, "name": "홍길동", "phone": "010-1111", "email": "hong@mail.com"},
    {"id": 2, "name": "김철수", "phone": "010-2222", "email": "kim@mail.com"},
]
# customers[0]을 꺼내면 홍길동의 모든 정보가 함께 온다!
```

파편화된 방식은 이름, 전화번호, 이메일이 각각 다른 리스트에 흩어져 있어서, 홍길동의 전화번호를 찾으려면 인덱스 번호가 같다는 '약속'에 의존해야 합니다. 실수로 하나만 순서가 어긋나면 홍길동에게 김철수의 번호가 연결되는 사고가 나죠 [Source C: Deep Research §2.1]. 반면 구조화된 방식은 한 고객의 모든 정보가 하나의 딕셔너리에 묶여 있으니, 꺼낼 때도 통째로 나옵니다. 안전하고 직관적이죠.

---

## ④ 코드 데모 — 전역 서랍장의 동작 확인

🗣️ 강사 대본 (Instructor Script):

AI가 짜준 코드에서 이 구조를 직접 확인해봅시다. 코드 최상단에 선언된 `customers = []`가 보이시나요? 이 변수가 프로그램이 실행되는 동안 모든 고객 데이터를 기억하는 유일한 장소입니다. 등록(Create)을 하면 이 리스트에 딕셔너리가 하나 추가되고, 조회(Read)를 하면 이 리스트를 처음부터 끝까지 순회하며 화면에 출력합니다.

한 가지 예측을 해봅시다. 프로그램을 종료했다가 다시 실행하면, 아까 등록한 고객 데이터는 어떻게 될까요? 맞습니다. 사라집니다. 변수는 메모리에 살고 있고, 프로그램이 꺼지면 메모리가 비워지니까요. 이것은 나중에 Day 5에서 파일 저장(FileStorage)을 배울 때 해결하게 됩니다.

---

## ⑤ 정리 — 전역 서랍장의 편리함과 위험성

🗣️ 강사 대본 (Instructor Script):

정리합니다. 우리의 고객 데이터는 '딕셔너리를 담은 전역 리스트'에 저장됩니다. 딕셔너리 덕분에 고객 한 명의 정보가 깔끔하게 묶이고, 리스트 덕분에 여러 고객을 순서대로 관리할 수 있습니다. 전역 변수라서 어디서든 접근할 수 있어 편리하지만, 바로 그 점이 나중에 '위험'으로 변한다는 것을 오후에 뼈저리게 느끼게 될 겁니다. 자, 빈 서랍장이 준비되었으니 이제 진짜로 고객을 서랍에 넣어보고(Create), 다시 꺼내보는(Read) 코드를 돌려보겠습니다.

> **체크포인트**: "우리 프로그램에서 고객 1명의 데이터는 어떤 자료구조에 담기나요?" — 딕셔너리(dictionary)!
