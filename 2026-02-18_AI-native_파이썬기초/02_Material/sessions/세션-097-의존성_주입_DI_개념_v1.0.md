# 세션 097: 의존성 주입(DI) 개념

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-097 |
| **소요 시간** | 20분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | narrative |
| **선행 세션** | 096 (필수) |
| **학습 목표** | 의존성 주입(DI)의 개념을 '교체 가능한 자동차 타이어' 비유로 설명하고, 결합도를 낮추는 이점을 이해할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 의존성 주입 패턴 · [Source B] day5_notebooklm.md · [Source C] day5_deep_research.md |

---

## ① 도입 — "저장 방식을 바꾸려면 코드를 다 뜯어야 합니다"

🗣️ 강사 대본 (Instructor Script):

여러분, 지금까지 만든 고객관리 프로그램은 데이터를 어디에 저장하고 있나요? 메모리, 즉 파이썬 리스트 안에 저장하고 있습니다. 프로그램을 끄면 데이터가 전부 날아가죠. 실제 서비스라면 이건 재앙입니다. 그래서 파일이나 데이터베이스에 저장해야 합니다. 문제는 이겁니다 — 지금 `CustomerManager` 안에 저장 로직을 직접 넣으면, 나중에 파일 저장에서 DB 저장으로 바꿀 때 `CustomerManager`의 코드를 통째로 뜯어고쳐야 합니다. 저장 방식이 바뀔 때마다 비즈니스 로직까지 건드려야 하는 구조, 이것은 좋은 설계가 아닙니다. 오늘은 이 문제를 우아하게 해결하는 "의존성 주입(DI)"이라는 아키텍처 패턴을 배워 보겠습니다.

---

## ② 비유 — 교체 가능한 자동차 타이어

🗣️ 강사 대본 (Instructor Script):

비유를 두 가지 드리겠습니다 [Source A][Source B]. 첫 번째는 "교체 가능한 자동차 타이어"입니다. 자동차(CustomerManager)가 있고, 이 자동차에는 타이어(저장소)가 필요합니다. 만약 타이어가 차체에 용접되어 있다면 어떨까요? 여름 타이어에서 겨울 타이어로 바꾸려면 차를 통째로 분해해야 합니다. 하지만 현실의 자동차는 타이어를 볼트로 끼우는 방식이죠. 볼트만 풀면 여름 타이어를 빼고 겨울 타이어를 끼울 수 있습니다. 차체(비즈니스 로직)는 전혀 건드리지 않아도 됩니다.

두 번째 비유는 "바리스타와 원두 납품업체"입니다 [Source B][Source C]. 바리스타(CustomerManager)가 커피를 내립니다. 바리스타가 직접 원두를 재배하나요? 아닙니다. 원두 납품업체(Storage)로부터 원두를 받아서 커피를 내립니다. 납품업체가 에티오피아산에서 콜롬비아산으로 바뀌어도, 바리스타의 커피 내리는 기술(비즈니스 로직)은 변하지 않습니다. 바리스타는 "원두가 들어오면 커피를 내린다"는 것만 알면 되고, 원두가 어디서 왔는지는 신경 쓰지 않습니다.

이것이 의존성 주입(Dependency Injection, DI)의 핵심입니다 [Source A][Source C]. 내부에서 사용할 의존성(저장소)을 직접 생성하지 않고, 외부에서 만들어서 넣어주는(주입하는) 패턴입니다. `CustomerManager`는 "저장소가 있다"는 것만 알고, 그것이 파일인지 DB인지는 모릅니다. 저장소를 바꾸고 싶으면 외부에서 다른 저장소를 넣어주기만 하면 됩니다. `CustomerManager`의 코드는 한 줄도 바꿀 필요가 없습니다.

---

## ③ 개념 설명 — DI의 원리

🗣️ 강사 대본 (Instructor Script):

DI를 구현하는 핵심 아이디어는 "인터페이스(약속)"입니다 [Source A][Source C]. 모든 저장소가 공통으로 지켜야 할 약속을 먼저 정합니다. "저장소라면 반드시 `save()`와 `load()` 메서드를 가져야 한다." 이 약속을 파이썬에서는 기반 클래스(Base Class)로 표현합니다.

```python
class Storage:
    def save(self, customers: list) -> None:
        raise NotImplementedError

    def load(self) -> list:
        raise NotImplementedError
```

이 `Storage` 클래스는 실제 저장 로직이 없습니다. "나를 상속받는 자식은 반드시 `save()`와 `load()`를 구현해야 한다"는 약속(계약)만 정의합니다. 그리고 `CustomerManager`는 이 `Storage` 타입만 알면 됩니다.

```python
class CustomerManager:
    def __init__(self, storage: Storage):
        self._storage = storage  # 외부에서 주입받음
```

`CustomerManager`의 `__init__`에 `storage` 매개변수가 있습니다. 이것이 "주입구(나사 구멍)"입니다. 외부에서 `JsonFileStorage()`를 넣어주면 파일에 저장하고, `SQLiteStorage()`를 넣어주면 DB에 저장합니다. `CustomerManager`는 어떤 저장소가 들어올지 모르지만, `save()`와 `load()`가 있다는 약속만 믿고 호출합니다.

---

## ④ 코드 미리보기 — DI의 위력

🗣️ 강사 대본 (Instructor Script):

코드로 미리 맛보기를 해 봅시다.

```python
# 저장소를 갈아 끼우는 것만으로 동작이 바뀜
manager1 = CustomerManager(JsonFileStorage())   # 파일 저장
manager2 = CustomerManager(SQLiteStorage())     # DB 저장
```

놀랍지 않나요? `CustomerManager` 코드는 단 한 줄도 바꾸지 않았는데, 생성할 때 어떤 저장소를 넣어주느냐에 따라 파일에 저장할 수도 있고 DB에 저장할 수도 있습니다. 타이어를 갈아 끼우듯, 저장소를 갈아 끼운 겁니다. 이것이 아키텍처의 힘입니다. 다음 두 세션에서 `JsonFileStorage`와 `SQLiteStorage`를 직접 구현해 보겠습니다.

---

## ⑤ 정리 — "만들지 말고, 받아라"

🗣️ 강사 대본 (Instructor Script):

오늘의 핵심을 한 문장으로 정리합니다. 의존성 주입(DI)은 "내부에서 만들지 말고, 외부에서 받아라"는 설계 원칙입니다. 바리스타가 원두를 직접 재배하지 않듯, `CustomerManager`는 저장소를 직접 만들지 않고 외부에서 주입받습니다. 이렇게 하면 저장 방식이 바뀌어도 비즈니스 로직은 한 줄도 수정할 필요가 없습니다. 다음 세션에서는 첫 번째 저장소인 `JsonFileStorage`를 직접 구현해 보겠습니다!
