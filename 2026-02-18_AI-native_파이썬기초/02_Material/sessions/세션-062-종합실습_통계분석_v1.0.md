# 세션 062: 종합실습_통계분석

> **세션 ID**: MS-PY101-062 | **소요 시간**: 25min | **난이도**: ★★★
> **청크 타입**: lab | **선행 세션**: 061(필수) | **후행 세션**: 063
> **출처**: [Source A: 8 코딩.pdf §3.2] [Source B: NotebookLM day3] [Source C: Deep Research day3]

---

## ① 도입 (Hook)

🗣️ 강사 대본 (Instructor Script):

여러분, 우리가 지금까지 파이썬이라는 새로운 언어로 정말 먼 길을 달려왔어요. 세션 060에서는 복잡하고 다양한 형태의 데이터들을 어떻게 설계하고 구조화할지 고민하며 단단한 뼈대를 만들었죠. 그리고 바로 이전 세션인 061에서는 그 데이터 사이를 매끄럽게 흐르는 조건과 반복의 논리, 즉 생명력이 넘치는 로직을 불어넣었습니다. 마치 자동차를 설계하고 엔진까지 장착한 것과 같은 짜릿한 순간이었습니다. 하지만 완성된 자동차가 단순히 굴러가기만 한다고 끝이 아니죠. 그 자동차가 얼마나 빨리 달리는지, 연비는 어떤지 파악하는 계기판이 필요합니다. 우리 프로그램에도 똑같이 남은 마지막 퍼즐 조각이 하나 있습니다. 그게 바로 오늘 우리가 다룰 통계 분석입니다. 

우리가 만든 데이터베이스에 아무리 방대한 학생들의 점수 데이터가 쌓여있어도, 그것을 단순히 화면에 텍스트로만 띄워둔다면 그건 그저 숫자의 나열에 불과해요. 데이터 속에서 의미 있는 패턴을 찾아내고 평균이나 최고점을 뽑아내는 작업이 없다면 코딩의 진짜 매력을 절반밖에 느끼지 못한 셈입니다. [Source C: Deep Research day3]의 심층 연구 사례에서도 확인할 수 있듯이, 가장 복잡해 보이는 데이터 분석 프로젝트의 출발점조차도 결국엔 오늘 우리가 배울 이 기초 통계 산출에서부터 시작된다는 사실을 기억하셔야 합니다. 우리가 세운 뼈대와 엔진 위에, 오늘은 데이터를 한눈에 꿰뚫어 볼 수 있는 강력하고 정교한 계기판을 직접 달아보도록 하겠습니다.

---

## ② 비유 풀이 (Analogy)

🗣️ 강사 대본 (Instructor Script):

통계 분석이라는 단어를 들으면 벌써부터 머리가 아프고 복잡한 수학 공식이 떠오르는 분들도 계실 거예요. 하지만 파이썬이 제공하는 도구들을 사용하면 그 과정은 생각보다 훨씬 재미있고 직관적입니다. 오늘 우리가 배울 핵심 도구들을 아주 크고 튼튼한 '통계용 뜰채'라고 상상해보세요. 우리가 다루고 있는 데이터의 바다에는 수많은 물고기들이 섞여서 헤엄치고 있습니다. 국어 점수, 영어 점수, 수학 점수라는 물고기들이 뒤엉켜 있는 셈이죠. 우리는 여기서 오직 수학 점수라는 특정 물고기만 골라내고 싶습니다. 

이때 우리가 기존에 배웠던 전통적인 반복문이라는 낚싯대를 사용해 한 마리씩 잡아서 양동이에 넣는 방법도 물론 가능합니다. 하지만 파이썬은 우리에게 '리스트 컴프리헨션'이라는 아주 촘촘하고 넓은 특수 뜰채를 제공합니다. 이 뜰채를 한 번 휙 휘두르기만 하면 수백, 수천 마리의 수학 점수 물고기들만 정확하게 걸러져서 새로운 양동이에 담기게 되죠. 방대한 양의 문서에서 핵심 정보만 순식간에 요약해서 건져내는 [Source B: NotebookLM day3]의 인공지능 요약 원리와도 매우 흡사한 과정입니다. 이렇게 뜰채로 수학 점수만 모두 건져냈다면, 이제 양동이의 무게를 달아보는 'sum'이라는 저울, 물고기가 총 몇 마리인지 세어주는 'len'이라는 자동 계수기, 그리고 가장 큰 물고기를 찾아주는 'max'라는 마법의 돋보기를 사용하기만 하면 됩니다. 이렇게 뜰채와 세 가지 도구만 있으면, 아무리 복잡한 데이터라도 순식간에 통계 수치로 변신하는 마법을 경험하시게 될 겁니다.

---

## ③ 개념 설명 (What)

🗣️ 강사 대본 (Instructor Script):

이제 통계용 뜰채의 실제 이름과 사용법을 정확히 짚고 넘어가 보겠습니다. 파이썬 프로그래밍에서 가장 사랑받고 또 가장 자주 쓰이는 문법 중 하나가 바로 리스트 컴프리헨션입니다. 리스트 안에 반복문을 집어넣어서, 기존 리스트의 요소들을 가공해 새로운 리스트를 단 한 줄 만에 만들어내는 아주 우아한 문법이죠. [Source A: 8 코딩.pdf]에서 누누이 강조하는 파이썬 특유의 간결하고 가독성 높은 코딩 스타일, 즉 파이써닉한 코드의 결정체라고 할 수 있습니다. 여러 줄에 걸쳐서 빈 리스트를 만들고, 거기에 반복문으로 하나씩 추가하던 거추장스러운 코드를 단숨에 압축시켜 줍니다.

통계 분석은 길고 복잡할 필요가 전혀 없어요. 리스트 컴프리헨션으로 여러분이 원하는 점수들만 새 리스트로 쫙 뽑아낸 다음에는, 파이썬이 기본으로 제공하는 내장 함수들을 조립하기만 하면 강력한 통계 엔진이 뚝딱 완성됩니다. 리스트 안에 들어있는 모든 숫자를 다 더해주는 sum 함수와, 리스트 안에 요소가 총 몇 개 들어있는지 개수를 알려주는 len 함수를 나누기 기호와 함께 쓰면 그게 바로 평균을 구하는 공식이 됩니다. 가장 높은 숫자를 찾아주는 max 함수나 가장 낮은 숫자를 찾아주는 min 함수도 마찬가지로 단어 하나만 적어주면 스스로 모든 비교를 마친 뒤 결과를 돌려줍니다. 그리고 이 멋진 결과물들을 화면에 출력할 때에는 우리가 예전부터 즐겨 쓰던 f-string이라는 포매팅 기법을 활용해서 소수점 첫째 자리까지만 깔끔하게 잘라내어 보여줄 겁니다. 결국 오늘 배울 내용은 새로운 복잡한 논리를 배우는 것이 아니라, 우리가 이미 알고 있는 도구들을 얼마나 기발하게 결합할 수 있는지 보여주는 조립의 예술에 가깝습니다.

---

## ④ 코드/실제 활용 (How)

🗣️ 강사 대본 (Instructor Script):

그럼 머릿속에 그렸던 뜰채와 계산기 도구들을 실제로 코드 편집기 위에 펼쳐보도록 하겠습니다. 이전 세션에서 우리가 열심히 타이핑해 두었던 학생들의 딕셔너리 리스트 데이터인 학생 변수를 그대로 이어서 사용할 거예요. 코드를 보시면 리스트 컴프리헨션이 어떻게 딕셔너리의 수학 점수 키에 접근해서 데이터만 쏙 빼내는지, 그리고 그렇게 만들어진 새 리스트가 내장 함수와 어떻게 만나는지 그 환상적인 호흡을 확인하실 수 있습니다.

```python
# 수학 점수만 모아서 평균 계산 (리스트 컴프리헨션 + 내장함수)
math_scores = [s["math"] for s in students]
math_avg = sum(math_scores) / len(math_scores)

print(f"수학 평균: {math_avg:.1f}점")
print(f"최고 수학 점수: {max(math_scores)}점")
```

🎙️ 실습 가이드 (Lab Guide):

이제 여러분이 직접 키보드를 잡고 이 통계 엔진을 여러분의 코드에 이식해볼 차례입니다. 실습 시간은 총 이십 분을 드리겠습니다. 처음 십 분 동안은 화면에 보이는 수학 점수 통계 코드를 그대로 따라 쳐보시면서 에러 없이 결과가 잘 출력되는지 확인해 보세요. 특히 출력문 안에서 소수점 자릿수를 제한하는 부분에서 콜론과 점 사이, 그리고 알파벳 위치에서 오타가 나지 않도록 주의 깊게 살펴보시기 바랍니다. 정상적으로 수학 평균과 최고점이 출력되셨다면, 남은 십 분 동안은 스스로에게 새로운 미션을 부여해 볼 시간입니다. 지금은 수학 점수에 대해서만 분석을 진행했지만, 코드를 살짝만 수정해서 영어 점수 리스트를 새롭게 뽑아내고, 영어 점수의 평균과 함께 최저 점수를 구하는 min 함수까지 활용하여 결과를 출력해 보세요. 변수 이름을 직관적으로 짓는 것도 잊지 마시고요. 막히는 부분이 있다면 언제든지 손을 들어 질문해주시면 제가 바로 달려가서 함께 고민해 드리겠습니다.

---

## ⑤ 정리 및 다음 세션 예고 (Closing)

🗣️ 강사 대본 (Instructor Script):

정말 고생 많으셨습니다. 여러분이 방금 완성하신 코드를 찬찬히 들여다보세요. 처음 파이썬을 시작했을 때는 데이터 하나를 출력하는 것도 어색했는데, 이제는 딕셔너리로 묶인 복잡한 구조의 데이터에서 리스트 컴프리헨션으로 원하는 값만 쏙 뽑아내어 통계까지 산출해 내는 어엿한 프로그램을 완성하셨습니다. 데이터 설계, 흐름을 제어하는 로직, 그리고 통계를 통한 분석까지 모든 퍼즐이 드디어 완벽하게 맞춰진 순간입니다. 통계 분석은 길고 복잡할 필요 없음, 리스트 컴프리헨션과 내장 함수 sum, len, max를 조립하면 단 두 줄만으로도 강력한 통계 엔진이 완성된다는 사실을 직접 증명하셨습니다. 여러분 스스로에게 큰 박수를 쳐주셔도 좋을 만큼 훌륭한 성과입니다. 

그런데 여기서 한 가지 재미있는 고민이 생깁니다. 우리가 직접 한 줄 한 줄 짠 코드는 이렇게 소중하고 믿음직스럽지만, 인공지능이 순식간에 뱉어낸 코드는 과연 덮어놓고 언제나 완벽하게 믿어도 될까요? 다음 세션인 063에서는 우리가 코드를 작성하는 개발자의 역할을 넘어, 인공지능이 짠 코드를 냉철하게 평가하고 검증하는 품질 검사관으로 변신해 볼 겁니다. 아주 흥미진진한 코드 리뷰 게임이 준비되어 있으니, 방금 짠 코드들을 잘 저장해 두시고 가벼운 마음으로 다음 세션으로 넘어가 보도록 하겠습니다. 곧바로 이어질 품질 검사관 게임 세션에서 뵙겠습니다.
