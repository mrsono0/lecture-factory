# 마이크로 세션: 071 — 절차적 Update, Delete 구현 및 통합 테스트

> **세션 ID**: MS-PY101-071  
> **소요 시간**: 25분  
> **난이도**: ★★★  
> **청크 타입**: lab  
> **버전**: v2.1 (7섹션 구조)

---

## §1. 개요

> **Day 4 | AM | 세션 071/075**

### 🎯 학습 목표

이 세션이 끝나면, 수강생은 다음을 할 수 있습니다:

- 절차적 방식으로 Update(수정)와 Delete(삭제) 기능을 기존 코드에 통합할 수 있다.
- 수정과 삭제 등 데이터 조작 시 필수적으로 수반되는 '대상 데이터 검색' 로직의 원리를 이해할 수 있다.
- 4가지 기능(CRUD)이 모두 모인 상태에서 통합 테스트를 수행하고 예외 상황을 검증할 수 있다.

### 선행 세션 환기

바로 직전 세션(세션-070)에서 우리는 메뉴 1번(등록)과 2번(조회)을 절차적인 방식으로 뼈대를 잡아보았습니다. 거대한 `while` 루프 안에서 조건문으로 기능을 분기하는 구조를 만들었죠. AI가 짜준 코드를 붙여넣고 실행하니 등록과 조회가 제법 훌륭하게 작동했습니다. 

하지만, 아직 우리는 데이터를 반쪽짜리로만 다루고 있습니다. 현실 세계에서는 한 번 기록된 고객 정보나 데이터가 영원히 변하지 않는 경우가 거의 없기 때문입니다. 고객의 전화번호가 바뀌거나, 회원을 탈퇴하는 일은 늘 일어납니다. 오늘은 이 뼈대에 살을 붙여, 데이터를 완벽하게 제어할 수 있는 메뉴 3번(수정)과 4번(삭제)을 마저 완성해 보겠습니다.

---

## §2. 핵심 개념 (+ 🗣️ 강사 대본 + Mermaid)

### 서랍장 숨바꼭질과 라벨 확인

수정이나 삭제를 하려면 가장 먼저 무엇을 해야 할까요? 무작정 지우개부터 들면 될까요? 아닙니다. 바로 "내가 원하는 대상을 정확하게 찾아내는 일"부터 해야 합니다. 

이 상황을 투명 서랍장에 비유해 보겠습니다. 수백 명의 이름이 적힌 서랍장이 우리 앞에 놓여있고, 누군가 "홍길동이라는 사람의 정보를 이몽룡으로 고쳐주세요"라고 요청합니다. 직원은 어떻게 할까요? 첫 번째 서랍부터 시작해서 붙어있는 이름 라벨을 하나하나 확인해야 합니다. "첫 번째 칸, 김철수? 아니네. 두 번째 칸, 이영희? 아니네. 세 번째 칸, 홍길동! 드디어 찾았다."

이렇게 서랍을 열어가며 내가 찾는 이름과 서랍 안의 이름이 일치하는지 비교하는 숨바꼭질이 바로 검색(Search)의 본질입니다. 삭제를 할 때도 마찬가지입니다. 홍길동을 완전히 없애달라는 요청이 오면, 1번 서랍부터 차례대로 열어보면서 홍길동을 찾아내야만 비로소 그 정보를 꺼내 파기할 수 있습니다. 

🗣️ **강사 대본 (Instructor Script)**:

> 자, 이제 여러분의 프로그램에 Update(수정)와 Delete(삭제) 기능을 추가해 볼 겁니다. 그런데 여기서 잠깐, 코드를 짜기 전에 먼저 생각해 볼까요? 누군가의 정보를 수정하거나 지우려면 컴퓨터는 제일 먼저 무슨 일을 해야 할까요? 
>
> 맞습니다. 바로 '찾는' 일입니다. 서랍장 1번부터 끝번까지 쭉 훑어보면서 "이름이 홍길동인 서랍이 어딨지?" 하고 찾는 과정이 무조건 선행되어야 해요. 이것을 우리는 '검색 로직'이라고 부릅니다.
> 
> 이 과정에서 아주 재미있는 사실을 하나 깨닫게 됩니다. 정보를 수정할 때도 이 숨바꼭질이 필요하고, 지울 때도 똑같은 숨바꼭질이 필요하다는 점이에요. 심지어 나중에 고객 한 명만 콕 집어서 조회하는 기능을 만든다면? 거기서도 또 똑같은 숨바꼭질을 해야 합니다. 코드가 어떻게 될까요? 네, 코드 편집기에 문자 그대로 똑같은 로직이 복사하고 붙여넣기 한 것처럼 반복해서 등장하게 됩니다. 이 점을 꼭 기억하면서 오늘 추가되는 코드를 살펴보세요.

### Mermaid 다이어그램

```mermaid
flowchart TD
    A["메뉴 입력 (3: 수정, 4: 삭제)"] --> B{"검색 로직 (숨바꼭질)"}
    B -->|for 루프 실행| C["순차적으로 고객 데이터 확인"]
    C --> D{"이름이 일치하는가?"}
    D -->|No| C
    D -->|Yes (검색 성공)| E{"선택한 메뉴?"}
    E -->|3: 수정| F["새로운 데이터로 덮어쓰기 (Update)"]
    E -->|4: 삭제| G["리스트에서 데이터 완전히 제거 (Delete)"]
    F --> H["메인 메뉴로 복귀"]
    G --> H
```

---

## §3. 상세 내용

### Why — 왜 수정과 삭제에도 검색 로직이 필요한가?

어떤 대상을 조작하기 위해서는, 컴퓨터 메모리 어딘가에 저장된 그 데이터의 정확한 '위치'를 특정해야 합니다. 파이썬의 리스트(List)는 순서가 있는 데이터의 묶음이므로, 첫 번째 항목부터 끝 항목까지 순차적으로 꺼내보며 비교하는 과정(Sequential Search)이 필수적입니다. 데이터베이스를 사용한다면 이런 검색을 내부적으로 알아서 최적화해 주지만, 현재 우리가 작성하는 기초 수준의 절차적 코드에서는 `for` 루프와 `if` 조건문을 통해 이 검색 과정을 우리가 직접, 매번 코드로 구현해 주어야 합니다.

### What — 모놀리식 스크립트 구조의 덫과 중복

현재 우리는 모든 기능을 하나의 거대한 `while True` 루프 안에 때려 넣고 있습니다. 메뉴 3번(수정)을 선택했을 때도 데이터를 찾는 `for` 문이 통째로 들어가고, 메뉴 4번(삭제)을 선택했을 때도 똑같은 `for` 문이 통째로 들어갑니다.

연구 문헌에서는 이렇게 하나의 무한 루프 안에 모든 기능을 몰아넣는 방식을 '모놀리식 스크립트 구조(Monolithic Script Pattern)'라고 부릅니다. 프로그램이 작동은 하지만, 덩치가 커질수록 눈에 띄게 코드가 길어지고 유지보수가 극도로 어려워지는 전형적인 안티 패턴입니다. 우리는 작동에 초점을 맞춰 코드를 짜고 있지만, 이 과정에서 '코드 중복'이라는 거대한 늪에 발을 들이게 된 것입니다.

### How — 어떻게 코드를 추가하는가?

기존에 만들었던 `while` 루프의 `elif` 조건문 뒤에 메뉴 3번과 4번에 대한 코드를 아래와 같이 이어 붙입니다.
- **수정 로직 (Update)**: `input()`으로 찾을 이름을 입력받은 뒤, `for` 문으로 `customers` 리스트를 돕니다. 일치하는 딕셔너리를 찾으면, 다시 `input()`으로 새 이름을 받아 딕셔너리의 값을 덮어씁니다. (그리고 더 이상 찾을 필요가 없으니 `break`로 루프를 탈출합니다)
- **삭제 로직 (Delete)**: 동일하게 찾을 이름을 입력받고 `for` 문으로 리스트를 돕니다. 일치하는 딕셔너리를 찾으면 파이썬 리스트의 내장 함수인 `.remove()`를 사용하여 해당 요소를 제거합니다. (마찬가지로 `break`로 탈출)

> ✅ **체크포인트**: 여기까지 이해했는지 스스로 점검해 보세요.
> - 수정과 삭제 기능에서 공통적으로 먼저 수행해야 하는, 리스트 안의 특정 대상을 찾아내는 과정을 무엇이라고 부를까요? ("검색(Search)")
> - 절차적 방식으로 작성했을 때, 기능이 늘어날수록 프로그램의 덩치가 급격히 커지는 가장 큰 이유는 무엇인가요? ("동일한 검색 로직이 곳곳에 중복해서 복사/붙여넣기 되기 때문")

---

## §4. 실습 가이드 (+ 🎙️ 실습 대본)

### 실습 목표

이 실습을 통해 수강생은 기존 코드에 Update, Delete 기능을 추가하여 완전한 CRUD를 절차적으로 통합 구현하고, 실전 테스트 시나리오를 바탕으로 예외 상황을 철저하게 검증합니다.

🎙️ **실습 가이드 대본 (Lab Guide)**:

> 자, 이제 드디어 네 가지 기능이 모두 모일 시간입니다. 지난 시간에 만들었던 파일을 다시 열어주세요. 
> 
> AI에게 "우리가 만든 코드에 3번 수정, 4번 삭제 기능을 추가해 줘. 함수 쓰지 말고 메인 while 루프 안에 절차적으로 다 넣어줘"라고 깐깐하게 부탁해 볼 겁니다. 코드가 갑자기 확 길어질 텐데 당황하지 마세요. 
>
> 코드를 다 붙여넣었다면 이제 테스트를 해봐야겠죠? 먼저 1번 메뉴로 여러분의 이름을 하나 등록하고, 3번을 눌러서 이름을 멋지게 바꿔보세요. 2번을 눌러서 잘 바뀌었는지 확인하시고요! 그 다음 4번을 눌러서 방금 만든 이름을 아예 삭제해 보세요. 다시 조회를 눌렀을 때 아무것도 나오지 않는다면 삭제 기능 역시 정상 작동하는 겁니다.
>
> 하지만 가장 중요한 테스트는 지금부터입니다. 4번 삭제나 3번 수정을 누른 다음, 아예 목록에 없는 이상한 이름을 입력해 보세요. "아무개" 같은 거요. 에러 텍스트를 뿜으면서 프로그램이 팍 꺼지나요? 아니면 아무 일 없다는 듯이 조용히 메인 메뉴로 돌아오나요? 오류 없이 첫 화면으로 얌전하게 돌아왔다면 합격입니다. 데이터를 찾지 못했을 때 멈춰버리지 않는 것, 이것이 바로 프로그램 안정성의 기본입니다.

### 단계별 지시

| 단계 | 소요시간 | 강사 지시사항 | 학습자 액션 | 예상 결과 |
|---|---|---|---|---|
| 1 | 5분 | "AI에게 U/D 기능 추가 프롬프트를 입력하세요" | 아래 프롬프트를 Agent Manager에 입력 | 기존 코드에 3, 4번 기능이 추가된 절차적 코드 생성 |
| 2 | 2분 | "IDE에 코드를 적용하고 프로그램을 실행하세요" | 기존 파일 덮어쓰기 후 스크립트 실행 | 터미널에 1~4번 전체 메뉴 표시 |
| 3 | 5분 | "등록, 조회, 수정을 연계해서 테스트하세요" | 이름 등록 → 메뉴 3번으로 수정 → 조회로 검증 | 이름이 정상적으로 변경되어 출력 |
| 4 | 5분 | "삭제 기능 테스트 및 존재하지 않는 이름 입력" | 삭제 실행 후 목록에 없는 이름 삭제 시도 | 데이터 영구 제거, 없는 이름 입력 시 오류 없이 무시됨 |

**[단계 1] AI에게 Update/Delete 추가 요청하기**

Agent Manager 채팅창에 다음 프롬프트를 입력하여 전체 CRUD 코드를 완성해 봅니다.

```text
기존에 만든 C, R 기능이 있는 파이썬 고객 관리 코드에 3.수정, 4.삭제 기능을 마저 추가해 줘.
수정과 삭제를 하려면 고객 리스트를 for문으로 순회하면서 일치하는 이름을 먼저 찾아야 해.
함수를 쓰지 말고, 메인 while 루프 안에 절차적으로 모든 코드를 작성해 줘.
```

AI가 응답한 코드를 훑어보세요. `elif menu == '3':`과 `elif menu == '4':` 아래에 상당히 길고 유사한 코드가 쌍둥이처럼 추가되었을 것입니다.

**[단계 2] 통합 CRUD 코드 덮어쓰기 및 실행**

생성된 코드를 기존 파이썬 파일에 덮어쓰기하고 실행합니다. (아래 §5. 코드 및 명령어 모음에 있는 전체 코드 모습과 비슷한지 확인하세요.)

**[단계 3] 정상 케이스 통합 테스트 (Update 교차 검증)**

1. `1`을 입력하여 '홍길동'을 등록합니다.
2. `3`을 입력합니다. 수정할 이름으로 '홍길동', 새 이름으로 '이몽룡'을 입력합니다.
3. `2`를 입력하여 조회합니다. '홍길동'이 '이몽룡'으로 완벽하게 덮어써진 것을 확인합니다.

**[단계 4] 삭제 및 예외 케이스 테스트 (Delete 방어 검증)**

1. `4`를 입력하고 방금 수정한 '이몽룡'을 지워봅니다.
2. `2`를 입력하여 아무것도 출력되지 않는지 확인합니다. (데이터가 리스트에서 완전히 제거됨)
3. **[중요]** 다시 `4`를 입력하고, 현재 목록에 없는 '아무개'를 당당하게 입력해 봅니다.
4. 프로그램이 붉은 에러 메시지를 뿜어내지 않고 다시 메인 메뉴 화면을 표시하면 완벽하게 통과한 것입니다.

---


### 🎓 강사 노트 (Instructor Support)

- ⏱️ **타이밍**: 11:30 (25분, lab)
- 🎯 **핵심 활동**: U, D 기능 추가 & 통합 테스트
- ⚠️ **강사 주의사항**: 검색 로직이 핵심. 꼼꼼히


### 📋 실습 설계 보강 (Lab Packet)

**세션 071 실습 설계 보강**

절차적 Update, Delete 기능 구현 및 통합 테스트
- **3-Stage Example Set**
  - 기본: U/D 기능 실행 → 등록 → 수정 → 삭제 → 재조회로 전체 사이클 검증
  - 변형: 존재하지 않는 고객을 수정/삭제 시도 → 에러 처리 확인
  - 실수 해결: "삭제했는데 인덱스가 꼬여서 다른 데이터가 삭제됐어요" → 이름 검색 기반 삭제로 전환
- **난이도 예측**: ★★★ "대상 데이터 검색" 로직이 핵심 — for문 안의 if문 활용
- **타이밍 가이드**: U기능 테스트 7분 | D기능 테스트 7분 | 통합 시나리오 5분 | 엣지 케이스 6분
- **심리적 장벽**: "수정이랑 삭제는 등록보다 훨씬 복잡해요"
- **자가 점검**:
  - [ ] 등록→조회→수정→조회→삭제→조회 전체 사이클을 완주했는가?
  - [ ] 존재하지 않는 이름으로 수정/삭제 시도 시 오류 메시지가 나오는가?
  - [ ] CRUD 4가지 기능이 모두 정상 동작하는가?

## §5. 코드 및 명령어 모음

### 완성된 절차적 CRUD 스크립트 (참고 및 대조용)

```python
customers = [{"name": "홍길동"}] # 테스트를 위해 처음부터 들어있는 데이터

while True:
    menu = input("\n1.등록 2.조회 3.수정 4.삭제 0.종료: ")
    
    if menu == '1':
        name = input("이름: ")
        customers.append({"name": name})
        print("등록 완료")
        
    elif menu == '2':
        for c in customers:
            print(f"고객이름: {c['name']}")
            
    elif menu == '3':
        old_name = input("수정할 이름: ")
        # 수정 대상을 찾기 위한 검색 로직 (중복 발생 구간 시작)
        for c in customers:
            if c['name'] == old_name:
                new_name = input("새 이름: ")
                c['name'] = new_name
                print("수정 완료")
                break
                
    elif menu == '4':
        del_name = input("삭제할 이름: ")
        # 삭제 대상을 찾기 위한 검색 로직 (위의 수정 로직과 거의 복사 붙여넣기 수준)
        for c in customers:
            if c['name'] == del_name:
                customers.remove(c)
                print("삭제 완료")
                break
                
    elif menu == '0':
        print("프로그램을 종료합니다.")
        break
```

> 🤖 **AI 프롬프트 예시**: "방금 작성한 코드에서 3번과 4번 메뉴의 for문 코드가 너무 똑같이 생겼어. 혹시 이렇게 코드가 계속 반복되는 게 나중에 문제가 되지는 않을까?" (다음 세션의 빌드업을 위해 AI에게 미리 물어볼 수 있는 질문)

---

## §6. 요약

### 핵심 학습 포인트

훌륭합니다! 여러분은 이제 Create, Read, Update, Delete라는 4대 천왕을 하나의 프로그램 안에 모두 구현해 냈습니다. 데이터베이스 프로그래밍의 가장 기초적이고 완벽한 사이클을 완성한 것이죠. 
특히 Update와 Delete를 구현하기 위해서는 무턱대고 지우는 것이 아니라, 반드시 데이터를 먼저 '검색'해야 한다는 사실을 배웠습니다. 통합 테스트 결과, 기능은 우리가 의도한 대로 완벽하게 작동했으며, 목록에 없는 이름을 입력하는 예외 상황에서도 프로그램이 죽지 않고 든든하게 버텼습니다.

### 작동하지만 아쉬운 코드 (한계점 인식)

하지만 훌륭한 시니어 개발자는 단순히 '작동하는 코드'에 결코 만족하지 않습니다. 화면에 작성된 코드를 스크롤을 내려가며 다시 한번 보세요. 100줄 가까이 팽창한 거대한 하나의 루프, 그리고 조회, 수정, 삭제 메뉴마다 끈질기게 반복되는 `for` 루프 숨바꼭질. 이 코드에는 보이지 않는 커다란 시한폭탄이 숨겨져 있습니다.

### 다음 세션 예고

다음 세션에서는 우리가 방금 만든 자랑스러운(?) 이 코드를 시니어 개발자의 날카로운 시선으로 다시 뜯어봅니다. 절차적 방식이 가진 3대 문제점(전역 상태 오염, 코드 중복, 테스트 불가)이 우리 코드에 어떻게 스며들어 있는지 뼈아프게 체험해 보고, 이 지옥에서 탈출하기 위한 '구조적 리팩토링'의 세계로 넘어갈 준비를 하겠습니다.

---

## §7. 참고 자료

### 3-Source 출처

- **Source A (로컬 참고자료)**: [A] 8 코딩.pdf §8.9 — 절차적 프로그래밍 패턴의 특징과 한계, 거대한 while 루프 분기 기반의 통짜 CRUD 구현.
- **Source B (NotebookLM)**: [B] NotebookLM §3 — 절차적 Update, Delete 구현의 본질, 모놀리식 스크립트 구조가 야기하는 문제점 및 유지보수의 어려움 정의.
- **Source C (Deep Research)**: [C] Deep Research §1.4, §3.1 — 반복적인 검색 로직으로 인한 코드 팽창 현상, 통합 테스트 시 예외(없는 데이터 조회) 방어 케이스의 중요성.

### 강사 노트

> 💡 **강사 노트**: 수강생들이 처음으로 모든 기능이 하나로 연동된 프로그램을 완성하고 성취감을 느끼는 타이밍입니다. 칭찬을 아끼지 마시되, 코드의 '길이'와 '반복'에 대해서는 의도적으로 찝찝함과 불편함을 느끼게끔 유도해 주세요. "스크롤을 한참 내려야 코드를 다 볼 수 있죠?", "수정 기능과 삭제 기능이 쌍둥이처럼 똑같이 생기지 않았나요?"와 같은 질문을 던지며 다음 세션(072 구조적 결함 리뷰)을 위한 심리적 빌드업을 해 주시는 것이 매우 중요합니다.

---

## ✅ 세션 완료 체크리스트 (강사용)

- [ ] §1~§7 모든 섹션이 충실하게 7섹션 구조로 작성되었는가?
- [ ] 서랍장 숨바꼭질 비유가 §2에 적절하게 배치되고 이해하기 쉽게 발전되었는가?
- [ ] §2에 시스템 동작 과정을 한눈에 보여주는 Mermaid 다이어그램이 포함되었는가?
- [ ] §4 실습 가이드에 U/D 통합 테스트 및 예외(없는 데이터 조작) 검증 과정이 상세히 기술되었는가?
- [ ] 🗣️ 강사 대본과 🎙️ 실습 가이드 대본이 구어체로 현장감 있게 작성되었는가?
- [ ] Source A, B, C 출처가 명확히 명시되었는가?
- [ ] 다음 세션(072 구조적 결함 리뷰)을 위한 자연스러운 브릿지가 §6에 포함되었는가?

---

**🔗 선행 세션**: [세션-070] 절차적 Create, Read 기능 구현 및 테스트 (필수)  
**🔗 후행 세션**: [세션-072] 코드 리뷰: 전역 변수와 코드 중복의 한계점 발견

---

*작성 일시: 2026-02-25*  
*작성 에이전트: Sisyphus-Junior (Antigravity)*  
*교안 구조: 7섹션 (A0 팀 공통 표준)*
