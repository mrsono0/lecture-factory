# 세션 091: 고객관리 v3로의 진화 (OOP 적용)

| 항목 | 값 |
|------|-----|
| **세션 ID** | MS-PY101-091 |
| **소요 시간** | 25분 |
| **난이도** | ★★☆ (medium) |
| **청크 타입** | code |
| **선행 세션** | 090 (필수) |
| **학습 목표** | AI 프롬프트를 활용해 절차적 구조의 코드를 `Customer`와 `CustomerManager` 클래스로 분리된 객체지향 구조로 리팩토링하고, 두 코드의 차이점을 설명할 수 있다 |
| **출처** | [Source A] 8 코딩.pdf §8.14 리팩토링 · [Source C] day5_deep_research.md |

---

## ① 도입 — "조직 개편, 지금 시작합니다"

🗣️ 강사 대본 (Instructor Script):

여러분, 방금 전 세션에서 "부서 조직 재편"의 필요성과 "캡슐화"라는 안전장치의 개념을 배웠습니다. 이론은 충분합니다. 이제 실전입니다. Day 4에서 만들었던 `customer_manager_v2.py`를 다 같이 열어 볼까요? 파일 맨 위에 `customers = []`라는 전역 변수가 덩그러니 놓여 있고, 그 아래로 `add_customer()`, `find_customer()`, `update_customer()`, `delete_customer()` 함수들이 쭉 나열되어 있습니다. 전형적인 "시장통" 구조죠. 오늘 이 시장통을 깔끔한 법인 기업으로 탈바꿈시키겠습니다. 개인 사업자(v2)에서 법인 기업(v3)으로의 진화, 시작합니다.

---

## ② 비유 — 개인 사업자에서 법인 기업으로

🗣️ 강사 대본 (Instructor Script):

비유를 이어가 볼게요 [Source A]. 여러분의 v2 코드는 구멍가게 개인 사업자와 같습니다. 사장님(메인 코드) 혼자서 장부(`customers = []`)도 쓰고, 손님 응대(`add_customer`)도 하고, 재고 확인(`find_customer`)도 하고, 클레임 처리(`delete_customer`)도 합니다. 사장님이 만능이라 가게가 돌아가긴 하는데, 손님이 늘어나면 한계가 옵니다. 장부를 펼쳐놓고 손님을 받다가, 다른 손님이 장부를 슬쩍 건드려도 모릅니다.

법인 기업(v3)은 다릅니다 [Source C]. 회사에 두 개의 부서를 신설합니다. 첫 번째는 "고객 데이터 전담팀(`Customer` 클래스)" — 고객 한 명 한 명의 이름, 전화번호, 이메일을 객체로 관리하는 부서입니다. 두 번째는 "경영 관리 총괄팀(`CustomerManager` 클래스)" — 고객 객체들의 목록을 보유하고, 등록·조회·수정·삭제를 총괄하는 부서입니다. 각 부서는 자기 역할에만 집중하고, 다른 부서의 내부 사정에 간섭하지 않습니다.

이 구조의 가장 큰 장점은 확장성입니다. 나중에 "VIP 고객"이라는 새로운 유형이 생겨도, `Customer` 부서만 확장하면 됩니다. `CustomerManager`는 건드릴 필요가 없어요. 마치 회사에 새 팀을 추가해도 경영진의 업무 프로세스는 그대로인 것과 같습니다. AI에게 리팩토링을 맡기면 코드가 어떻게 진화하는지 직접 보시겠습니다. 구조를 설계(명세)하는 것은 우리의 몫이고, 귀찮은 타이핑과 이전(Migration)은 AI의 몫입니다.

---

## ③ 개념 설명 — Customer와 CustomerManager의 역할 분리

🗣️ 강사 대본 (Instructor Script):

코드 구조를 명확히 짚겠습니다 [Source A][Source C]. `Customer` 클래스는 고객 한 명의 데이터를 담는 그릇입니다. 이전 세션에서 배운 `@dataclass`를 활용하면 아주 간결하게 만들 수 있죠. 이름, 전화번호, 이메일 — 이 세 가지 속성을 품고 있으며, 자기 정보를 출력하는 `display()` 메서드 정도를 가집니다.

`CustomerManager` 클래스는 이 `Customer` 객체들의 컬렉션을 관리하는 총괄 매니저입니다. `__init__`에서 빈 리스트 `self._customers = []`를 만들고, `add()`, `find()`, `update()`, `delete()` 메서드로 CRUD를 수행합니다. 핵심은 이겁니다 — v2에서 전역 변수였던 `customers` 리스트가 이제 `CustomerManager`의 내부 속성으로 들어갔습니다. 밖에서 떠돌던 데이터가 클래스라는 울타리 안으로 안전하게 들어온 거예요.

이 분리가 왜 중요할까요? 책임이 명확해지기 때문입니다. "고객 데이터의 형태가 바뀌면 `Customer`만 고치면 되고, 관리 로직이 바뀌면 `CustomerManager`만 고치면 됩니다." 서로의 영역을 침범하지 않으니 수정할 때 다른 곳이 깨질 걱정이 없습니다.

---

## ④ 실습 — AI에게 리팩토링 지시하기

🎙️ 실습 가이드 (Lab Guide):

자, 본격적으로 실습을 시작합니다. 총 4단계로 진행하겠습니다.

**1단계 (5분) — AI에게 리팩토링 프롬프트 작성**: Day 4의 v2 코드를 AI 입력창에 붙여넣고, 이렇게 요청하세요. "이 코드를 객체지향으로 리팩토링해줘. `@dataclass`를 사용한 `Customer` 클래스와, 전체 목록을 관리하는 `CustomerManager` 클래스로 나눠줘. 기존 v2의 모든 기능(등록, 조회, 수정, 삭제, 검색)을 빠짐없이 포함해줘."

```python
from dataclasses import dataclass

@dataclass
class Customer:
    name: str
    phone: str
    email: str

    def display(self) -> None:
        print(f"[고객] {self.name} | {self.phone} | {self.email}")

class CustomerManager:
    def __init__(self):
        self._customers: list[Customer] = []

    def add(self, customer: Customer) -> None:
        self._customers.append(customer)
        print(f"'{customer.name}' 고객이 등록되었습니다.")

    def find(self, name: str) -> Customer | None:
        for c in self._customers:
            if c.name == name:
                return c
        return None

    def list_all(self) -> None:
        for c in self._customers:
            c.display()
```

**2단계 (5분) — 실행 및 동작 확인**: 생성된 코드를 `customer_manager_v3.py`로 저장하고 실행합니다. v2와 똑같이 고객 등록, 조회, 수정, 삭제가 정상 동작하는지 확인하세요.

**3단계 (5분) — v2 vs v3 나란히 비교**: 두 파일을 나란히 띄우세요. 기존의 `add_customer(customers, name, phone, email)` 함수가 v3에서는 `CustomerManager.add(customer)` 메서드로 어떻게 위치를 옮겼는지 찾아보세요. 전역 변수 `customers = []`가 어디로 갔는지도 확인합니다.

**4단계 (5분) — 가벼운 코드 리뷰**: Day 4에서 배운 코드 리뷰 5대 체크포인트를 적용해 AI가 짜준 v3 코드에 누락된 기능이나 버그가 없는지 검토해 봅시다.

---

## ⑤ 정리 — "법인 기업의 탄생"

🗣️ 강사 대본 (Instructor Script):

축하합니다! 여러분의 고객관리 프로그램이 개인 사업자(v2)에서 법인 기업(v3)으로 성공적으로 진화했습니다. 밖에서 떠돌던 `customers` 리스트가 `CustomerManager`의 `__init__` 안으로 쏙 들어갔고, 흩어져 있던 함수들이 클래스의 메서드로 깔끔하게 정리되었습니다. 코드가 좀 길어진 것 같지만, 관련 로직들이 클래스라는 서랍 안에 묶여 있어서 유지보수가 훨씬 쉬워졌습니다. 그런데 지금 구조에서는 사용자가 전화번호에 "가나다라"를 입력해도 그대로 저장이 돼버립니다. 다음 세션에서 깐깐한 검증 로직을 추가해 보겠습니다!
