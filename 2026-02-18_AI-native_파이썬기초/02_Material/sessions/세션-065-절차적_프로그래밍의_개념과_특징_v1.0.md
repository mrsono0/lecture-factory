# 세션 065 — 절차적 프로그래밍의 개념과 특징

| 항목 | 내용 |
|------|------|
| **세션 ID** | MS-PY101-065 |
| **소요 시간** | 20분 |
| **난이도** | ★☆☆ (low) |
| **청크 타입** | narrative |
| **선행 세션** | 세션-064 (권장) |
| **학습 목표** | 절차적 프로그래밍의 개념을 '일렬 도미노'에 비유하여 설명할 수 있다 |
| **출처** | [A] 8 코딩.pdf §8.9 · [B] NotebookLM §1 · [C] Deep Research §1.1, 1.2 |

---

## ① 도입 — "재료는 준비됐는데, 요리법은?"

🗣️ 강사 대본 (Instructor Script):

여러분, 지난 3일 동안 파이썬의 재료들을 하나씩 손질해왔습니다. 변수라는 이름표, 리스트라는 서랍장, 조건문이라는 갈림길, 반복문이라는 컨베이어 벨트, 그리고 함수라는 레시피 카드까지 말이죠. 그런데 이 재료들을 가지고 실제로 '완성된 요리'를 만들려면, 어떤 순서로 조합해야 할까요? 프로그래밍 세계에서 가장 오래되고, 가장 직관적인 요리법이 있습니다. 바로 '절차적 프로그래밍(Procedural Programming)'입니다. 오늘부터 이틀에 걸쳐, 이 오래된 요리법으로 실제 프로그램을 만들어보고, 그 한계를 뼈저리게 느낀 뒤, 더 나은 요리법으로 진화하는 여정을 함께 떠나겠습니다.

---

## ② 비유 — 일렬로 늘어선 도미노

🗣️ 강사 대본 (Instructor Script):

절차적 프로그래밍을 가장 쉽게 이해하는 방법은 '일렬로 세워놓은 도미노'를 떠올리는 겁니다. 여러분이 책상 위에 도미노를 한 줄로 쭉 세워놓았다고 상상해보세요. 첫 번째 도미노를 톡 밀면, 두 번째가 넘어지고, 세 번째, 네 번째가 차르르 쓰러집니다. 절차적 프로그래밍도 정확히 이렇게 동작합니다. 코드가 위에서 아래로, 작성된 순서 그대로 한 줄씩 '정직하게' 실행되는 거예요 [Source A: 8 코딩.pdf §8.9].

이 방식의 가장 큰 장점은 직관성입니다. 코드를 위에서 아래로 읽으면 프로그램이 무엇을 하는지 바로 알 수 있어요. 마치 레시피를 1번부터 순서대로 따라 하면 요리가 완성되는 것처럼요. 컴퓨터 과학 용어로 말하면, 컴퓨터가 '어떻게(How)' 작업을 수행해야 하는지 절차에 집중하는 패러다임입니다 [Source B: NotebookLM §1].

그런데 한 가지 질문을 던져볼게요. 도미노가 10개일 때는 관리가 쉽습니다. 하나 넘어뜨리면 끝이니까요. 그런데 도미노가 1,000개, 10,000개로 늘어나면 어떨까요? 중간에 하나를 빼고 싶거나, 순서를 바꾸고 싶다면요? 잘못 건드렸다가 전체가 와르르 무너질 수도 있습니다. 이게 바로 절차적 프로그래밍이 본질적으로 품고 있는 3대 문제점의 시작입니다. 전역 상태 오염, 코드 중복, 그리고 단위 테스트 불가 — 이 세 가지는 코드가 커질수록 악몽으로 변합니다 [Source C: Deep Research §1.2].

---

## ③ 개념 — 절차적 프로그래밍이란 무엇인가

🗣️ 강사 대본 (Instructor Script):

절차적 프로그래밍을 정의하면 이렇습니다. 코드가 기능 분리 없이 위에서 아래로 순차적으로 실행되며, 전역 변수를 공유하는 프로그래밍 패러다임입니다 [Source A: 8 코딩.pdf §8.9]. 여기서 '기능 분리 없이'라는 말이 핵심이에요. 우리가 Day 3에서 배운 함수(def)를 아직 활용하지 않고, 모든 코드를 한 줄기 물 흐르듯이 쭉 나열하는 방식이라는 뜻입니다.

초기 프로그래머들은 모두 이 방식으로 코드를 작성했습니다. 그리고 놀랍게도, AI에게 "프로그램을 만들어줘"라고 지시하면 AI도 처음에는 이런 도미노 방식의 코드를 던져줍니다. 직관적이고 빠르게 만들 수 있으니까요. 하지만 프로그램의 기능이 3개, 5개, 10개로 늘어나면 코드가 수백 줄로 팽창하고, 특정 부분을 고치려고 스크롤을 올렸다 내렸다 하는 자신을 발견하게 됩니다.

이런 경험을 해보신 분도 계실 거예요. 에러가 어디서 났는지 찾으려고 코드를 처음부터 끝까지 읽어봐야 했던 적. 그때의 막막함이 바로 절차적 코드의 한계에서 오는 겁니다. 지금은 "그래서 어쩌라고?"라는 생각이 드실 수 있어요. 괜찮습니다. 오늘 오전 중으로 이 한계를 직접 체험하고, 오후에는 이 한계를 돌파하는 방법을 배울 테니까요.

---

## ④ 코드 예시 — 절차적 방식의 단면

🗣️ 강사 대본 (Instructor Script):

간단한 예시를 하나 볼까요? 고객 정보를 관리하는 아주 소박한 코드입니다.

```python
# 절차적 방식의 고객 관리 코드 단면
name1: str = "홍길동"
phone1: str = "010-1234-5678"
print(f"고객 추가: {name1}, {phone1}")

name2: str = "김철수"
phone2: str = "010-9876-5432"
print(f"고객 추가: {name2}, {phone2}")

# 고객이 100명이면? 변수가 200개...
```

보이시나요? 고객이 두 명만 되어도 변수가 4개, 출력 코드가 2줄입니다. 고객이 100명이면 변수 200개에 출력 코드 100줄이에요. 게다가 출력 형식을 `"고객 추가:"`에서 `"[등록완료]"`로 바꾸고 싶으면요? 100줄을 전부 찾아서 고쳐야 합니다. 빼먹으면 바로 버그가 되죠. 이게 바로 도미노 1,000개를 관리하는 악몽의 시작입니다 [Source A: 8 코딩.pdf §8.9].

---

## ⑤ 정리 — 도미노의 한계를 기억하세요

🗣️ 강사 대본 (Instructor Script):

정리하겠습니다. 절차적 프로그래밍은 코드가 위에서 아래로 순서대로 흐르는 가장 직관적인 방식이며, 작은 프로그램에서는 빠르고 편리합니다. 하지만 코드가 커질수록 전역 변수 오염, 코드 중복, 테스트 불가라는 세 가지 문제가 기다리고 있습니다. 다음 세션에서는 초기 프로그래머들이 이 도미노가 길어지면서 얼마나 처참한 '스파게티'를 만들어냈는지, 그리고 그들이 어떻게 탈출했는지를 살펴보겠습니다.

> **체크포인트**: "절차적 프로그래밍의 3대 문제점은 무엇인가요?" — 짝꿍에게 한 문장으로 설명해보세요.
